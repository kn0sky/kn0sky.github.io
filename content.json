{"pages":[{"title":"About","date":"2020-03-16T07:54:13.553Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-03-16T07:54:13.553Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-03-16T07:54:13.553Z","path":"tags/index.html","text":""}],"posts":[{"title":"汇编作业--电话簿","date":"2020-05-03T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编作业--电话簿/","text":"汇编作业–电话簿12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**项目名称：**汇编语言电话本**项目背景：**基于同学们学习汇编语言后没有练习的问题，特以该项目作为阶段性练习。**项目目的：**熟悉汇编语言编程，练习编程逻辑，熟悉Win32 API调用模式**项目要求：**编写一个具有增删改查功能的电话本，基于控制台。具体要求如下：1. 基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储2. 增加功能：插入姓名与电话号码到数据结构的最后。3. 查询功能：输入姓名，以此作为依据，到数据结构中查找，将找到的信息打印到控制台。4. 删除功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，且删除该条信息。5. 修改功能：输入姓名或电话号码，以此作为依据，到数据结构中查找，找到后打印信息，要求输入新的姓名或电话，接受后修改原有条目。 **编写指南：****1.****数组的编写方式**TelephoneNumber dd 30 DUP(?) **2.****结构体的编写方式**Name STRUCT具体成员信息Name ENDS **3.****控制台相关的API**GetStdHandle 获得标准输入输出的窗口句柄SetConsoleTextAttribute是设置控制台字体颜色和背景色CONSOLE_CURSOR_INFO用于存放控制光标信息SetConsoleCursorInfo设置光标的信息GetConsoleScreenBufferInfo取得控制台屏幕信息SetConsoleCursorPosition设置光标位置WriteConsoleOutput直接写输入缓冲区SetConsoleTitle设置控制台的标题ReadConsole 读控制台WriteConsole 写控制台 实现基本功能首先，根据前面所学的知识不能够完成本项目，目前以本项目为最终目标，将目标分解成小目标逐个击破 第一步———-基本功能：电话本具有姓名与电话号码两项属性，并且使用数据结构作为存储 数据结构首先要了解数据结构要怎么弄，我们的数据包括姓名和电话两部分，姓名是字符串，电话是数组，应该先弄清楚这两样东西怎么用 字符串定义一个字符串并通过调用消息框输出： 123456789101112131415161718192021222324.586.model flat,stdcallincludelib user32.libincludelib kernel32.libExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD.dataname1 db &quot;警告&quot; ,0name2 db &quot;你菜爆了&quot; ,0.codemain proc push 0 lea eax ,name1 push eax lea eax ,name2 push eax push 0 call MessageBoxA add esp,16 call ExitProcessmain ENDPEND main 通过控制台输出： 123456789101112131415.586.model flat, stdcallinclude msvcrt.incincludelib msvcrt.lib.data szText db &#39;Hello World!&#39;, 0.codemain proc invoke crt_printf, addr szText;类似于call，但比call方便，可直接在后面跟参数 mov eax ,eaxmain endpend main 数组定义一个数组并输出到控制台： 遇到的问题及其解决方案0X01 找不到msvcrt.inv文件 下载MASM SDK文件（http://www.masm32.com/） 安装，C盘装不上装其他盘也可以 在masm32文件夹下找到lib目录中找到msvcrt.lib文件，在include目录中找到msvcrt.inc文件，将它们复制到项目目录下 参考资料 VS常见错误之一：error LNK2019: 无法解析的外部符号 安装masm32 问题：Delete Operation of EXE file has Failed!的解决办法 汇编实现电话本 Tips","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"半导体物理01--能带理论","date":"2020-04-26T14:37:19.000Z","path":"wiki/学习笔记/半导体物理学习笔记/半导体物理01--能带理论/","text":"半导体物理01 – 能带理论认识半导体半导体的主要特征：电阻率可在很大范围内变化 半导体的分类： 元素半导体（单质，比如Si、Ge） 化合物半导体（比如：GaAs、InP） 固溶半导体（混合晶体） 非晶态半导体 有机半导体 半导体的晶格结构： 金刚石结构（共价键 | Si、Ge） 闪锌矿结构（混合键） 纤锌矿结构（混合键） NaCl结构（共价键） 能带理论原子中的电子状态–能级电子运动处于量子态，要完全描述电子的运动需要4个量子数（唯一确定）： 主量子数n（主能级）：表征量子态具有的能量大小，n=1,2,3… 角量子数l（次能级）：表征电子运动的角动量大小， l=0,1,2,3… 磁量子数m：决定轨道角动量在空间的方位，m=0,±1,±2… 自旋量子数s：决定自旋角动量在空间的方位，s=±1/2 主能级n的值决定有多少次能级l 次能级轨道依次为s p d f 磁量子数m和次能级轨道数有关，后面的轨道比前面的轨道m多2 自旋量子数说明电子有两种自旋方向 简并度：指量子态数（由对应能级的磁量子数决定） 电子在量子态上的分布电子填充量子态需遵从2个原则： 泡利不相容原理（计入自旋）：原子中每个量子态最多只能容纳一个电子 能量最低原理：原子中的电子，在不违背泡利不相容原理的前提下，总是先占据能量低的量子态 晶体中的电子状态–能带电子共有化运动： 原子靠近组成晶体，越外层的层壳交叠越多 电子不再局限于某一原子，可以转移到相邻原子上 电子的转移只能在不同原子的相似壳层 电子共有化运动 —&gt; 分裂出若干个相近的能级 —&gt; 形成一个准连续的能带 能带重组： 绝对零度时（0K），半导体、绝缘体、金属的能带区别半导体，绝缘体，金属能带的区别： 绝缘体：导带是空带，价带是满带，禁带距离大 半导体：导带是空带，价带是满带，禁带距离小 金 属：导带是半满，价带是满带，禁带距离无 电子从价带跃迁到导带，使晶体拥有导电特性 满带、空带：不导电 半满带：导电 绝缘体和半导体结构类似，在0K时不导电， 在室温环境下，由于本征激发，半导体有一定的导电性（掺杂之后可以强导电） 半导体中电子的状态和能带单电子近似：晶体中的电子是在晶格的周期性势场（原子核与电子的平均势场）中运动的 布洛赫定理：","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"半导体物理学习笔记","slug":"学习笔记/半导体物理学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础10--使用函数","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础10--使用函数/","text":"汇编基础10 – 使用函数函数编写函数格式： 123function proc codefunction endp 传参方式： 寄存器 堆栈 函数调用调用指令：CALL 格式：CALL OPRD 相当于： 12push EIPjmp OPRD 返回指令：RETN 格式：RETN 相当于： 12pop EIPjmp EIP 示例1：通过栈传递参数 123456789101112131415161718.586.MODEL flat,stdcall.codeaddx proc mov eax ,[esp+4] ;先进栈的，地址位置大，后进的，地址小（小端序） mov ebx ,[esp+8] add eax ,ebx retnaddx endpmain proc push 1 push 2;通过栈传参 call addx mov eax ,eaxmain ENDPEND main 示例2：通过寄存器传递参数 12345678910111213141516.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpmain proc mov eax ,2 mov ebx ,1 call addx mov eax ,eaxmain ENDPEND main 示例3：加减乘除函数 12345678910111213141516171819202122232425262728293031323334353637383940.586.MODEL flat,stdcall.codeaddx proc add eax ,ebx retnaddx endpsubt proc sub eax ,ebx retnsubt endpmult proc mov ebx,[esp+4] mul ebx retmult endpdivi proc div ebx mov ah,ah mov al,al retdivi endpmain proc mov eax ,2 mov ebx ,2 push 15 call addx call subt call mult mov ebx ,1;把ebx清0，方便观察看出栈数据 pop ebx call divi mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础12--数组和结构体","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础12--数组和结构体/","text":"汇编基础12 – 数组和结构体数组的声明和使用： 123456789101112131415161718192021.586.MODEL flat ,stdcall.Datavalu dd 11,22,33;声明并初始化有三个元素的 DWORD 数组; 该数组每个元素是 4 字节;也可以按如下方式写;valu dd 11; dd 22,33.Codemain PROC mov eax,valu ;0x0B mov eax,valu[4] ;0x16 mov eax,valu[8] ;0x21; mov eax,valu[4*0] ;0x0B; mov eax,valu[4*1] ;0x16; mov eax,valu[4*2] ;0x21 mov eax,eaxmain ENDPEND main 使用伪指令DUP： 123456789101112131415.586.MODEL flat ,stdcall.Datavalu dd 3 dup(0).Codemain PROC mov eax,valu mov eax,valu[4] mov eax,valu[8] mov eax,eaxmain ENDPEND main 参考资料 学 Win32 汇编6: 伪指令 DUP 与数组","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础11--win32汇编","date":"2020-04-18T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础11--win32汇编/","text":"汇编基础11 – win32汇编API：（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 [1] 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。 win32汇编是通过使用Windows提供的接口进行编程 示例：hello world！ 123456789101112131415161718192021222324252627.586.MODEL flat,stdcallincludelib user32.libincludelib kernel32.lib;声明函数ExitProcess PROTO, dwExitCode:DWORDMessageBoxA PROTO, hWnd:DWORD ,lpText:BYTE ,lpCaption:BYTE ,uType:DWORD;参数从栈中调用出来，左边的参数在栈下面，右边的在上面.datastr1 db &quot;Hello world&quot; ,0;需要,0结尾，不然报错;db是一个占了8位的类型，db后面的内容视为数据而不视为代码.codemain proc push 1 lea eax ,str1 push eax push eax push 0 call MessageBoxA add esp ,16 ;堆栈平衡 call ExitProcessmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础09--传送指令","date":"2020-04-17T23:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础09--传送指令/","text":"汇编基础09 – 传送指令指令：MOVS 格式：MOVS OPRD1,OPRD2 功能：把DS:SI指向的存储单元中的数据装入ES:DI指向的存储单元中，然后根据DF标志分别增减SI和DI 示例 1234567891011.586.MODEL flat,stdcall.codemain proc mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi];把esi中的数据存储到edi中 mov eax ,eaxmain ENDPEND main 寄存器存储的是内存地址，内存地址里存储的是数据 指令：STOS 格式：STOS OPRD 功能：把AL/AX/EAX/RAX等中的数据存储到DI/EDI（这种为目的串的地址）中，每次执行后，会根据DF的值进行自动调整 把AL或AX中的数据装入ES:DI指向的存储单元，然后根据DF标志增减DI 示例： 12345678910.586.MODEL flat,stdcall.codemain proc mov eax,11223344 mov edi ,esp stos dword ptr es:[edi] mov eax ,eaxmain ENDPEND main 将EAX的值放到目的地址中 指令：REP 格式：REP 功能：重复其后的字符串操作指令。重复前先判断CX是否为0，为0就结束重复，否则CX减1，重复其后的串操作指令。主要用在MOVS和STOS前。一般不用在LODS前。 示例： 12345678910111213.586.MODEL flat,stdcall.codemain proc mov ecx,4 mov edi ,esp mov dword ptr ss:[esp],0;给edi清零 mov esi ,ebp movs dword ptr es:[edi],dword ptr ds:[esi] rep movsb mov eax,eaxmain ENDPEND main 将esi的4个位传送到edi，每重复一次，往后多传送一位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础08： JCC 转移指令","date":"2020-04-17T22:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础08--JCC指令/","text":"汇编基础08： JCC 转移指令常用的JCC指令 JMP：无条件跳转 JZ/JE：ZF =1,也就是比较结果=0[cmp通过相减的方式进行比较(相等)]时跳转 JNZ/JNE：ZF =0，也就是比较结果≠0（不相等）时跳转 JBE/JNA：CF=1/ZF=1 ，低于等于/不高于等于跳转(前面数小于等于后面数) JNBE/JA：CF=0/ZF=0 ，不低于等于/高于等于跳转（前面数大于等于后面数） JL/JNGE：SF!=OF ，小于/不大于等于跳转 JNL/JGE：SF=OF ,不小于/大于等于跳转 注意： 使用JCC指令的时候，前面不要跟影响标志位的指令 一般JCC和CMP指令一起用 JCC指令表","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"使用电脑控制手机","date":"2020-04-17T07:38:51.000Z","path":"wiki/计算机使用入门学习/手机连接电脑/使用电脑控制手机/","text":"使用电脑控制 Android 手机scrcpy（适用Windows、Linux、MacOS）scrcpy 是免费开源的投屏软件，支持将安卓手机屏幕投放在 Windows、macOS、GNU/Linux 上，并可直接借助鼠标在投屏窗口中进行交互和录制。 项目地址：https://github.com/Genymobile/scrcpy Windows软件下载：https://github.com/Genymobile/scrcpy/releases/download/v1.12.1/scrcpy-win64-v1.12.1.zip Windows 下 有线连接 手机开启开发者模式 手机开启USB调试模式 手机和电脑通过数据线连接 双击软件中的scrcpy.exe 即可完成有线连接下的电脑控制手机（手机投屏电脑） Windows 下 无线连接1234567891011# a.将代码目录定位到 scrcpy 文件夹cd D:\\Libraries\\Desktop\\scrcpy-win64-v1.12.1# b.在手机端开启「开发者选项」及「USB 调试」，然后使用数据线将手机和电脑连接并允许 USB 调试，开启手机端口.\\adb tcpip 5555# c.拔出手机数据线，开始无线投屏。(192.168.2.234 为手机端 ip，需更改).\\adb connect 192.168.2.234:5555# d.启动 scrcpy.exe.\\scrcpy 参考资料 scrcpy - 手机无线投屏到电脑","tags":[],"categories":[{"name":"计算机使用入门学习","slug":"计算机使用入门学习","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"name":"手机连接电脑","slug":"计算机使用入门学习/手机连接电脑","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"test","date":"2020-04-14T09:40:50.000Z","path":"wiki/test/","text":"参考资料","tags":[],"categories":[]},{"title":"汇编基础07：比较指令","date":"2020-04-11T07:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础07--比较指令/","text":"汇编基础07：比较指令CMP 格式：CMP OPRD1,OPRD2 功能：对两个数进行相减，进行比较 作用：影响标志位 测试代码： 1234567891011121314.586.MODEL flat,stdcall.codemain proc mov eax ,5 mov ebx ,4 cmp eax ,ebx cmp eax ,5 cmp eax ,ebx cmp eax ,6 cmp eax ,ebx mov eax ,eaxmain ENDPEND main 结果： 当OPDR1 &gt; OPDR2 时：PL=0 ，ZR=0，AC=0，CY=0，PE=0 当OPDR1 = OPDR2 时：PL=0 ，ZR=1，AC=0，CY=0，PE=1 当OPDR1 &lt; OPDR2 时：PL=1 ，ZR=0，AC=1，CY=1，PE=1 TEST 格式：TEST OPRD1,OPRD2 功能：与AND相同，但结果直接抛弃，对标志位进行重新置位","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"前端入门01--HTML和CSS基础","date":"2020-04-06T17:17:33.000Z","path":"wiki/学习笔记/前端入门学习笔记/前端入门01--HTML&CSS基础/","text":"前端入门 01 – HTML和CSS基础环境准备编辑器： VS Code 插件： City Lights Theme Live Server prettier vim HTML 最基础的结构123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 引用 CSS 样式有三种方式引用CSS： 内部引用，CSS比较少时，写在一个文件中看起来方便，或者用在复杂的覆盖层级 1&lt;style&gt;&lt;/style&gt; 外部引用，写在单独一个文件时比较方便，使用在CSS较多时，或者用他人CSS时 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt; 内联样式，作为元素的style属性，常用于覆盖其他样式 123&lt;div style=\"width:50px;\" class=\"red\"&gt; hello world&lt;/div&gt; 内部引用样式优先级顺序取决于写在style标签里的先后顺序，写在后面的会覆盖写在前面的样式 三种样式引用优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 样式选择器 id选择器：选取id属性，例如：#red 类选择器：选取class属性，例如：.red 类型选择器：选取元素类型，例如：div CSS 基本写法基本格式：选择器 + {属性;} 1234.red &#123; background-color:red; width:50px;&#125; 属性名称中带有- 的为子属性 让元素横着排列：向CSS中添加flex属性 1display:flex 改变元素轴向分布：使用justify-content属性 12居中对齐justify-content:center 加边框：使用border属性 12border-width:10px;border-style:solid; 使用flex居中： 123display: flex;justify-content: center;align-items: center; 盒模型待补充","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端入门学习笔记","slug":"学习笔记/前端入门学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"51单片机入门01--LED流水灯","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/51单片机学习笔记/51单片机入门01--LED流水灯/","text":"51单片机入门01–LED流水灯实验环境 Protues Keil 电路图 能流过LED的电流大概是20mA，所以需要加大于250Ω的电阻 仿真软件单片机内部自带复位和时钟电路 代码延时程序：通过空执行循环来达到延时的效果，120次大概是1ms 123456void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;&lt;j++); &#125;&#125; LED流水灯程序：通过移位来实现流水灯功能 1234567891011121314151617void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125; led1函数为共阳的8个led进行流水灯操作 led2函数为共阴的8个led进行流水灯操作 led2函数执行完之后，P1.7端口依然处于高电平，此处用P1 = 0x00；来熄灭 完整代码： 12345678910111213141516171819202122232425262728293031323334353637#include\"reg51.h\"//头文件有两种写法，还有一种是通过&lt;reg51.h&gt;来导入，系统会从默认路径找头文件，通过“”是从用户定义路径查找，然后再去系统路径查找void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125;void led1()&#123; int i=0; for(i=0;i&lt;9;i++)&#123; P2=~(0x01&lt;&lt;i);//0000 0001 --&gt; 0000 0010 --&gt; 0000 0100 delay(200); &#125;&#125;void led2()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P1=0x01&lt;&lt;i; delay(200); &#125; P1 = 0x00;&#125;void main()&#123; P1 = 0x00; while(1)&#123; led1(); led2(); &#125;&#125; 主程序里，先将与P1连接的灯全部熄灭再进行16个led的流水灯操作比较好看 流水灯的通用实现方法 12345678910111213141516171819202122232425#include \"reg51.h\"unsigned char leddat[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;120;j++); &#125;&#125; void led()&#123; int i=0; for(i=0;i&lt;8;i++)&#123; P2=~leddat[i]; delay(100); &#125;&#125;void main()&#123; while(1)&#123; led(); &#125;&#125;","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"学习笔记/51单片机学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础06：数据传送指令","date":"2020-04-04T15:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础06--数据传送指令/","text":"汇编基础06：数据传送指令MOV指令格式：MOV OPDR1,OPDR2 功能：将一个源操作数传送到目的操作数中 OPDR1为目的操作数，可以使寄存器、存储器、累加器 OPDR2为源操作数，可以使寄存器、存储器、累加器、立即数 示例： 123456789.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,eax mov eax ,eaxmain ENDPEND main LEA指令有效地址传送指令 格式：LEA OPDR1,OPDR2 功能：将源操作数给出的有效地址传送到制定寄存器中 OPDR1必须是寄存器 将OPDR2的内存地址给了OPDR1 示例： 12345678.586.MODEL flat, stdcall.codemain proc lea eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main XCHG指令数据交换指令 格式：XCHG OPDR1, OPDR2 功能，两个操作数的值互换 示例： 12345678.586.MODEL flat, stdcall.codemain proc xchg eax ,dword ptr ss:[esp-4] mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础05：堆栈","date":"2020-04-04T14:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础05--堆栈/","text":"汇编基础05：堆栈栈 栈是一种后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的段地址 栈的数据出口位于栈顶，也就是esp寄存器指向的位置 栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向栈底，不会改变 作用： 存储少量数据 保存寄存器环境 传递参数 栈操作PUSH：压栈指令，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入 POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定目标，然后ESP+4，清理空间","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础04：循环","date":"2020-04-04T13:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础04--循环/","text":"汇编基础04：循环循环控制指令：LOOP 格式：LOOP 标号 功能：(CX) &lt;–（CX）-1，（CX）&lt;&gt;0，则转移至标号处循环执行，直至(CX)=0，继续执行后续指令 LOOP执行一次，cx-1，如果cx=0，则会无限循环 示例： 12345678910111213.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,1 mov ecx ,3s: add eax ,ebx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+3+…+100 123456789101112.586.MODEL flat, stdcall.codemain proc mov eax ,0 mov ecx ,100s: add eax ,ecx loop s mov eax ,eaxmain ENDPEND main 练习：1+2+4+8+….+2147483648(0x80000000) 123456789101112131415.586.MODEL flat, stdcall.codemain proc mov eax ,1 mov ebx ,0 mov ecx ,32s: mov edx ,2 add ebx ,eax mul edx loop s mov eax ,eaxmain ENDPEND main","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础03：数学运算&逻辑运算","date":"2020-04-04T12:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础03--数学运算&逻辑运算/","text":"汇编基础03：数学运算&amp;逻辑运算数字运算加法加法指令：ADD 格式：ADD OPRD1 ,OPRD2 功能：两数相加 加法指令运算结果对CF，SF，OF，PF，ZF，AF都有影响，不允许OPRD1 和OPRD2同时为存储器 带进位的加法指令：ADC 功能：OPDR1= OPDR1 + OPDR2 + CF 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,5 mov ebx ,5 add eax ,ebx mov eax ,eaxmain ENDPEND main 减法减法指令：SUB 格式：SUB OPRD1,OPRD2 功能：两个操作数相减，从OPDR1中减去OPDR2，结果保存在OPDR1中 立即数不能用于目的操作数，两个存储器之间的操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数 带借位减法指令：SBB 格式：SBB OPDR1,OPDR2 功能：OPDR1 = OPDR1 - OPDR2 -CF 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,15 mov ebx ,5 sub eax ,ebx mov eax ,eaxmain ENDPEND main 乘法无符号位乘法指令：MUL 格式：MUL OPDR 带符号位乘法指令：IMUL 格式：IMUL OPDR 功能：乘法操作 OPDR位通用寄存器或存储器操作数 本指令影响标志位：CF，OF 乘法指令是将操作数*EAX，并将结果返回EAX，所以只需要一个操作数 示例： 12345678910.586.MODEL flat, stdcall.codemain proc mov eax ,2 mov ebx ,5 mul ebx mov eax ,eaxmain ENDPEND main 除法【待解决疑问】无符号位除法指令：DIV 格式：DIV OPDR 有符号位除法指令：IDIV 格式：IDIV OPDR 功能：实现两个带符号数的二进制除法运算 16bit的被除数，商放在AL，余数放在AH 32bit的被除数，商放在AX，余数放在DX 64bit的被除数，商放在EAX，余数放在EDX 128bit的被除数，商放在RAX，余数放在RDX 示例： 123456789101112.586.MODEL flat, stdcall.codemain proc mov ax,1000 mov bl,50 div bl mov ah,ah mov al,al mov eax,eaxmain ENDPEND main 出现的问题： vs2015里面不能看到变量的变化 自增+1指令：INC 格式：INC OPDR 功能：OPDR = OPDE +1 示例： 12 自减-1指令：DEC 格式：DEC OPDR 功能：OPDR = OPDE -1 逻辑运算与指令：AND 格式：AND OPDR1，OPDR2 影响标志位PF、SF、ZF，使CF = 0 ，OF= 0 主要用于修改操作数或置某些位为零 或指令：OR 格式：OR OPDR1，OPDR2 异或指令：XOR 格式：XOR OPDR1，OPDR2 非指令：NOT 格式：NOT exp","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编基础02：第一个程序","date":"2020-04-04T11:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础02--第一个程序/","text":"汇编基础02：第一个程序Visual Studio 2015 使用：创建汇编项目： 新建项目 模板 ， Visual C++ ， Win32， 控制台程序 名称随便起，确定 选中项目右键“生成自定义”，选择MASM生成规则 右击右边的资源管理器中的源文件，添加，新建项，新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 写代码运行即可 调试汇编程序： 右击项目名称，选择重新生成，然后点上面工作栏的本地Windows调试器即可 可进行断点执行 通过调试的窗口中可将寄存器显示调出来 第一个程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344.586;指定指令集，工作在386版本的都行.MODEL flat, stdcall;使用的内存模式：flat（win32使用的内存模式）;函数调用约定：stdcall（用于win32 API）includelib user32.libincludelib kernel32.lib;导入库ExitProcess PROTO, dwExitCode : DWORDMessageBoxA PROTO hWnd : DWORD, lpText : BYTE , lpCaption : BYTE, uType : DWORD;声明的win32API的原型.dataNumber DWORD 0text db &quot;hello world&quot;,0;数据段，声明多大整多大;定义数据，可读可写，程序直接放在内存里;.data?：不会占用exe的大小，是程序运行的时候申请的;.const：常量，可读不可写.codemain proc;函数体，可以加参数 mov eax ,5 mov ebx ,6 add eax ,ebx add eax ,Number push 0 push offset text push offset text push 0 call MessageBoxA sub esp ,16 call ExitProcessmain ENDP;结束函数END main;结束程序流程;代码段，所有指令都要写在代码段中;数据段不可执行，代码段可执行","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常用工具备忘录","date":"2020-04-04T03:21:13.000Z","path":"wiki/备忘录/常用工具汇总/","text":"常用工具备忘录编程类Visual Studio 2015适用平台：Windows 下载地址：https://msdn.itellyou.cn/ 选择功能：在默认配置的基础上， 勾选编程语言中 的 Visual C++和针对 Visual Studio 的 Python 工具 勾选通用Windows应用开发工具 做图类：ProcessOn适用平台：全平台 Web在线工具：https://www.processon.com/ 高效办公类：Spackdesk适用平台：Windows，macOS 官网：https://spacedesk.net/ 简介：Windows下的软件扩展桌面解决方案 Microsoft To Do适用平台：Windows，Android 下载地址：Microsoft应用商店 简介：挺好用的清单软件","tags":[],"categories":[{"name":"备忘录","slug":"备忘录","permalink":"http://kn0sky.com/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"}]},{"title":"内存","date":"2020-04-02T12:27:19.000Z","path":"wiki/计算机使用基础概念/内存/","text":"内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数： 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构","tags":[],"categories":[{"name":"计算机使用基础概念","slug":"计算机使用基础概念","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"}]},{"title":"寄存器逻辑结构","date":"2020-03-31T05:21:13.000Z","path":"wiki/计算机使用基础概念/寄存器逻辑结构/","text":"寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI","tags":[],"categories":[{"name":"计算机使用基础概念","slug":"计算机使用基础概念","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"}]},{"title":"汇编基础01：基础概念","date":"2020-03-30T06:27:19.000Z","path":"wiki/学习笔记/汇编基础学习笔记/汇编基础01--基础概念/","text":"汇编基础01：基础概念16/32/64位汇编的区别 16位汇编：实模式，16位处理器内部，最多处理存储长度为16位 32位汇编：保护模式，32位处理器内部，最多处理存储长度为32位 64位汇编：保护模式，64位处理器内部，最多处理存储长度为64位 16位处理器只能运行16位汇编， 64位处理器可以运行64和32位汇编， 32位处理器不能运行16位汇编， 因为模式不一样 基本执行环境32位： 8个32位通用寄存器 标志寄存器：EFLAGS 指令指针寄存器：EIP（记录下一条执行的地址） 64位： 8个64位通用寄存器 标志寄存器：RFLAGS 指令指针寄存器：RIP（记录下一条执行的地址） EFLAGS 寄存器包含了独立的二进制位，用于控制CPU操作，或反应CPU执行的结果 MMX 寄存器MMX 寄存器实际上是浮点单元中使用的同样寄存器的别名 XMM 寄存器SIMD的扩展指令集 环境配置 Ollydbg Visual Studio 2015 新建空项目 选中项目右键“生成自定义”，选择MASM生成规则 新建一个.asm后缀的新文件 选中项目右键–属性–链接器–系统–子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt; 选中项目右键–属性–链接器–高级–入口点–填写 “main” 寄存器逻辑结构EAX：累加器，操作数和结果数据累加器，返回值运算结果一般都存在这里 64:RAX 32:EAX 16:AX 8:AH+AL EBX：基地址，DS段的数据指针，在内存寻址的时候存放基地址 64:RBX 32:EBX 16:BX 8:BH+BL ECX：计数器，字符串和循环操作的计数器 64:RCX 32:ECX 16:CX 8:CH+CL EDX：存储部分乘法结果和部分除法被除数 64:RDX 32:EDX 16:DX 8:DH+DL EBP：基址指针，SS段的数据指针 64:RBP 32:EBP 16:BP ESP：栈帧指针，指向栈顶，也叫栈顶指针 64:RSP 32:ESP 16:SP EDI：字符串操作的目标指针，ES段的数据指针 64:RDI 32:EDI 16:DI ESI：字符串操作的原始指针，SS段的数据指针 64:RSI 32:ESI 16:SI 冯·诺依曼体系结构分为5个部分 输入设备–存储器–输出设备，运算器–控制器 内存冯诺依曼中用来存储程序和数据的部件叫做存储器，存储器分为主存储器（内存储器）和辅助存储器，主存储器也叫内存 内存的寻址范围32位系统内存的寻址范围是0x00000000-0xFFFFFFFF 最大寻址范围：0xFFFFFFFF+1(4294967296) 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 4294967296 Byte = 4 GB （32位系统最大内存是4 GB） 64位系统内存寻址范围：0x0000000000000000 – 0xFFFFFFFFFFFFFFFF 内存和寄存器的区别内存：数量庞大，便宜，速度较慢 寄存器：数量少，昂贵，速度极快，位于CPU内部 内存的5种表现形式立即数： 1MOV EAX,DWORD PTR DS:0x????????] 把后面这个内存给EAX 寄存器： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX] 寄存器+立即数： 12MOV EBX ,0x????????MOV EAX ,DWORD PTR DS:[EBX + 4] 比例因子： 1[REG + REG * &#123;1,2,4,8&#125;] 数组元素地址 = 数组首地址 + 元素索引 * 数组元素占用空间 123MOV EAX ,0x????????MOV EBX ,0x2MOV ECX ,DWORD PTR DS:[EAX+EBX*4] 比例因子+立即数： 123MOV EAX,0x????????MOV EBX,0x2MOV ECX,DWORDPTRDS:[EAX + EBX*4 +1] 数据存储模式大端序：数据高位在内存低位，数据低位在内存高位，常用于ARM架构 小端序：数据高位在内存高位，数据低位在内存低位，常用于x86、AMD64架构 参考资料 EFLAGS寄存器中状态标志（Status Flags）小结 x86—EFLAGS寄存器详解","tags":[],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"汇编基础学习笔记","slug":"学习笔记/汇编基础学习笔记","permalink":"http://kn0sky.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"借助云服务器实现hexo全自动部署","date":"2020-03-15T14:36:10.000Z","path":"wiki/计算机使用入门学习/博客搭建/借助云服务器实现hexo全自动部署/","text":"借助云服务器实现hexo全自动部署大家好，我是kn0sky，上一篇我们用hexo搭建了wiki主题个人博客，这次我们来讲讲部署hexo文章我们可以如何偷懒。不想直接把站点文件都传到github上，那自己发布hexo文章需要依次执行3条命令，懒惰的我觉得太麻烦了，于是简单写了个脚本将三条hexo命令简化成一条执行脚本命令，但发布文章还是要执行一条命令啊，还是太麻烦了，后来就在想啊，能不能一条命令也不用输入，完全自动发布文章呢，于是有了本文。 本文的实现思路如下：通过云服务器的定时任务以及和云服务器的实时同步文件来实现全自动部署工作。 本文内容分为如下几部分： 云服务器安装hexo 实现与云服务器的文件实时同步 云服务器定时部署到github page 云服务器安装Hexo安装git和Node.JS首先通过ssh连接到云服务器，具体操作自行百度 我这里使用的云服务器系统是Ubuntu Linux系统，所以本文以Ubuntu Linux为例进行讲解 Ubuntu Linux默认自带git，所以我们还需要自行安装一下Node.JS： 12345678$ wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz$ tar -xvf node-v12.16.1-linux-x64.tar.xz $ sudo mv node-v12.16.1-linux-x64 /usr/local/node-v12$ sudo ln -s /usr/local/node-v12/bin/node /bin/node$ sudo ln -s /usr/local/node-v12/bin/npm /bin/npm# 可使用如下命令检测node是否安装成功$ node -v$ npm -v 如果该云服务器是第一次使用git，记得添加一下名称和邮箱 12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 安装Hexo1234$ npm install -g hexo-cli$ sudo ln -s /usr/local/node-v12/bin/hexo /bin/hexo# 检测hexo是否安装成功$ hexo -v 运行Hexo我们需要先初始化一个hexo目录 1$ hexo init &lt;floder name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 要运行hexo,在hexo的目录下使用如下命令即可： 123$ hexo server# 或者$ hexo s 启动服务器后，默认在4000端口启动web服务，此时访问&lt;ip&gt;:4000即可访问到当前hexo站点，此时站点里默认会有一篇快速入门的文章帮助你快速熟悉hexo的使用 想将自己的hexo博客设置成wiki样式，可参考我的上篇文章《使用hexo搭建wiki》进行配置 将本地配置好的wiki移动到云服务器将本地配置好的服务器打包，上传到云服务器，然后解压即可直接使用，有的插件可能要再次npm装一下 实现到云服务器之间的文件实时同步为了方便我们写文章在本地保存完就直接同步到服务器上，我们可以想办法实现一下文件实时同步，将本地文件夹的修改实时同步到云服务器上，这里有一个现成的解决方案：使用坚果云实时同步文件夹。 这里我们使用坚果云软件，我们的主机上下载好坚果云软件，注册登录，建立一个同步文件夹，这里操作很无脑，就不演示了，接下来讲讲没有图形界面的Linux命令行如何同步坚果云： 坚果云提供WebDav接口，这里可以使用davfs工具去挂载WebDav目录 WebDav:WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。有利于用户间协同编辑和管理存储在万维网服务器文档 总之，就是常用于网盘的一种网络协议。 davfs:一种连接WebDav网盘的工具 安装davfs21$ sudo apt install davfs2 配置&amp;挂载davfs2编辑配置文件/etc/davfs2/davfs2.conf，找到如下内容将注释去掉，将0改成1 1# ignore_dav_header 0 编辑配置文件/etc/davfs2/secrets，在配置文件最后添加如下内容： 1https:&#x2F;&#x2F;dav.jianguoyun.com&#x2F;dav 你的坚果云账户 你的webdav应用密码 坚果云WebDav应用密码获取方式： 坚果云官网登录你的坚果云账号 依次点击账户信息—安全选项，即可看到添加WebDav应用的按钮 点击添加应用，名称随意输入，然后就会自动生成一个密码 然后进行挂载 1$ sudo mount.davfs https://dav.jianguoyun.com/dav 你想要挂载的目录 接下来访问该目录即可发现目录里的内容已经和我们坚果云账号创建的实时同步文件夹同步了 接下来，我们将我们的hexo主目录source文件下的_post目录放到我们的坚果云实时同步文件夹下，然后在云服务器软链接（ln -s）到云服务器hexo目录的该位置即可，过于简单就不演示了 到此为止，我们在本地写完文章保存后，云服务器会自动同步文章，接下来在云服务器后台启动hexo s即可实时展示博客更新的内容了： 12$ cd 你的hexo的目录$ nohup /bin/hexo server &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 命令含义详见参考资料 通过脚本生成新的文章模板每次创建新的文章都需要通过命令hexo new name进行，hexo程序为我们生成一个文章模板，但是如果我想只在远程服务器上安装hexo，不想在本地安装hexo呢，这里我们通过一个脚本来实现hexo new的功能，这样即使本地没有hexo，也能写hexo的文章，这里直接给出代码了： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/pythonimport sysimport timeimport osif not sys.argv[1]: print(\"请输入文章标题\") print(\"例如：python hexonew.py title\") sys.exit()title = sys.argv[1]time = time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime())header = f\"\"\"---title: &#123;title&#125; toc: truedate: &#123;time&#125;tags:categories:--- \"\"\"footer = \"\"\"## 参考资料&gt; - []()&gt; - []()\"\"\"text = header + '\\n' + footerurl = os.getcwd() + '/' + title + '.md'with open(url,'w') as f: f.write(text) 通过脚本和命令实现全自动化部署到Github Page为了全自动部署到Github Page，我们可以使用Linux的定时任务，比如每天晚上12点进行一次部署，部署的命令我们写成脚本方便一键执行，这样一来，我们只需要写完内容，然后保存，就能全自动部署到我们的博客上了，而且我们可以在任何机器上写文章，甚至不需要安装任何环境，非常方便。 配置云服务器ssh秘钥连接github生成ssh秘钥 1$ ssh-keygen -t rsa -C \"github邮箱账号\" 找到生成的秘钥，将公钥内容复制，在github上个人设置–SSH and GPG keys–New SSH key添加秘钥 添加完秘钥可使用如下命令测试: 1$ ssh -T git@github.com 这里我遇到了一个错误：git@github.com: Permission denied (publickey)，解决方案我放在参考资料里了。 连接成功的话，会返回类似如下字样： 1Hi kn0sky! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 此时我们到hexo主目录使用一下hexo d命令试一试，此时我们无需输入账号密码即可成功部署 一键脚本使用一键部署脚本便于定时任务的设置，这里使用shell脚本进行部署 不知道什么原因，云服务器的hexo s启动服务器不会因为坚果云同步目录的变更而更新内容，所以这里也定时重启好了 PS：目录地址需要根据自己的情况进行修改 重启脚本： 1234567891011#!/bin/bashcd ~/hexo-wikinum=`ps -elf | grep hexo | grep -v grep | wc -l`if [ $&#123;num&#125; -ne 0 ];then ps -elf | grep hexo | grep -v grep | awk '&#123;print $4&#125;' | xargs kill -9 echo \"[+]已杀死进程\" &gt;&gt; ~/hexo.logfiecho \"--------------\" &gt;&gt; ~/hexo.logecho `date -d now` &gt;&gt; ~/hexo.lognohup /bin/hexo server -p 30808 &gt;&gt; ~/hexo.log 2&gt;&amp;1 &amp; 部署脚本： 123456#!/bin/bashcd ~/hexo-wikinohup hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &gt;&gt; ~/crontab_script/hexo_auto_depoly.log 2&gt;&amp;1 &amp;echo '-----------------------'echo `date -d 'now'` &gt;&gt; ~/crontab_script/blog_auto_deploy.logecho \"[+]完成部署！\" &gt;&gt; ~/crontab_script/blog_auto_deploy.log 这里使用git进行自动部署，git会自动检测提交的内容同上次提交相比是否有变更，如果有，就部署，反之，不部署。 设置定时任务使用crontab工具设置定时任务，使用如下命令进入编辑页面 1$ crontab -e 在配置的最底下添加如下内容： 1234# 每天9点12分的时候运行部署脚本12 9 * * * bash ~/crontab_script/blog_auto_deploy.sh# 每15分钟运行一次hexo 服务重启脚本*/15 * * * * bash ~/crontab_script/blog_auto_server.sh 到此，基本实现hexo全自动部署功能！ 希望对读完的你有所帮助。 参考资料 使用hexo搭建个人wiki 备份Linux操作系统的数据到坚果云的方法 搭建 Node.js 环境 linux shell中”2&gt;&amp;1”含义 nohup和&amp;后台运行，进程查看及终止 git@github.com: Permission denied (publickey) Linux crontab 命令","tags":[],"categories":[{"name":"计算机使用入门学习","slug":"计算机使用入门学习","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"name":"博客搭建","slug":"计算机使用入门学习/博客搭建","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"使用手机扩展电脑屏幕","date":"2020-03-13T10:38:51.000Z","path":"wiki/计算机使用入门学习/手机连接电脑/使用手机扩展电脑屏幕/","text":"Windows 下 使用手机 进行 屏幕扩展多屏幕协同工作可以有效提高工作效率，在一定程度上摆脱窗口反复切换的问题，下面将分别介绍常规和非常规的解决方案。 常规解决方案最常规的方法是整一个显示设备（显示器、投影仪等），HDMI线缆连接，然后显示设置里选择扩展屏幕（也有复制选项） 非常规解决方案通过局域网使用手机/平板/其他Windows电脑进行屏幕扩展这里需要通过spacedesk软件实现，下载地址参考：spacedesk官网 软件分为主机端和扩展端，主机端只能是Windows系统，扩展端可以是Android、Windows、iOS等 软件的安装较为无脑，直接点下一步即可，这里不多啰嗦，Android端apk打不开Google Play商店可通过其他下载站进行下载，例如Freeapk 软件安装完之后，主机和用于扩展屏幕的设备需处于同一局域网下，主机端打开软件，扩展端也打开软件，扩展端会直接在局域网内搜索主机，然后选中要使用扩展的主机即可 PS： Windows系统查看 IP 地址可通过 cmd 命令进行查询： 快捷键Windows + R打开运行 输入 cmd 敲击回车，弹出黑框框 输入ipconfig命令敲击回车，即可查询当前IP 注意：如果手机和电脑分辨率不一样会导致扩展屏的使用体验很糟糕！","tags":[],"categories":[{"name":"计算机使用入门学习","slug":"计算机使用入门学习","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"name":"手机连接电脑","slug":"计算机使用入门学习/手机连接电脑","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91/"}]},{"title":"使用hexo搭建个人wiki","date":"2020-03-12T11:38:51.000Z","path":"wiki/计算机使用入门学习/博客搭建/使用hexo搭建wiki/","text":"Hexo及其环境的安装安装Hexo需要Node.js和Git环境，Hexo安装方法和过程参考官方文档 初始化hexo文件夹：1$ hexo init &lt;floder_name&gt; 初始化完成后，文件夹结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，themes为主题文件目录 hexo的快速入门创建新文章1$ hexo new \"My New Post\" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment PS：Hexo建站各种基本使用方法请参考官方文档 Hexo安装Wikitten主题：PS:这里主题使用相关内容均来自Wikitten主题的文档 安装过程如下： 进入你的hexo文件夹，将主题克隆到themes/路径下 12$ cd your-hexo-directory$ git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 覆盖站点目录中的默认页面模板 12$ cp -rf themes/Wikitten/_source/* source/$ cp -rf themes/Wikitten/_scaffolds/* scaffolds/ 重命名主题中的 _config.yml.example 到 _config.yml，然后可以使用配置文件配置主题 123$ cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# 编辑配置文件，定制你的配置项$ vim themes/Wikitten/_config.yml 安装插件 12345hexo-autonofollow // 打开非本站链接时自动开启新标签页hexo-directory-category // 根据文章文件目录自动为文章添加分类hexo-generator-feed // 生成 RSS 源hexo-generator-json-content // 生成全站文章 json 内容，用于全文搜索hexo-generator-sitemap // 生成全站站点地图 sitemap 安装命令： 1$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap 到这里我们的个人wiki版的hexo站点已经可以运行了，接下来我们需要做一些定制化的配置： 添加插件的配置内容：向站点配置文件（hexo根目录下的_config.yml文件）最后添加如下内容 123456789101112131415161718192021222324252627282930313233## Markdown## https://github.com/hexojs/hexo-renderer-markedmarked: gfm: true ## Plugins: https://hexo.io/plugins/### JsonContentjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml### Adds nofollow attribute to all external links in your hexo blog posts automatically.nofollow: enable: true exclude: - &lt;your site url domain&gt; # eg: zthxxx.me 到这里，我们的wikitten主题的hexo站点已经成功搭建完成 一些个人定制化配置（可选）修改代码块颜色这个主题启用之后，默认代码块的背景颜色是黑色，纯白色的背景配纯黑的代码块背景颜色有点看着不舒服，所以我想将代码块颜色进行修改。 找到主题配置文件找到如下行： 1highlight: monokai 将monokai改成自己想要的主题即可，本站使用的风格是`` PS：可用主题名称可于Wikitten/source/css/_highlight目录下找到，highlightjs网站可进行在线预览。 启用资源文件夹编写.md格式文档过程中，图片的插入是个问题，我们可以引用外部链接，也可以使用本地图片，如果不想使用远程图床的话，这里启用资源文件夹更加便于在文档中插入图片 在站点配置文件夹中，找到如下配置选项，将false改为true即可 1post_asset_folder: false 接下来使用命令(hexo new title)创建新文档的时候，就会自动创建一个资源文件夹 PS：由于之前开启了自动以文件夹来创建分类，所以我们使用资源文件夹的时候，文件夹里不要出现.md文件，不然文件夹也会被认为是一个文章分类 部署到Github Page手动部署这里有两个地方要操作，一个是github，一个是本地配置文件 github创建github page仓库 创建github账号 创建个人仓库，仓库名为用户名.github.io 配置部署到github 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 编辑站点配置文件，找到如下内容： 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: '' 按照如下格式进行修改： 1234deploy: type: git repo: &lt;repository url&gt; branch: master repo：github仓库的url（例如:https://github.com/username/username.github.io.git） branch：分支名称(一般是master) 然后使用如下命令进行部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令执行完成后会提示你输入github账号密码，输入完即完成了提交 接下来可从username.github.io访问到自己的博客了 免密码部署设置 创建SSH密匙 1ssh-keygen -t rsa -C \"GitHub 邮箱\" 复制公钥（生成的.pub的文件）的内容到github–setting–SSH and GPG keys中（标题随便起） 修改站点配置文件，将前面我们的repo改成ssh地址，格式例如： 1234deploy: type: git repository: git@github.com:myname/myname.github.io.git branch: master 然后我们再次使用hexo d进行部署，就不再需要我们填写用户名和密码了 使用脚本一键部署每次部署都需要三条命令，过于麻烦，我们可以写个脚本将三条命令进行简化 以下脚本均放在站点主目录下 shell脚本 12#!/bin/bashhexo clean &amp;&amp; hexo g &amp;&amp; hexo d python脚本 12345#!/usr/bin/python3import osos.system('hexo clean')os.system('hexo g')os.system('hexo d') 设置自定义域名我们也可以使用我们自己的域名来访问我们的博客，首先，我们需要先注册一个域名（比如，可以去腾讯云注册） 然后在我们博客的github仓库设置自定义域名为我们想要访问解析的域名，同时在我们注册域名的地方设置CNAME解析地址为:username.github.io. 稍等片刻即可通过自定义域名访问博客了 不过这里会出现一个问题就是每次部署都会导致CNAME信息需要重新设置，这里我们需要在站点主目录的source目录下创建个CNAME文件，里面写上自己要解析的地址即可 自动化部署到Github Page 使用Travis CI 将 Hexo 博客部署到 GitHub Pages 上可实现自动化部署，只需要我们将站点文件push到github上，即可自动部署成博客 如果不希望自己的站点文件公开的话，还是建议使用上面的手动部署方法 详细教程请参考hexo相关文档 More info: deploy to github page 参考资料 Hexo-Theme-Wikitten中文文档 Hexo文档","tags":[],"categories":[{"name":"计算机使用入门学习","slug":"计算机使用入门学习","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"name":"博客搭建","slug":"计算机使用入门学习/博客搭建","permalink":"http://kn0sky.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]}